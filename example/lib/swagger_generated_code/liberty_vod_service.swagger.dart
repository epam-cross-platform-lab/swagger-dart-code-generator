// ignore_for_file: type=lint

import 'package:json_annotation/json_annotation.dart';
import 'package:collection/collection.dart';
import 'dart:convert';

import 'overriden_models.dart';
import 'package:chopper/chopper.dart';

import 'client_mapping.dart';
import 'dart:async';
import 'package:chopper/chopper.dart' as chopper;
import 'liberty_vod_service.enums.swagger.dart' as enums;
export 'liberty_vod_service.enums.swagger.dart';

part 'liberty_vod_service.swagger.chopper.dart';
part 'liberty_vod_service.swagger.g.dart';

// **************************************************************************
// SwaggerChopperGenerator
// **************************************************************************

@ChopperApi()
abstract class LibertyVodService extends ChopperService {
  static LibertyVodService create({
    ChopperClient? client,
    Authenticator? authenticator,
    Uri? baseUrl,
    Iterable<dynamic>? interceptors,
  }) {
    if (client != null) {
      return _$LibertyVodService(client);
    }

    final newClient = ChopperClient(
        services: [_$LibertyVodService()],
        converter: $JsonSerializableConverter(),
        interceptors: interceptors ?? [],
        authenticator: authenticator,
        baseUrl: baseUrl ?? Uri.parse('http://'));
    return _$LibertyVodService(newClient);
  }

  ///Returns programs that are similar to the most recently watched VoD title (by the same profile).
  ///@param feedCrid feedCrid to find suggestions
  ///@param profileId The user selected profile id
  ///@param isSharedProfile Indicate (for RENG) whether the profileId is the shared (main household) profileId
  ///@param encoding The only encoding that the device or context supports. If provided, content only available in different encoding profiles will be filtered out
  ///@param maxRes The maximum resolution that the device or context supports. Content only available in higher resolutions will be filtered out
  ///@param excludeExternalProviders List of brandingProviderIds to exclude their contents
  ///@param count The maximum number of items to return
  ///@param x-reng-clienttype The value to use towards RENG as the ClientType. If absent, a configured default will be used.
  ///@param x-Claims-Set The claims set generated by the gateway from the claims token as obtained from personalization service. Used to validate that the profileId given, belongs to the customer making the request.
  Future<chopper.Response<FeedComposerResponseWithSeedTitle>>
      feedComposerV1MoreLikeWatchedFromFeedFeedCridGet({
    required String? feedCrid,
    required String? profileId,
    required bool? isSharedProfile,
    enums.FeedComposerV1MoreLikeWatchedFromFeedFeedCridGetEncoding? encoding,
    enums.FeedComposerV1MoreLikeWatchedFromFeedFeedCridGetMaxRes? maxRes,
    String? excludeExternalProviders,
    required int? count,
    String? xRengClienttype,
    String? xClaimsSet,
    String? cacheControl,
  }) {
    generatedMapping.putIfAbsent(FeedComposerResponseWithSeedTitle,
        () => FeedComposerResponseWithSeedTitle.fromJsonFactory);

    return _feedComposerV1MoreLikeWatchedFromFeedFeedCridGet(
        feedCrid: feedCrid,
        profileId: profileId,
        isSharedProfile: isSharedProfile,
        encoding: encoding?.value?.toString(),
        maxRes: maxRes?.value?.toString(),
        excludeExternalProviders: excludeExternalProviders,
        count: count,
        xRengClienttype: xRengClienttype,
        xClaimsSet: xClaimsSet,
        cacheControl: cacheControl);
  }

  ///Returns programs that are similar to the most recently watched VoD title (by the same profile).
  ///@param feedCrid feedCrid to find suggestions
  ///@param profileId The user selected profile id
  ///@param isSharedProfile Indicate (for RENG) whether the profileId is the shared (main household) profileId
  ///@param encoding The only encoding that the device or context supports. If provided, content only available in different encoding profiles will be filtered out
  ///@param maxRes The maximum resolution that the device or context supports. Content only available in higher resolutions will be filtered out
  ///@param excludeExternalProviders List of brandingProviderIds to exclude their contents
  ///@param count The maximum number of items to return
  ///@param x-reng-clienttype The value to use towards RENG as the ClientType. If absent, a configured default will be used.
  ///@param x-Claims-Set The claims set generated by the gateway from the claims token as obtained from personalization service. Used to validate that the profileId given, belongs to the customer making the request.
  @Get(path: '/feed-composer/v1/more-like-watched-from-feed/{feedCrid}')
  Future<chopper.Response<FeedComposerResponseWithSeedTitle>>
      _feedComposerV1MoreLikeWatchedFromFeedFeedCridGet({
    @Path('feedCrid') required String? feedCrid,
    @Query('profileId') required String? profileId,
    @Query('isSharedProfile') required bool? isSharedProfile,
    @Query('encoding') String? encoding,
    @Query('maxRes') String? maxRes,
    @Query('excludeExternalProviders') String? excludeExternalProviders,
    @Query('count') required int? count,
    @Header('x-reng-clienttype') String? xRengClienttype,
    @Header('x-Claims-Set') String? xClaimsSet,
    @Header('Cache-Control') String? cacheControl,
  });

  ///Retrieves the paused items collection
  ///@param profileId The user selected profile id
  ///@param encoding The only encoding that the device or context supports. If provided, content only available in different encoding profiles will be filtered out
  ///@param maxRes The maximum resolution that the device or context supports. Content only available in higher resolutions will be filtered out
  ///@param count The maximum number of items to return
  ///@param filter Comma separated list of filters. The following values are allowed: vod, downloadable, viewableOnCpe
  ///@param x-cus Customer ID
  ///@param x-Claims-Set The claims set generated by the gateway from the claims token as obtained from personalization service. Used to validate that the profileId given, belongs to the customer making the request.
  ///@param x-dev Device ID
  ///@param x-entitlements-token Entitlement Token
  Future<chopper.Response<FeedComposerResponse>> feedComposerV1PausedItemsGet({
    required String? profileId,
    enums.FeedComposerV1PausedItemsGetEncoding? encoding,
    enums.FeedComposerV1PausedItemsGetMaxRes? maxRes,
    required int? count,
    required String? filter,
    String? xCus = 'X-Cus',
    String? xClaimsSet,
    String? xDev,
    String? xEntitlementsToken = 'X-Entitlements-Token',
    String? cacheControl,
  }) {
    generatedMapping.putIfAbsent(
        FeedComposerResponse, () => FeedComposerResponse.fromJsonFactory);

    return _feedComposerV1PausedItemsGet(
        profileId: profileId,
        encoding: encoding?.value?.toString(),
        maxRes: maxRes?.value?.toString(),
        count: count,
        filter: filter,
        xCus: xCus,
        xClaimsSet: xClaimsSet,
        xDev: xDev,
        xEntitlementsToken: xEntitlementsToken,
        cacheControl: cacheControl);
  }

  ///Retrieves the paused items collection
  ///@param profileId The user selected profile id
  ///@param encoding The only encoding that the device or context supports. If provided, content only available in different encoding profiles will be filtered out
  ///@param maxRes The maximum resolution that the device or context supports. Content only available in higher resolutions will be filtered out
  ///@param count The maximum number of items to return
  ///@param filter Comma separated list of filters. The following values are allowed: vod, downloadable, viewableOnCpe
  ///@param x-cus Customer ID
  ///@param x-Claims-Set The claims set generated by the gateway from the claims token as obtained from personalization service. Used to validate that the profileId given, belongs to the customer making the request.
  ///@param x-dev Device ID
  ///@param x-entitlements-token Entitlement Token
  @Get(path: '/feed-composer/v1/paused-items')
  Future<chopper.Response<FeedComposerResponse>> _feedComposerV1PausedItemsGet({
    @Query('profileId') required String? profileId,
    @Query('encoding') String? encoding,
    @Query('maxRes') String? maxRes,
    @Query('count') required int? count,
    @Query('filter') required String? filter,
    @Header('x-cus') String? xCus = 'X-Cus',
    @Header('x-Claims-Set') String? xClaimsSet,
    @Header('x-dev') String? xDev,
    @Header('x-entitlements-token')
        String? xEntitlementsToken = 'X-Entitlements-Token',
    @Header('Cache-Control') String? cacheControl,
  });

  ///Returns programs for which an active TVOD rental exists.
  ///@param brandingProviderId The (optional) id of the branding provider whose content should be considered exclusively
  ///@param encoding The only encoding that the device or context supports. If provided, content only available in different encoding profiles will be filtered out
  ///@param maxRes The maximum resolution that the device or context supports. Content only available in higher resolutions will be filtered out
  ///@param count The maximum number of items to return
  ///@param filter Comma separated list of filters. The following values are allowed: nonAdult, adult, downloadable, viewableOnCpe
  ///@param x-cus Customer ID
  ///@param x-dev Device ID
  ///@param x-entitlements-token Entitlement Token
  Future<chopper.Response<FeedComposerResponseForPurchasedProgram>>
      feedComposerV1PurchasedItemsGet({
    String? brandingProviderId,
    enums.FeedComposerV1PurchasedItemsGetEncoding? encoding,
    enums.FeedComposerV1PurchasedItemsGetMaxRes? maxRes,
    required int? count,
    String? filter,
    String? xCus = 'X-Cus',
    String? xDev,
    String? xEntitlementsToken = 'X-Entitlements-Token',
    String? cacheControl,
  }) {
    generatedMapping.putIfAbsent(FeedComposerResponseForPurchasedProgram,
        () => FeedComposerResponseForPurchasedProgram.fromJsonFactory);

    return _feedComposerV1PurchasedItemsGet(
        brandingProviderId: brandingProviderId,
        encoding: encoding?.value?.toString(),
        maxRes: maxRes?.value?.toString(),
        count: count,
        filter: filter,
        xCus: xCus,
        xDev: xDev,
        xEntitlementsToken: xEntitlementsToken,
        cacheControl: cacheControl);
  }

  ///Returns programs for which an active TVOD rental exists.
  ///@param brandingProviderId The (optional) id of the branding provider whose content should be considered exclusively
  ///@param encoding The only encoding that the device or context supports. If provided, content only available in different encoding profiles will be filtered out
  ///@param maxRes The maximum resolution that the device or context supports. Content only available in higher resolutions will be filtered out
  ///@param count The maximum number of items to return
  ///@param filter Comma separated list of filters. The following values are allowed: nonAdult, adult, downloadable, viewableOnCpe
  ///@param x-cus Customer ID
  ///@param x-dev Device ID
  ///@param x-entitlements-token Entitlement Token
  @Get(path: '/feed-composer/v1/purchased-items')
  Future<chopper.Response<FeedComposerResponseForPurchasedProgram>>
      _feedComposerV1PurchasedItemsGet({
    @Query('brandingProviderId') String? brandingProviderId,
    @Query('encoding') String? encoding,
    @Query('maxRes') String? maxRes,
    @Query('count') required int? count,
    @Query('filter') String? filter,
    @Header('x-cus') String? xCus = 'X-Cus',
    @Header('x-dev') String? xDev,
    @Header('x-entitlements-token')
        String? xEntitlementsToken = 'X-Entitlements-Token',
    @Header('Cache-Control') String? cacheControl,
  });

  ///Returns personal suggested programs
  ///@param areaCrid areaCrid to find suggestions
  ///@param profileId The user selected profile id
  ///@param isSharedProfile Indicate (for RENG) whether the profileId is the shared (main household) profileId
  ///@param encoding The only encoding that the device or context supports. If provided, content only available in different encoding profiles will be filtered out
  ///@param maxRes The maximum resolution that the device or context supports. Content only available in higher resolutions will be filtered out
  ///@param excludeExternalProviders List of brandingProviderIds to exclude their contents
  ///@param count The maximum number of items to return
  ///@param x-reng-clienttype The value to use towards RENG as the ClientType. If absent, a configured default will be used.
  ///@param x-Claims-Set The claims set generated by the gateway from the claims token as obtained from personalization service. Used to validate that the profileId given, belongs to the customer making the request.
  Future<chopper.Response<FeedComposerResponse>>
      feedComposerV1SuggestedFromContentAreaAreaCridGet({
    required String? areaCrid,
    required String? profileId,
    required bool? isSharedProfile,
    enums.FeedComposerV1SuggestedFromContentAreaAreaCridGetEncoding? encoding,
    enums.FeedComposerV1SuggestedFromContentAreaAreaCridGetMaxRes? maxRes,
    String? excludeExternalProviders,
    required int? count,
    String? xRengClienttype,
    String? xClaimsSet,
    String? cacheControl,
  }) {
    generatedMapping.putIfAbsent(
        FeedComposerResponse, () => FeedComposerResponse.fromJsonFactory);

    return _feedComposerV1SuggestedFromContentAreaAreaCridGet(
        areaCrid: areaCrid,
        profileId: profileId,
        isSharedProfile: isSharedProfile,
        encoding: encoding?.value?.toString(),
        maxRes: maxRes?.value?.toString(),
        excludeExternalProviders: excludeExternalProviders,
        count: count,
        xRengClienttype: xRengClienttype,
        xClaimsSet: xClaimsSet,
        cacheControl: cacheControl);
  }

  ///Returns personal suggested programs
  ///@param areaCrid areaCrid to find suggestions
  ///@param profileId The user selected profile id
  ///@param isSharedProfile Indicate (for RENG) whether the profileId is the shared (main household) profileId
  ///@param encoding The only encoding that the device or context supports. If provided, content only available in different encoding profiles will be filtered out
  ///@param maxRes The maximum resolution that the device or context supports. Content only available in higher resolutions will be filtered out
  ///@param excludeExternalProviders List of brandingProviderIds to exclude their contents
  ///@param count The maximum number of items to return
  ///@param x-reng-clienttype The value to use towards RENG as the ClientType. If absent, a configured default will be used.
  ///@param x-Claims-Set The claims set generated by the gateway from the claims token as obtained from personalization service. Used to validate that the profileId given, belongs to the customer making the request.
  @Get(path: '/feed-composer/v1/suggested-from-content-area/{areaCrid}')
  Future<chopper.Response<FeedComposerResponse>>
      _feedComposerV1SuggestedFromContentAreaAreaCridGet({
    @Path('areaCrid') required String? areaCrid,
    @Query('profileId') required String? profileId,
    @Query('isSharedProfile') required bool? isSharedProfile,
    @Query('encoding') String? encoding,
    @Query('maxRes') String? maxRes,
    @Query('excludeExternalProviders') String? excludeExternalProviders,
    @Query('count') required int? count,
    @Header('x-reng-clienttype') String? xRengClienttype,
    @Header('x-Claims-Set') String? xClaimsSet,
    @Header('Cache-Control') String? cacheControl,
  });

  ///Returns personal suggested programs that are of the same genre as the most recently watched VoD title.
  ///@param areaCrid areaCrid to find suggestions
  ///@param profileId The user selected profile id
  ///@param isSharedProfile Indicate (for RENG) whether the profileId is the shared (main household) profileId
  ///@param encoding The only encoding that the device or context supports. If provided, content only available in different encoding profiles will be filtered out
  ///@param maxRes The maximum resolution that the device or context supports. Content only available in higher resolutions will be filtered out
  ///@param excludeExternalProviders List of brandingProviderIds to exclude their contents
  ///@param count The maximum number of items to return
  ///@param x-reng-clienttype The value to use towards RENG as the ClientType. If absent, a configured default will be used.
  ///@param x-Claims-Set The claims set generated by the gateway from the claims token as obtained from personalization service. Used to validate that the profileId given, belongs to the customer making the request.
  Future<chopper.Response<FeedComposerResponseWithSeedTitleAndGenre>>
      feedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGet({
    required String? areaCrid,
    required String? profileId,
    required bool? isSharedProfile,
    enums.FeedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetEncoding?
        encoding,
    enums.FeedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetMaxRes?
        maxRes,
    String? excludeExternalProviders,
    required int? count,
    String? xRengClienttype,
    String? xClaimsSet,
    String? cacheControl,
  }) {
    generatedMapping.putIfAbsent(FeedComposerResponseWithSeedTitleAndGenre,
        () => FeedComposerResponseWithSeedTitleAndGenre.fromJsonFactory);

    return _feedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGet(
        areaCrid: areaCrid,
        profileId: profileId,
        isSharedProfile: isSharedProfile,
        encoding: encoding?.value?.toString(),
        maxRes: maxRes?.value?.toString(),
        excludeExternalProviders: excludeExternalProviders,
        count: count,
        xRengClienttype: xRengClienttype,
        xClaimsSet: xClaimsSet,
        cacheControl: cacheControl);
  }

  ///Returns personal suggested programs that are of the same genre as the most recently watched VoD title.
  ///@param areaCrid areaCrid to find suggestions
  ///@param profileId The user selected profile id
  ///@param isSharedProfile Indicate (for RENG) whether the profileId is the shared (main household) profileId
  ///@param encoding The only encoding that the device or context supports. If provided, content only available in different encoding profiles will be filtered out
  ///@param maxRes The maximum resolution that the device or context supports. Content only available in higher resolutions will be filtered out
  ///@param excludeExternalProviders List of brandingProviderIds to exclude their contents
  ///@param count The maximum number of items to return
  ///@param x-reng-clienttype The value to use towards RENG as the ClientType. If absent, a configured default will be used.
  ///@param x-Claims-Set The claims set generated by the gateway from the claims token as obtained from personalization service. Used to validate that the profileId given, belongs to the customer making the request.
  @Get(
      path:
          '/feed-composer/v1/suggested-from-content-area-by-watched-genre/{areaCrid}')
  Future<chopper.Response<FeedComposerResponseWithSeedTitleAndGenre>>
      _feedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGet({
    @Path('areaCrid') required String? areaCrid,
    @Query('profileId') required String? profileId,
    @Query('isSharedProfile') required bool? isSharedProfile,
    @Query('encoding') String? encoding,
    @Query('maxRes') String? maxRes,
    @Query('excludeExternalProviders') String? excludeExternalProviders,
    @Query('count') required int? count,
    @Header('x-reng-clienttype') String? xRengClienttype,
    @Header('x-Claims-Set') String? xClaimsSet,
    @Header('Cache-Control') String? cacheControl,
  });

  ///Returns the programs on the requested top list.
  ///@param topListId The id of the toplist
  ///@param profileId The user selected profile id
  ///@param isSharedProfile Indicate (for RENG) whether the profileId is the shared (main household) profileId
  ///@param brandingProviderId The (optional) id of the branding provider whose content should be considered exclusively
  ///@param encoding The only encoding that the device or context supports. If provided, content only available in different encoding profiles will be filtered out
  ///@param maxRes The maximum resolution that the device or context supports. Content only available in higher resolutions will be filtered out
  ///@param excludeExternalProviders List of brandingProviderIds to exclude their contents
  ///@param cityId City Identifier of the user.
  ///@param count The maximum number of items to return
  ///@param x-reng-clienttype The value to use towards RENG as the ClientType. If absent, a configured default will be used.
  Future<chopper.Response<FeedComposerResponse>>
      feedComposerV1TopListTopListIdGet({
    required String? topListId,
    String? profileId,
    bool? isSharedProfile,
    String? brandingProviderId,
    enums.FeedComposerV1TopListTopListIdGetEncoding? encoding,
    enums.FeedComposerV1TopListTopListIdGetMaxRes? maxRes,
    String? excludeExternalProviders,
    String? cityId,
    required int? count,
    String? xRengClienttype,
    String? cacheControl,
  }) {
    generatedMapping.putIfAbsent(
        FeedComposerResponse, () => FeedComposerResponse.fromJsonFactory);

    return _feedComposerV1TopListTopListIdGet(
        topListId: topListId,
        profileId: profileId,
        isSharedProfile: isSharedProfile,
        brandingProviderId: brandingProviderId,
        encoding: encoding?.value?.toString(),
        maxRes: maxRes?.value?.toString(),
        excludeExternalProviders: excludeExternalProviders,
        cityId: cityId,
        count: count,
        xRengClienttype: xRengClienttype,
        cacheControl: cacheControl);
  }

  ///Returns the programs on the requested top list.
  ///@param topListId The id of the toplist
  ///@param profileId The user selected profile id
  ///@param isSharedProfile Indicate (for RENG) whether the profileId is the shared (main household) profileId
  ///@param brandingProviderId The (optional) id of the branding provider whose content should be considered exclusively
  ///@param encoding The only encoding that the device or context supports. If provided, content only available in different encoding profiles will be filtered out
  ///@param maxRes The maximum resolution that the device or context supports. Content only available in higher resolutions will be filtered out
  ///@param excludeExternalProviders List of brandingProviderIds to exclude their contents
  ///@param cityId City Identifier of the user.
  ///@param count The maximum number of items to return
  ///@param x-reng-clienttype The value to use towards RENG as the ClientType. If absent, a configured default will be used.
  @Get(path: '/feed-composer/v1/top-list/{topListId}')
  Future<chopper.Response<FeedComposerResponse>>
      _feedComposerV1TopListTopListIdGet({
    @Path('topListId') required String? topListId,
    @Query('profileId') String? profileId,
    @Query('isSharedProfile') bool? isSharedProfile,
    @Query('brandingProviderId') String? brandingProviderId,
    @Query('encoding') String? encoding,
    @Query('maxRes') String? maxRes,
    @Query('excludeExternalProviders') String? excludeExternalProviders,
    @Query('cityId') String? cityId,
    @Query('count') required int? count,
    @Header('x-reng-clienttype') String? xRengClienttype,
    @Header('Cache-Control') String? cacheControl,
  });

  ///Returns personal recommended programs.
  ///@param profileId The user selected profile id
  ///@param isSharedProfile Indicate (for RENG) whether the profileId is the shared (main household) profileId
  ///@param encoding The only encoding that the device or context supports. If provided, content only available in different encoding profiles will be filtered out
  ///@param maxRes The maximum resolution that the device or context supports. Content only available in higher resolutions will be filtered out
  ///@param excludeExternalProviders List of brandingProviderIds to exclude their contents
  ///@param count The maximum number of items to return
  ///@param x-reng-clienttype The value to use towards RENG as the ClientType. If absent, a configured default will be used.
  ///@param x-Claims-Set The claims set generated by the gateway from the claims token as obtained from personalization service. Used to validate that the profileId given, belongs to the customer making the request.
  Future<chopper.Response<FeedComposerResponse>>
      feedComposerV1UserRecommendedGet({
    required String? profileId,
    required bool? isSharedProfile,
    enums.FeedComposerV1UserRecommendedGetEncoding? encoding,
    enums.FeedComposerV1UserRecommendedGetMaxRes? maxRes,
    String? excludeExternalProviders,
    required int? count,
    String? xRengClienttype,
    String? xClaimsSet,
    String? cacheControl,
  }) {
    generatedMapping.putIfAbsent(
        FeedComposerResponse, () => FeedComposerResponse.fromJsonFactory);

    return _feedComposerV1UserRecommendedGet(
        profileId: profileId,
        isSharedProfile: isSharedProfile,
        encoding: encoding?.value?.toString(),
        maxRes: maxRes?.value?.toString(),
        excludeExternalProviders: excludeExternalProviders,
        count: count,
        xRengClienttype: xRengClienttype,
        xClaimsSet: xClaimsSet,
        cacheControl: cacheControl);
  }

  ///Returns personal recommended programs.
  ///@param profileId The user selected profile id
  ///@param isSharedProfile Indicate (for RENG) whether the profileId is the shared (main household) profileId
  ///@param encoding The only encoding that the device or context supports. If provided, content only available in different encoding profiles will be filtered out
  ///@param maxRes The maximum resolution that the device or context supports. Content only available in higher resolutions will be filtered out
  ///@param excludeExternalProviders List of brandingProviderIds to exclude their contents
  ///@param count The maximum number of items to return
  ///@param x-reng-clienttype The value to use towards RENG as the ClientType. If absent, a configured default will be used.
  ///@param x-Claims-Set The claims set generated by the gateway from the claims token as obtained from personalization service. Used to validate that the profileId given, belongs to the customer making the request.
  @Get(path: '/feed-composer/v1/user-recommended')
  Future<chopper.Response<FeedComposerResponse>>
      _feedComposerV1UserRecommendedGet({
    @Query('profileId') required String? profileId,
    @Query('isSharedProfile') required bool? isSharedProfile,
    @Query('encoding') String? encoding,
    @Query('maxRes') String? maxRes,
    @Query('excludeExternalProviders') String? excludeExternalProviders,
    @Query('count') required int? count,
    @Header('x-reng-clienttype') String? xRengClienttype,
    @Header('x-Claims-Set') String? xClaimsSet,
    @Header('Cache-Control') String? cacheControl,
  });

  ///Returns personal suggested programs that are of the same genre as the most recently watched VoD title
  ///@param profileId The user selected profile id
  ///@param isSharedProfile Indicate (for RENG) whether the profileId is the shared (main household) profileId
  ///@param encoding The only encoding that the device or context supports. If provided, content only available in different encoding profiles will be filtered out
  ///@param maxRes The maximum resolution that the device or context supports. Content only available in higher resolutions will be filtered out
  ///@param excludeExternalProviders List of brandingProviderIds to exclude their contents
  ///@param count The maximum number of items to return
  ///@param x-reng-clienttype The value to use towards RENG as the ClientType. If absent, a configured default will be used.
  ///@param x-Claims-Set The claims set generated by the gateway from the claims token as obtained from personalization service. Used to validate that the profileId given, belongs to the customer making the request.
  Future<chopper.Response<FeedComposerResponseWithSeedTitleAndGenre>>
      feedComposerV1UserRecommendedByWatchedGenreGet({
    required String? profileId,
    required bool? isSharedProfile,
    enums.FeedComposerV1UserRecommendedByWatchedGenreGetEncoding? encoding,
    enums.FeedComposerV1UserRecommendedByWatchedGenreGetMaxRes? maxRes,
    String? excludeExternalProviders,
    required int? count,
    String? xRengClienttype,
    String? xClaimsSet,
    String? cacheControl,
  }) {
    generatedMapping.putIfAbsent(FeedComposerResponseWithSeedTitleAndGenre,
        () => FeedComposerResponseWithSeedTitleAndGenre.fromJsonFactory);

    return _feedComposerV1UserRecommendedByWatchedGenreGet(
        profileId: profileId,
        isSharedProfile: isSharedProfile,
        encoding: encoding?.value?.toString(),
        maxRes: maxRes?.value?.toString(),
        excludeExternalProviders: excludeExternalProviders,
        count: count,
        xRengClienttype: xRengClienttype,
        xClaimsSet: xClaimsSet,
        cacheControl: cacheControl);
  }

  ///Returns personal suggested programs that are of the same genre as the most recently watched VoD title
  ///@param profileId The user selected profile id
  ///@param isSharedProfile Indicate (for RENG) whether the profileId is the shared (main household) profileId
  ///@param encoding The only encoding that the device or context supports. If provided, content only available in different encoding profiles will be filtered out
  ///@param maxRes The maximum resolution that the device or context supports. Content only available in higher resolutions will be filtered out
  ///@param excludeExternalProviders List of brandingProviderIds to exclude their contents
  ///@param count The maximum number of items to return
  ///@param x-reng-clienttype The value to use towards RENG as the ClientType. If absent, a configured default will be used.
  ///@param x-Claims-Set The claims set generated by the gateway from the claims token as obtained from personalization service. Used to validate that the profileId given, belongs to the customer making the request.
  @Get(path: '/feed-composer/v1/user-recommended-by-watched-genre')
  Future<chopper.Response<FeedComposerResponseWithSeedTitleAndGenre>>
      _feedComposerV1UserRecommendedByWatchedGenreGet({
    @Query('profileId') required String? profileId,
    @Query('isSharedProfile') required bool? isSharedProfile,
    @Query('encoding') String? encoding,
    @Query('maxRes') String? maxRes,
    @Query('excludeExternalProviders') String? excludeExternalProviders,
    @Query('count') required int? count,
    @Header('x-reng-clienttype') String? xRengClienttype,
    @Header('x-Claims-Set') String? xClaimsSet,
    @Header('Cache-Control') String? cacheControl,
  });

  ///Returns items on the user's watch list
  ///@param profileId The user selected profile id
  ///@param encoding The only encoding that the device or context supports. If provided, content only available in different encoding profiles will be filtered out
  ///@param maxRes The maximum resolution that the device or context supports. Content only available in higher resolutions will be filtered out
  ///@param excludeExternalProviders List of brandingProviderIds to exclude their contents
  ///@param count The maximum number of items to return
  ///@param filter Comma separated list of filters. The following values are allowed: vod, downloadable, viewableOnCpe
  ///@param x-cus Customer ID
  ///@param x-Claims-Set The claims set generated by the gateway from the claims token as obtained from personalization service. Used to validate that the profileId given, belongs to the customer making the request.
  ///@param x-dev Device ID
  ///@param x-entitlements-token Entitlement Token
  Future<chopper.Response<FeedComposerResponse>> feedComposerV1WatchlistGet({
    required String? profileId,
    enums.FeedComposerV1WatchlistGetEncoding? encoding,
    enums.FeedComposerV1WatchlistGetMaxRes? maxRes,
    String? excludeExternalProviders,
    required int? count,
    required String? filter,
    String? xCus = 'X-Cus',
    String? xClaimsSet,
    String? xDev,
    String? xEntitlementsToken = 'X-Entitlements-Token',
    String? cacheControl,
  }) {
    generatedMapping.putIfAbsent(
        FeedComposerResponse, () => FeedComposerResponse.fromJsonFactory);

    return _feedComposerV1WatchlistGet(
        profileId: profileId,
        encoding: encoding?.value?.toString(),
        maxRes: maxRes?.value?.toString(),
        excludeExternalProviders: excludeExternalProviders,
        count: count,
        filter: filter,
        xCus: xCus,
        xClaimsSet: xClaimsSet,
        xDev: xDev,
        xEntitlementsToken: xEntitlementsToken,
        cacheControl: cacheControl);
  }

  ///Returns items on the user's watch list
  ///@param profileId The user selected profile id
  ///@param encoding The only encoding that the device or context supports. If provided, content only available in different encoding profiles will be filtered out
  ///@param maxRes The maximum resolution that the device or context supports. Content only available in higher resolutions will be filtered out
  ///@param excludeExternalProviders List of brandingProviderIds to exclude their contents
  ///@param count The maximum number of items to return
  ///@param filter Comma separated list of filters. The following values are allowed: vod, downloadable, viewableOnCpe
  ///@param x-cus Customer ID
  ///@param x-Claims-Set The claims set generated by the gateway from the claims token as obtained from personalization service. Used to validate that the profileId given, belongs to the customer making the request.
  ///@param x-dev Device ID
  ///@param x-entitlements-token Entitlement Token
  @Get(path: '/feed-composer/v1/watchlist')
  Future<chopper.Response<FeedComposerResponse>> _feedComposerV1WatchlistGet({
    @Query('profileId') required String? profileId,
    @Query('encoding') String? encoding,
    @Query('maxRes') String? maxRes,
    @Query('excludeExternalProviders') String? excludeExternalProviders,
    @Query('count') required int? count,
    @Query('filter') required String? filter,
    @Header('x-cus') String? xCus = 'X-Cus',
    @Header('x-Claims-Set') String? xClaimsSet,
    @Header('x-dev') String? xDev,
    @Header('x-entitlements-token')
        String? xEntitlementsToken = 'X-Entitlements-Token',
    @Header('Cache-Control') String? cacheControl,
  });

  ///Retrieves the continue watching collection
  ///@param profileId The user selected profile id
  ///@param encoding The only encoding that the device or context supports. If provided, content only available in different encoding profiles will be filtered out
  ///@param maxRes The maximum resolution that the device or context supports. Content only available in higher resolutions will be filtered out
  ///@param count The maximum number of items to return
  ///@param filter Comma separated list of filters. The following values are allowed: vod, downloadable, viewableOnCpe
  ///@param x-cus Customer ID
  ///@param x-Claims-Set The claims set generated by the gateway from the claims token as obtained from personalization service. Used to validate that the profileId given, belongs to the customer making the request.
  ///@param x-dev Device ID
  ///@param x-entitlements-token Entitlement Token
  Future<chopper.Response<FeedComposerResponse>>
      feedComposerV1ContinueWatchingGet({
    required String? profileId,
    enums.FeedComposerV1ContinueWatchingGetEncoding? encoding,
    enums.FeedComposerV1ContinueWatchingGetMaxRes? maxRes,
    required int? count,
    required String? filter,
    String? xCus = 'X-Cus',
    String? xClaimsSet,
    String? xDev,
    String? xEntitlementsToken = 'X-Entitlements-Token',
    String? cacheControl,
  }) {
    generatedMapping.putIfAbsent(
        FeedComposerResponse, () => FeedComposerResponse.fromJsonFactory);

    return _feedComposerV1ContinueWatchingGet(
        profileId: profileId,
        encoding: encoding?.value?.toString(),
        maxRes: maxRes?.value?.toString(),
        count: count,
        filter: filter,
        xCus: xCus,
        xClaimsSet: xClaimsSet,
        xDev: xDev,
        xEntitlementsToken: xEntitlementsToken,
        cacheControl: cacheControl);
  }

  ///Retrieves the continue watching collection
  ///@param profileId The user selected profile id
  ///@param encoding The only encoding that the device or context supports. If provided, content only available in different encoding profiles will be filtered out
  ///@param maxRes The maximum resolution that the device or context supports. Content only available in higher resolutions will be filtered out
  ///@param count The maximum number of items to return
  ///@param filter Comma separated list of filters. The following values are allowed: vod, downloadable, viewableOnCpe
  ///@param x-cus Customer ID
  ///@param x-Claims-Set The claims set generated by the gateway from the claims token as obtained from personalization service. Used to validate that the profileId given, belongs to the customer making the request.
  ///@param x-dev Device ID
  ///@param x-entitlements-token Entitlement Token
  @Get(path: '/feed-composer/v1/continue-watching')
  Future<chopper.Response<FeedComposerResponse>>
      _feedComposerV1ContinueWatchingGet({
    @Query('profileId') required String? profileId,
    @Query('encoding') String? encoding,
    @Query('maxRes') String? maxRes,
    @Query('count') required int? count,
    @Query('filter') required String? filter,
    @Header('x-cus') String? xCus = 'X-Cus',
    @Header('x-Claims-Set') String? xClaimsSet,
    @Header('x-dev') String? xDev,
    @Header('x-entitlements-token')
        String? xEntitlementsToken = 'X-Entitlements-Token',
    @Header('Cache-Control') String? cacheControl,
  });

  ///Returns the programs as set up in the editorial feed.
  ///@param feedCrid The id of the editorial feed
  ///@param filter Comma separated list of filters. The following values are allowed: lastChance, newArrivals, downloadable, viewableOnCpe
  ///@param brandingProviderId The (optional) id of the branding provider whose content should be considered exclusively
  ///@param encoding The only encoding that the device or context supports. If provided, content only available in different encoding profiles will be filtered out
  ///@param maxRes The maximum resolution that the device or context supports. Content only available in higher resolutions will be filtered out
  ///@param excludeExternalProviders List of brandingProviderIds to exclude their contents
  ///@param cityId City Identifier of the user.
  ///@param count The maximum number of items to return
  ///@param language The metadata language to use for sorting. Used and required only when sorting either nameAZ or nameZA
  ///@param sorting The sorting option. Default is editorial
  ///@param page The 0-based page number (using count as page size)
  Future<chopper.Response<FeedComposerResponseWithTotalCount>>
      feedComposerV1EditorialFeedFeedCridGet({
    required String? feedCrid,
    String? filter,
    String? brandingProviderId,
    enums.FeedComposerV1EditorialFeedFeedCridGetEncoding? encoding,
    enums.FeedComposerV1EditorialFeedFeedCridGetMaxRes? maxRes,
    String? excludeExternalProviders,
    String? cityId,
    required int? count,
    String? language,
    enums.FeedComposerV1EditorialFeedFeedCridGetSorting? sorting,
    int? page,
    String? cacheControl,
  }) {
    generatedMapping.putIfAbsent(FeedComposerResponseWithTotalCount,
        () => FeedComposerResponseWithTotalCount.fromJsonFactory);

    return _feedComposerV1EditorialFeedFeedCridGet(
        feedCrid: feedCrid,
        filter: filter,
        brandingProviderId: brandingProviderId,
        encoding: encoding?.value?.toString(),
        maxRes: maxRes?.value?.toString(),
        excludeExternalProviders: excludeExternalProviders,
        cityId: cityId,
        count: count,
        language: language,
        sorting: sorting?.value?.toString(),
        page: page,
        cacheControl: cacheControl);
  }

  ///Returns the programs as set up in the editorial feed.
  ///@param feedCrid The id of the editorial feed
  ///@param filter Comma separated list of filters. The following values are allowed: lastChance, newArrivals, downloadable, viewableOnCpe
  ///@param brandingProviderId The (optional) id of the branding provider whose content should be considered exclusively
  ///@param encoding The only encoding that the device or context supports. If provided, content only available in different encoding profiles will be filtered out
  ///@param maxRes The maximum resolution that the device or context supports. Content only available in higher resolutions will be filtered out
  ///@param excludeExternalProviders List of brandingProviderIds to exclude their contents
  ///@param cityId City Identifier of the user.
  ///@param count The maximum number of items to return
  ///@param language The metadata language to use for sorting. Used and required only when sorting either nameAZ or nameZA
  ///@param sorting The sorting option. Default is editorial
  ///@param page The 0-based page number (using count as page size)
  @Get(path: '/feed-composer/v1/editorial-feed/{feedCrid}')
  Future<chopper.Response<FeedComposerResponseWithTotalCount>>
      _feedComposerV1EditorialFeedFeedCridGet({
    @Path('feedCrid') required String? feedCrid,
    @Query('filter') String? filter,
    @Query('brandingProviderId') String? brandingProviderId,
    @Query('encoding') String? encoding,
    @Query('maxRes') String? maxRes,
    @Query('excludeExternalProviders') String? excludeExternalProviders,
    @Query('cityId') String? cityId,
    @Query('count') required int? count,
    @Query('language') String? language,
    @Query('sorting') String? sorting,
    @Query('page') int? page,
    @Header('Cache-Control') String? cacheControl,
  });

  ///Returns programs that are similar to the most recently watched VoD title (by the same profile)
  ///@param profileId The user selected profile id
  ///@param isSharedProfile Indicate (for RENG) whether the profileId is the shared (main household) profileId
  ///@param encoding The only encoding that the device or context supports. If provided, content only available in different encoding profiles will be filtered out
  ///@param maxRes The maximum resolution that the device or context supports. Content only available in higher resolutions will be filtered out
  ///@param excludeExternalProviders List of brandingProviderIds to exclude their contents
  ///@param count The maximum number of items to return
  ///@param x-reng-clienttype The value to use towards RENG as the ClientType. If absent, a configured default will be used.
  ///@param x-Claims-Set The claims set generated by the gateway from the claims token as obtained from personalization service. Used to validate that the profileId given, belongs to the customer making the request.
  Future<chopper.Response<FeedComposerResponseWithSeedTitle>>
      feedComposerV1MoreLikeWatchedGet({
    required String? profileId,
    required bool? isSharedProfile,
    enums.FeedComposerV1MoreLikeWatchedGetEncoding? encoding,
    enums.FeedComposerV1MoreLikeWatchedGetMaxRes? maxRes,
    String? excludeExternalProviders,
    required int? count,
    String? xRengClienttype,
    String? xClaimsSet,
    String? cacheControl,
  }) {
    generatedMapping.putIfAbsent(FeedComposerResponseWithSeedTitle,
        () => FeedComposerResponseWithSeedTitle.fromJsonFactory);

    return _feedComposerV1MoreLikeWatchedGet(
        profileId: profileId,
        isSharedProfile: isSharedProfile,
        encoding: encoding?.value?.toString(),
        maxRes: maxRes?.value?.toString(),
        excludeExternalProviders: excludeExternalProviders,
        count: count,
        xRengClienttype: xRengClienttype,
        xClaimsSet: xClaimsSet,
        cacheControl: cacheControl);
  }

  ///Returns programs that are similar to the most recently watched VoD title (by the same profile)
  ///@param profileId The user selected profile id
  ///@param isSharedProfile Indicate (for RENG) whether the profileId is the shared (main household) profileId
  ///@param encoding The only encoding that the device or context supports. If provided, content only available in different encoding profiles will be filtered out
  ///@param maxRes The maximum resolution that the device or context supports. Content only available in higher resolutions will be filtered out
  ///@param excludeExternalProviders List of brandingProviderIds to exclude their contents
  ///@param count The maximum number of items to return
  ///@param x-reng-clienttype The value to use towards RENG as the ClientType. If absent, a configured default will be used.
  ///@param x-Claims-Set The claims set generated by the gateway from the claims token as obtained from personalization service. Used to validate that the profileId given, belongs to the customer making the request.
  @Get(path: '/feed-composer/v1/more-like-watched')
  Future<chopper.Response<FeedComposerResponseWithSeedTitle>>
      _feedComposerV1MoreLikeWatchedGet({
    @Query('profileId') required String? profileId,
    @Query('isSharedProfile') required bool? isSharedProfile,
    @Query('encoding') String? encoding,
    @Query('maxRes') String? maxRes,
    @Query('excludeExternalProviders') String? excludeExternalProviders,
    @Query('count') required int? count,
    @Header('x-reng-clienttype') String? xRengClienttype,
    @Header('x-Claims-Set') String? xClaimsSet,
    @Header('Cache-Control') String? cacheControl,
  });

  ///Returns programs that are similar to the most recently watched VoD title (by the same profile), and are of the same genre
  ///@param profileId The user selected profile id
  ///@param isSharedProfile Indicate (for RENG) whether the profileId is the shared (main household) profileId
  ///@param encoding The only encoding that the device or context supports. If provided, content only available in different encoding profiles will be filtered out
  ///@param maxRes The maximum resolution that the device or context supports. Content only available in higher resolutions will be filtered out
  ///@param excludeExternalProviders List of brandingProviderIds to exclude their contents
  ///@param count The maximum number of items to return
  ///@param x-reng-clienttype The value to use towards RENG as the ClientType. If absent, a configured default will be used.
  ///@param x-Claims-Set The claims set generated by the gateway from the claims token as obtained from personalization service. Used to validate that the profileId given, belongs to the customer making the request.
  Future<chopper.Response<FeedComposerResponseWithSeedTitleAndGenre>>
      feedComposerV1MoreLikeWatchedGenreGet({
    required String? profileId,
    required bool? isSharedProfile,
    enums.FeedComposerV1MoreLikeWatchedGenreGetEncoding? encoding,
    enums.FeedComposerV1MoreLikeWatchedGenreGetMaxRes? maxRes,
    String? excludeExternalProviders,
    required int? count,
    String? xRengClienttype,
    String? xClaimsSet,
    String? cacheControl,
  }) {
    generatedMapping.putIfAbsent(FeedComposerResponseWithSeedTitleAndGenre,
        () => FeedComposerResponseWithSeedTitleAndGenre.fromJsonFactory);

    return _feedComposerV1MoreLikeWatchedGenreGet(
        profileId: profileId,
        isSharedProfile: isSharedProfile,
        encoding: encoding?.value?.toString(),
        maxRes: maxRes?.value?.toString(),
        excludeExternalProviders: excludeExternalProviders,
        count: count,
        xRengClienttype: xRengClienttype,
        xClaimsSet: xClaimsSet,
        cacheControl: cacheControl);
  }

  ///Returns programs that are similar to the most recently watched VoD title (by the same profile), and are of the same genre
  ///@param profileId The user selected profile id
  ///@param isSharedProfile Indicate (for RENG) whether the profileId is the shared (main household) profileId
  ///@param encoding The only encoding that the device or context supports. If provided, content only available in different encoding profiles will be filtered out
  ///@param maxRes The maximum resolution that the device or context supports. Content only available in higher resolutions will be filtered out
  ///@param excludeExternalProviders List of brandingProviderIds to exclude their contents
  ///@param count The maximum number of items to return
  ///@param x-reng-clienttype The value to use towards RENG as the ClientType. If absent, a configured default will be used.
  ///@param x-Claims-Set The claims set generated by the gateway from the claims token as obtained from personalization service. Used to validate that the profileId given, belongs to the customer making the request.
  @Get(path: '/feed-composer/v1/more-like-watched-genre')
  Future<chopper.Response<FeedComposerResponseWithSeedTitleAndGenre>>
      _feedComposerV1MoreLikeWatchedGenreGet({
    @Query('profileId') required String? profileId,
    @Query('isSharedProfile') required bool? isSharedProfile,
    @Query('encoding') String? encoding,
    @Query('maxRes') String? maxRes,
    @Query('excludeExternalProviders') String? excludeExternalProviders,
    @Query('count') required int? count,
    @Header('x-reng-clienttype') String? xRengClienttype,
    @Header('x-Claims-Set') String? xClaimsSet,
    @Header('Cache-Control') String? cacheControl,
  });

  ///Returns collaborative recommended programs (a.k.a. People who like this also like...)
  ///@param profileId The user selected profile id
  ///@param isSharedProfile Indicate (for RENG) whether the profileId is the shared (main household) profileId
  ///@param encoding The only encoding that the device or context supports. If provided, content only available in different encoding profiles will be filtered out
  ///@param maxRes The maximum resolution that the device or context supports. Content only available in higher resolutions will be filtered out
  ///@param excludeExternalProviders List of brandingProviderIds to exclude their contents
  ///@param count The maximum number of items to return
  ///@param x-reng-clienttype The value to use towards RENG as the ClientType. If absent, a configured default will be used.
  ///@param x-Claims-Set The claims set generated by the gateway from the claims token as obtained from personalization service. Used to validate that the profileId given, belongs to the customer making the request.
  Future<chopper.Response<FeedComposerResponseWithSeedTitle>>
      feedComposerV1CollaborativeRecommendationsGet({
    required String? profileId,
    required enums.FeedComposerV1CollaborativeRecommendationsGetIsSharedProfile?
        isSharedProfile,
    enums.FeedComposerV1CollaborativeRecommendationsGetEncoding? encoding,
    enums.FeedComposerV1CollaborativeRecommendationsGetMaxRes? maxRes,
    String? excludeExternalProviders,
    required int? count,
    String? xRengClienttype,
    String? xClaimsSet,
    String? cacheControl,
  }) {
    generatedMapping.putIfAbsent(FeedComposerResponseWithSeedTitle,
        () => FeedComposerResponseWithSeedTitle.fromJsonFactory);

    return _feedComposerV1CollaborativeRecommendationsGet(
        profileId: profileId,
        isSharedProfile: isSharedProfile?.value?.toString(),
        encoding: encoding?.value?.toString(),
        maxRes: maxRes?.value?.toString(),
        excludeExternalProviders: excludeExternalProviders,
        count: count,
        xRengClienttype: xRengClienttype,
        xClaimsSet: xClaimsSet,
        cacheControl: cacheControl);
  }

  ///Returns collaborative recommended programs (a.k.a. People who like this also like...)
  ///@param profileId The user selected profile id
  ///@param isSharedProfile Indicate (for RENG) whether the profileId is the shared (main household) profileId
  ///@param encoding The only encoding that the device or context supports. If provided, content only available in different encoding profiles will be filtered out
  ///@param maxRes The maximum resolution that the device or context supports. Content only available in higher resolutions will be filtered out
  ///@param excludeExternalProviders List of brandingProviderIds to exclude their contents
  ///@param count The maximum number of items to return
  ///@param x-reng-clienttype The value to use towards RENG as the ClientType. If absent, a configured default will be used.
  ///@param x-Claims-Set The claims set generated by the gateway from the claims token as obtained from personalization service. Used to validate that the profileId given, belongs to the customer making the request.
  @Get(path: '/feed-composer/v1/collaborative-recommendations')
  Future<chopper.Response<FeedComposerResponseWithSeedTitle>>
      _feedComposerV1CollaborativeRecommendationsGet({
    @Query('profileId') required String? profileId,
    @Query('isSharedProfile') required String? isSharedProfile,
    @Query('encoding') String? encoding,
    @Query('maxRes') String? maxRes,
    @Query('excludeExternalProviders') String? excludeExternalProviders,
    @Query('count') required int? count,
    @Header('x-reng-clienttype') String? xRengClienttype,
    @Header('x-Claims-Set') String? xClaimsSet,
    @Header('Cache-Control') String? cacheControl,
  });

  ///Retrieves the main menu (aka vodstructure)
  ///@param rootId The root logical key of soft link
  ///@param language The two character language code
  ///@param fallbackRootId The root link to fallback to
  ///@param encoding Supported encoding type for content instance selection
  ///@param maxRes The maximum resolution supported for content instance selection
  ///@param excludeAdult boolean flag when set to true indicating to remove any content that is adult
  ///@param featureFlags Comma Separated Values  of the features that clients supports
  ///@param x-cus Customer ID
  ///@param x-dev Device ID
  ///@param x-entitlements-token Token containing entitlements info
  Future<chopper.Response<Structure>> v2VodstructureRootIdGet({
    required String? rootId,
    required String? language,
    String? fallbackRootId,
    enums.V2VodstructureRootIdGetEncoding? encoding,
    enums.V2VodstructureRootIdGetMaxRes? maxRes,
    bool? excludeAdult,
    String? featureFlags,
    String? xCus = 'X-Cus',
    String? xDev,
    String? xEntitlementsToken = 'X-Entitlements-Token',
    String? cacheControl,
  }) {
    generatedMapping.putIfAbsent(Structure, () => Structure.fromJsonFactory);

    return _v2VodstructureRootIdGet(
        rootId: rootId,
        language: language,
        fallbackRootId: fallbackRootId,
        encoding: encoding?.value?.toString(),
        maxRes: maxRes?.value?.toString(),
        excludeAdult: excludeAdult,
        featureFlags: featureFlags,
        xCus: xCus,
        xDev: xDev,
        xEntitlementsToken: xEntitlementsToken,
        cacheControl: cacheControl);
  }

  ///Retrieves the main menu (aka vodstructure)
  ///@param rootId The root logical key of soft link
  ///@param language The two character language code
  ///@param fallbackRootId The root link to fallback to
  ///@param encoding Supported encoding type for content instance selection
  ///@param maxRes The maximum resolution supported for content instance selection
  ///@param excludeAdult boolean flag when set to true indicating to remove any content that is adult
  ///@param featureFlags Comma Separated Values  of the features that clients supports
  ///@param x-cus Customer ID
  ///@param x-dev Device ID
  ///@param x-entitlements-token Token containing entitlements info
  @Get(path: '/v2/vodstructure/{rootId}')
  Future<chopper.Response<Structure>> _v2VodstructureRootIdGet({
    @Path('rootId') required String? rootId,
    @Query('language') required String? language,
    @Query('fallbackRootId') String? fallbackRootId,
    @Query('encoding') String? encoding,
    @Query('maxRes') String? maxRes,
    @Query('excludeAdult') bool? excludeAdult,
    @Query('featureFlags') String? featureFlags,
    @Header('x-cus') String? xCus = 'X-Cus',
    @Header('x-dev') String? xDev,
    @Header('x-entitlements-token')
        String? xEntitlementsToken = 'X-Entitlements-Token',
    @Header('Cache-Control') String? cacheControl,
  });

  ///Retrieves the contextual menu
  ///@param rootId The root logical key of soft link
  ///@param language The two character language code
  ///@param profileId The user selected profile id
  ///@param optIn The user setting for personalized recommendations
  ///@param sharedProfile Indicator of a shared profile (default) or a personal one
  ///@param encoding Supported encoding type for content instance selection
  ///@param maxRes The maximum resolution supported for content instance selection
  ///@param cityId City Identifier of the user.
  ///@param includeExternalProvider If present, the contents from the 'external provider(s)' are included in the results. Value can be a comma separated list.
  ///@param replayOptedInTime Parameter to pass on to the picker service for season count calculation.
  ///@param mergingOn Parameter to indicate whether season count merging has to be done by picker service.
  ///@param excludeAdult boolean flag when set to true indicating to remove any content that is adult
  ///@param featureFlags Comma Separated Values  of the features that clients supports
  ///@param x-cus Customer ID
  ///@param x-dev Device ID
  ///@param x-entitlements-token Token containing entitlements info
  Future<chopper.Response<Screen>> v2ContextualvodRootIdGet({
    required String? rootId,
    required String? language,
    String? profileId,
    bool? optIn,
    bool? sharedProfile,
    enums.V2ContextualvodRootIdGetEncoding? encoding,
    enums.V2ContextualvodRootIdGetMaxRes? maxRes,
    String? cityId,
    String? includeExternalProvider,
    int? replayOptedInTime,
    bool? mergingOn,
    bool? excludeAdult,
    String? featureFlags,
    String? xCus = 'X-Cus',
    String? xDev,
    String? xEntitlementsToken = 'X-Entitlements-Token',
    String? cacheControl,
  }) {
    generatedMapping.putIfAbsent(Screen, () => Screen.fromJsonFactory);

    return _v2ContextualvodRootIdGet(
        rootId: rootId,
        language: language,
        profileId: profileId,
        optIn: optIn,
        sharedProfile: sharedProfile,
        encoding: encoding?.value?.toString(),
        maxRes: maxRes?.value?.toString(),
        cityId: cityId,
        includeExternalProvider: includeExternalProvider,
        replayOptedInTime: replayOptedInTime,
        mergingOn: mergingOn,
        excludeAdult: excludeAdult,
        featureFlags: featureFlags,
        xCus: xCus,
        xDev: xDev,
        xEntitlementsToken: xEntitlementsToken,
        cacheControl: cacheControl);
  }

  ///Retrieves the contextual menu
  ///@param rootId The root logical key of soft link
  ///@param language The two character language code
  ///@param profileId The user selected profile id
  ///@param optIn The user setting for personalized recommendations
  ///@param sharedProfile Indicator of a shared profile (default) or a personal one
  ///@param encoding Supported encoding type for content instance selection
  ///@param maxRes The maximum resolution supported for content instance selection
  ///@param cityId City Identifier of the user.
  ///@param includeExternalProvider If present, the contents from the 'external provider(s)' are included in the results. Value can be a comma separated list.
  ///@param replayOptedInTime Parameter to pass on to the picker service for season count calculation.
  ///@param mergingOn Parameter to indicate whether season count merging has to be done by picker service.
  ///@param excludeAdult boolean flag when set to true indicating to remove any content that is adult
  ///@param featureFlags Comma Separated Values  of the features that clients supports
  ///@param x-cus Customer ID
  ///@param x-dev Device ID
  ///@param x-entitlements-token Token containing entitlements info
  @Get(path: '/v2/contextualvod/{rootId}')
  Future<chopper.Response<Screen>> _v2ContextualvodRootIdGet({
    @Path('rootId') required String? rootId,
    @Query('language') required String? language,
    @Query('profileId') String? profileId,
    @Query('optIn') bool? optIn,
    @Query('sharedProfile') bool? sharedProfile,
    @Query('encoding') String? encoding,
    @Query('maxRes') String? maxRes,
    @Query('cityId') String? cityId,
    @Query('includeExternalProvider') String? includeExternalProvider,
    @Query('replayOptedInTime') int? replayOptedInTime,
    @Query('mergingOn') bool? mergingOn,
    @Query('excludeAdult') bool? excludeAdult,
    @Query('featureFlags') String? featureFlags,
    @Header('x-cus') String? xCus = 'X-Cus',
    @Header('x-dev') String? xDev,
    @Header('x-entitlements-token')
        String? xEntitlementsToken = 'X-Entitlements-Token',
    @Header('Cache-Control') String? cacheControl,
  });

  ///Retrieves the rented items
  ///@param language The two character language code
  ///@param pagingOffset The page offset value when paging is used
  ///@param pagingSize The page size when paging is used
  ///@param profileId The user selected profile id
  ///@param isAdult The user setting for adult content
  ///@param encoding Supported encoding type for content instance selection
  ///@param maxRes The maximum resolution supported for content instance selection
  ///@param replayOptedInTime Parameter to pass on to the picker service for season count calculation.
  ///@param mergingOn Parameter to indicate whether season count merging has to be done by picker service.
  ///@param x-cus Customer ID
  ///@param x-dev Device ID
  ///@param x-entitlements-token Token containing entitlements info
  Future<chopper.Response<RentalScreen>> v2RentalsGet({
    required String? language,
    String? pagingOffset,
    String? pagingSize,
    String? profileId,
    bool? isAdult,
    enums.V2RentalsGetEncoding? encoding,
    enums.V2RentalsGetMaxRes? maxRes,
    int? replayOptedInTime,
    bool? mergingOn,
    String? xCus = 'X-Cus',
    String? xDev,
    String? xEntitlementsToken = 'X-Entitlements-Token',
    String? cacheControl,
  }) {
    generatedMapping.putIfAbsent(
        RentalScreen, () => RentalScreen.fromJsonFactory);

    return _v2RentalsGet(
        language: language,
        pagingOffset: pagingOffset,
        pagingSize: pagingSize,
        profileId: profileId,
        isAdult: isAdult,
        encoding: encoding?.value?.toString(),
        maxRes: maxRes?.value?.toString(),
        replayOptedInTime: replayOptedInTime,
        mergingOn: mergingOn,
        xCus: xCus,
        xDev: xDev,
        xEntitlementsToken: xEntitlementsToken,
        cacheControl: cacheControl);
  }

  ///Retrieves the rented items
  ///@param language The two character language code
  ///@param pagingOffset The page offset value when paging is used
  ///@param pagingSize The page size when paging is used
  ///@param profileId The user selected profile id
  ///@param isAdult The user setting for adult content
  ///@param encoding Supported encoding type for content instance selection
  ///@param maxRes The maximum resolution supported for content instance selection
  ///@param replayOptedInTime Parameter to pass on to the picker service for season count calculation.
  ///@param mergingOn Parameter to indicate whether season count merging has to be done by picker service.
  ///@param x-cus Customer ID
  ///@param x-dev Device ID
  ///@param x-entitlements-token Token containing entitlements info
  @Get(path: '/v2/rentals')
  Future<chopper.Response<RentalScreen>> _v2RentalsGet({
    @Query('language') required String? language,
    @Query('pagingOffset') String? pagingOffset,
    @Query('pagingSize') String? pagingSize,
    @Query('profileId') String? profileId,
    @Query('isAdult') bool? isAdult,
    @Query('encoding') String? encoding,
    @Query('maxRes') String? maxRes,
    @Query('replayOptedInTime') int? replayOptedInTime,
    @Query('mergingOn') bool? mergingOn,
    @Header('x-cus') String? xCus = 'X-Cus',
    @Header('x-dev') String? xDev,
    @Header('x-entitlements-token')
        String? xEntitlementsToken = 'X-Entitlements-Token',
    @Header('Cache-Control') String? cacheControl,
  });

  ///Retrieves detailed info for an item
  ///@param crid The asset crid
  ///@param language The two character language code
  ///@param profileId The user selected profile id
  ///@param encoding Supported encoding type for content instance selection
  ///@param maxRes The maximum resolution supported for content instance selection
  ///@param cityId City Identifier of the user.
  ///@param includeExternalProvider If present, the contents from the 'external provider(s)' are included in the results. Value can be a comma separated list.
  ///@param brandingProviderId Filter content to a certain BrandingProvider
  ///@param x-cus Customer ID
  ///@param x-dev Device ID
  ///@param x-entitlements-token Token containing entitlements info
  Future<chopper.Response<Map<String, dynamic>>> v2DetailscreenCridGet({
    required String? crid,
    required String? language,
    String? profileId,
    enums.V2DetailscreenCridGetEncoding? encoding,
    enums.V2DetailscreenCridGetMaxRes? maxRes,
    String? cityId,
    String? includeExternalProvider,
    String? brandingProviderId,
    String? xCus = 'X-Cus',
    String? xDev,
    String? xEntitlementsToken = 'X-Entitlements-Token',
    String? cacheControl,
  }) {
    return _v2DetailscreenCridGet(
        crid: crid,
        language: language,
        profileId: profileId,
        encoding: encoding?.value?.toString(),
        maxRes: maxRes?.value?.toString(),
        cityId: cityId,
        includeExternalProvider: includeExternalProvider,
        brandingProviderId: brandingProviderId,
        xCus: xCus,
        xDev: xDev,
        xEntitlementsToken: xEntitlementsToken,
        cacheControl: cacheControl);
  }

  ///Retrieves detailed info for an item
  ///@param crid The asset crid
  ///@param language The two character language code
  ///@param profileId The user selected profile id
  ///@param encoding Supported encoding type for content instance selection
  ///@param maxRes The maximum resolution supported for content instance selection
  ///@param cityId City Identifier of the user.
  ///@param includeExternalProvider If present, the contents from the 'external provider(s)' are included in the results. Value can be a comma separated list.
  ///@param brandingProviderId Filter content to a certain BrandingProvider
  ///@param x-cus Customer ID
  ///@param x-dev Device ID
  ///@param x-entitlements-token Token containing entitlements info
  @Get(path: '/v2/detailscreen/{crid}')
  Future<chopper.Response<Map<String, dynamic>>> _v2DetailscreenCridGet({
    @Path('crid') required String? crid,
    @Query('language') required String? language,
    @Query('profileId') String? profileId,
    @Query('encoding') String? encoding,
    @Query('maxRes') String? maxRes,
    @Query('cityId') String? cityId,
    @Query('includeExternalProvider') String? includeExternalProvider,
    @Query('brandingProviderId') String? brandingProviderId,
    @Header('x-cus') String? xCus = 'X-Cus',
    @Header('x-dev') String? xDev,
    @Header('x-entitlements-token')
        String? xEntitlementsToken = 'X-Entitlements-Token',
    @Header('Cache-Control') String? cacheControl,
  });

  ///Returns a list of instances of the given trailer crid
  ///@param trailerCrid The trailer asset crid
  ///@param language The two character language code
  ///@param profileId The user selected profile id, only for logging purposes
  ///@param encoding Supported encoding type for content instance selection
  ///@param maxRes The maximum resolution supported for content instance selection
  ///@param cityId City Identifier of the user.
  ///@param includeExternalProvider If present, the contents from the 'external provider(s)' are included in the results. Value can be a comma separated list.
  ///@param x-cus Customer ID, only for logging purposes
  ///@param x-dev Device ID, only for logging purposes
  ///@param x-entitlements-token Token containing entitlements info, only for logging purposes
  Future<chopper.Response<TrailerInfo>> v2TrailerDetailsTrailerCridGet({
    required String? trailerCrid,
    required String? language,
    String? profileId,
    enums.V2TrailerDetailsTrailerCridGetEncoding? encoding,
    enums.V2TrailerDetailsTrailerCridGetMaxRes? maxRes,
    String? cityId,
    String? includeExternalProvider,
    String? xCus = 'X-Cus',
    String? xDev,
    String? xEntitlementsToken = 'X-Entitlements-Token',
    String? cacheControl,
  }) {
    generatedMapping.putIfAbsent(
        TrailerInfo, () => TrailerInfo.fromJsonFactory);

    return _v2TrailerDetailsTrailerCridGet(
        trailerCrid: trailerCrid,
        language: language,
        profileId: profileId,
        encoding: encoding?.value?.toString(),
        maxRes: maxRes?.value?.toString(),
        cityId: cityId,
        includeExternalProvider: includeExternalProvider,
        xCus: xCus,
        xDev: xDev,
        xEntitlementsToken: xEntitlementsToken,
        cacheControl: cacheControl);
  }

  ///Returns a list of instances of the given trailer crid
  ///@param trailerCrid The trailer asset crid
  ///@param language The two character language code
  ///@param profileId The user selected profile id, only for logging purposes
  ///@param encoding Supported encoding type for content instance selection
  ///@param maxRes The maximum resolution supported for content instance selection
  ///@param cityId City Identifier of the user.
  ///@param includeExternalProvider If present, the contents from the 'external provider(s)' are included in the results. Value can be a comma separated list.
  ///@param x-cus Customer ID, only for logging purposes
  ///@param x-dev Device ID, only for logging purposes
  ///@param x-entitlements-token Token containing entitlements info, only for logging purposes
  @Get(path: '/v2/trailerDetails/{trailerCrid}')
  Future<chopper.Response<TrailerInfo>> _v2TrailerDetailsTrailerCridGet({
    @Path('trailerCrid') required String? trailerCrid,
    @Query('language') required String? language,
    @Query('profileId') String? profileId,
    @Query('encoding') String? encoding,
    @Query('maxRes') String? maxRes,
    @Query('cityId') String? cityId,
    @Query('includeExternalProvider') String? includeExternalProvider,
    @Header('x-cus') String? xCus = 'X-Cus',
    @Header('x-dev') String? xDev,
    @Header('x-entitlements-token')
        String? xEntitlementsToken = 'X-Entitlements-Token',
    @Header('Cache-Control') String? cacheControl,
  });

  ///Retrieves the options for a grid screen
  ///@param crid The grid screen id
  ///@param language The two character language code
  ///@param genreCrid To indicate if GenreCategoryLink is configured
  ///@param encoding Supported encoding type for content instance selection
  ///@param maxRes The maximum resolution supported for content instance selection
  ///@param cityId City Identifier of the user.
  ///@param onlyGoPlayable Only return Go playable items
  ///@param x-cus Customer ID
  ///@param x-dev Device ID
  ///@param x-entitlements-token Token containing entitlements info
  Future<chopper.Response<GridOptions>> v2GridoptionsCridGet({
    required String? crid,
    required String? language,
    bool? genreCrid,
    enums.V2GridoptionsCridGetEncoding? encoding,
    enums.V2GridoptionsCridGetMaxRes? maxRes,
    String? cityId,
    bool? onlyGoPlayable,
    String? xCus = 'X-Cus',
    String? xDev,
    String? xEntitlementsToken = 'X-Entitlements-Token',
    String? cacheControl,
  }) {
    generatedMapping.putIfAbsent(
        GridOptions, () => GridOptions.fromJsonFactory);

    return _v2GridoptionsCridGet(
        crid: crid,
        language: language,
        genreCrid: genreCrid,
        encoding: encoding?.value?.toString(),
        maxRes: maxRes?.value?.toString(),
        cityId: cityId,
        onlyGoPlayable: onlyGoPlayable,
        xCus: xCus,
        xDev: xDev,
        xEntitlementsToken: xEntitlementsToken,
        cacheControl: cacheControl);
  }

  ///Retrieves the options for a grid screen
  ///@param crid The grid screen id
  ///@param language The two character language code
  ///@param genreCrid To indicate if GenreCategoryLink is configured
  ///@param encoding Supported encoding type for content instance selection
  ///@param maxRes The maximum resolution supported for content instance selection
  ///@param cityId City Identifier of the user.
  ///@param onlyGoPlayable Only return Go playable items
  ///@param x-cus Customer ID
  ///@param x-dev Device ID
  ///@param x-entitlements-token Token containing entitlements info
  @Get(path: '/v2/gridoptions/{crid}')
  Future<chopper.Response<GridOptions>> _v2GridoptionsCridGet({
    @Path('crid') required String? crid,
    @Query('language') required String? language,
    @Query('genreCrid') bool? genreCrid,
    @Query('encoding') String? encoding,
    @Query('maxRes') String? maxRes,
    @Query('cityId') String? cityId,
    @Query('onlyGoPlayable') bool? onlyGoPlayable,
    @Header('x-cus') String? xCus = 'X-Cus',
    @Header('x-dev') String? xDev,
    @Header('x-entitlements-token')
        String? xEntitlementsToken = 'X-Entitlements-Token',
    @Header('Cache-Control') String? cacheControl,
  });

  ///Retrieves a grid screen with items
  ///@param rootId The root logical key of soft link
  ///@param crid The grid screen id
  ///@param language The two character language code
  ///@param profileId The user selected profile id
  ///@param sortType The sort order for assets
  ///@param sortDirection The sort direction
  ///@param filterType The associated filter type
  ///@param pagingOffset The page offset value when paging is used
  ///@param encoding Supported encoding type for content instance selection
  ///@param maxRes The maximum resolution supported for content instance selection
  ///@param cityId City Identifier of the user.
  ///@param includeExternalProvider If present, the contents from the 'external provider(s)' are included in the results. Value can be a comma separated list.
  ///@param goDownloadable Only return downloadable items
  ///@param onlyGoPlayable Only return Go playable items
  ///@param replayOptedInTime Parameter to pass on to the picker service for season count calculation.
  ///@param mergingOn Parameter to indicate whether season count merging has to be done by picker service.
  ///@param excludeAdult boolean flag when set to true indicating to remove any content that is adult
  ///@param x-cus Customer ID
  ///@param x-dev Device ID
  ///@param x-entitlements-token Token containing entitlements info
  Future<chopper.Response<GridScreen>> v2GridscreenRootIdCridGet({
    required String? rootId,
    required String? crid,
    required String? language,
    String? profileId,
    enums.V2GridscreenRootIdCridGetSortType? sortType,
    enums.V2GridscreenRootIdCridGetSortDirection? sortDirection,
    enums.V2GridscreenRootIdCridGetFilterType? filterType,
    String? pagingOffset,
    enums.V2GridscreenRootIdCridGetEncoding? encoding,
    enums.V2GridscreenRootIdCridGetMaxRes? maxRes,
    String? cityId,
    String? includeExternalProvider,
    bool? goDownloadable,
    bool? onlyGoPlayable,
    int? replayOptedInTime,
    bool? mergingOn,
    bool? excludeAdult,
    String? xCus = 'X-Cus',
    String? xDev,
    String? xEntitlementsToken = 'X-Entitlements-Token',
    String? cacheControl,
  }) {
    generatedMapping.putIfAbsent(GridScreen, () => GridScreen.fromJsonFactory);

    return _v2GridscreenRootIdCridGet(
        rootId: rootId,
        crid: crid,
        language: language,
        profileId: profileId,
        sortType: sortType?.value?.toString(),
        sortDirection: sortDirection?.value?.toString(),
        filterType: filterType?.value?.toString(),
        pagingOffset: pagingOffset,
        encoding: encoding?.value?.toString(),
        maxRes: maxRes?.value?.toString(),
        cityId: cityId,
        includeExternalProvider: includeExternalProvider,
        goDownloadable: goDownloadable,
        onlyGoPlayable: onlyGoPlayable,
        replayOptedInTime: replayOptedInTime,
        mergingOn: mergingOn,
        excludeAdult: excludeAdult,
        xCus: xCus,
        xDev: xDev,
        xEntitlementsToken: xEntitlementsToken,
        cacheControl: cacheControl);
  }

  ///Retrieves a grid screen with items
  ///@param rootId The root logical key of soft link
  ///@param crid The grid screen id
  ///@param language The two character language code
  ///@param profileId The user selected profile id
  ///@param sortType The sort order for assets
  ///@param sortDirection The sort direction
  ///@param filterType The associated filter type
  ///@param pagingOffset The page offset value when paging is used
  ///@param encoding Supported encoding type for content instance selection
  ///@param maxRes The maximum resolution supported for content instance selection
  ///@param cityId City Identifier of the user.
  ///@param includeExternalProvider If present, the contents from the 'external provider(s)' are included in the results. Value can be a comma separated list.
  ///@param goDownloadable Only return downloadable items
  ///@param onlyGoPlayable Only return Go playable items
  ///@param replayOptedInTime Parameter to pass on to the picker service for season count calculation.
  ///@param mergingOn Parameter to indicate whether season count merging has to be done by picker service.
  ///@param excludeAdult boolean flag when set to true indicating to remove any content that is adult
  ///@param x-cus Customer ID
  ///@param x-dev Device ID
  ///@param x-entitlements-token Token containing entitlements info
  @Get(path: '/v2/gridscreen/{rootId}/{crid}')
  Future<chopper.Response<GridScreen>> _v2GridscreenRootIdCridGet({
    @Path('rootId') required String? rootId,
    @Path('crid') required String? crid,
    @Query('language') required String? language,
    @Query('profileId') String? profileId,
    @Query('sortType') String? sortType,
    @Query('sortDirection') String? sortDirection,
    @Query('filterType') String? filterType,
    @Query('pagingOffset') String? pagingOffset,
    @Query('encoding') String? encoding,
    @Query('maxRes') String? maxRes,
    @Query('cityId') String? cityId,
    @Query('includeExternalProvider') String? includeExternalProvider,
    @Query('goDownloadable') bool? goDownloadable,
    @Query('onlyGoPlayable') bool? onlyGoPlayable,
    @Query('replayOptedInTime') int? replayOptedInTime,
    @Query('mergingOn') bool? mergingOn,
    @Query('excludeAdult') bool? excludeAdult,
    @Header('x-cus') String? xCus = 'X-Cus',
    @Header('x-dev') String? xDev,
    @Header('x-entitlements-token')
        String? xEntitlementsToken = 'X-Entitlements-Token',
    @Header('Cache-Control') String? cacheControl,
  });

  ///Retrieves the next episode
  ///@param language The two character language code
  ///@param episodeId The id of episode
  ///@param encoding Supported encoding type for content instance selection
  ///@param maxRes The maximum resolution supported for content instance selection
  ///@param includeExternalProvider If present, the contents from the 'external provider(s)' are included in the results. Value can be a comma separated list.
  ///@param brandingProviderId Filter content to a certain BrandingProvider
  Future<chopper.Response<NextEpisode>> v2NextepisodeGet({
    required String? language,
    required String? episodeId,
    enums.V2NextepisodeGetEncoding? encoding,
    enums.V2NextepisodeGetMaxRes? maxRes,
    String? includeExternalProvider,
    String? brandingProviderId,
    String? cacheControl,
  }) {
    generatedMapping.putIfAbsent(
        NextEpisode, () => NextEpisode.fromJsonFactory);

    return _v2NextepisodeGet(
        language: language,
        episodeId: episodeId,
        encoding: encoding?.value?.toString(),
        maxRes: maxRes?.value?.toString(),
        includeExternalProvider: includeExternalProvider,
        brandingProviderId: brandingProviderId,
        cacheControl: cacheControl);
  }

  ///Retrieves the next episode
  ///@param language The two character language code
  ///@param episodeId The id of episode
  ///@param encoding Supported encoding type for content instance selection
  ///@param maxRes The maximum resolution supported for content instance selection
  ///@param includeExternalProvider If present, the contents from the 'external provider(s)' are included in the results. Value can be a comma separated list.
  ///@param brandingProviderId Filter content to a certain BrandingProvider
  @Get(path: '/v2/nextepisode')
  Future<chopper.Response<NextEpisode>> _v2NextepisodeGet({
    @Query('language') required String? language,
    @Query('episodeId') required String? episodeId,
    @Query('encoding') String? encoding,
    @Query('maxRes') String? maxRes,
    @Query('includeExternalProvider') String? includeExternalProvider,
    @Query('brandingProviderId') String? brandingProviderId,
    @Header('Cache-Control') String? cacheControl,
  });

  ///Retrieves a tile screen with items
  ///@param rootId The root logical key of soft link
  ///@param crid The title screen id
  ///@param language The two character language code
  ///@param encoding Supported encoding type for content instance selection
  ///@param maxRes The maximum resolution supported for content instance selection
  ///@param excludeAdult boolean flag when set to true indicating to remove any content that is adult
  ///@param featureFlags Comma Separated Values  of the features that clients supports
  ///@param x-cus Customer ID
  ///@param x-dev Device ID
  ///@param x-entitlements-token Token containing entitlements info
  Future<chopper.Response<TileScreen>> v2TilescreenRootIdCridGet({
    required String? rootId,
    required String? crid,
    required String? language,
    enums.V2TilescreenRootIdCridGetEncoding? encoding,
    enums.V2TilescreenRootIdCridGetMaxRes? maxRes,
    bool? excludeAdult,
    String? featureFlags,
    String? xCus = 'X-Cus',
    String? xDev,
    String? xEntitlementsToken = 'X-Entitlements-Token',
    String? cacheControl,
  }) {
    generatedMapping.putIfAbsent(TileScreen, () => TileScreen.fromJsonFactory);

    return _v2TilescreenRootIdCridGet(
        rootId: rootId,
        crid: crid,
        language: language,
        encoding: encoding?.value?.toString(),
        maxRes: maxRes?.value?.toString(),
        excludeAdult: excludeAdult,
        featureFlags: featureFlags,
        xCus: xCus,
        xDev: xDev,
        xEntitlementsToken: xEntitlementsToken,
        cacheControl: cacheControl);
  }

  ///Retrieves a tile screen with items
  ///@param rootId The root logical key of soft link
  ///@param crid The title screen id
  ///@param language The two character language code
  ///@param encoding Supported encoding type for content instance selection
  ///@param maxRes The maximum resolution supported for content instance selection
  ///@param excludeAdult boolean flag when set to true indicating to remove any content that is adult
  ///@param featureFlags Comma Separated Values  of the features that clients supports
  ///@param x-cus Customer ID
  ///@param x-dev Device ID
  ///@param x-entitlements-token Token containing entitlements info
  @Get(path: '/v2/tilescreen/{rootId}/{crid}')
  Future<chopper.Response<TileScreen>> _v2TilescreenRootIdCridGet({
    @Path('rootId') required String? rootId,
    @Path('crid') required String? crid,
    @Query('language') required String? language,
    @Query('encoding') String? encoding,
    @Query('maxRes') String? maxRes,
    @Query('excludeAdult') bool? excludeAdult,
    @Query('featureFlags') String? featureFlags,
    @Header('x-cus') String? xCus = 'X-Cus',
    @Header('x-dev') String? xDev,
    @Header('x-entitlements-token')
        String? xEntitlementsToken = 'X-Entitlements-Token',
    @Header('Cache-Control') String? cacheControl,
  });

  ///Retrieves a vod screen
  ///@param rootId The root logical key of soft link
  ///@param crid The screen id
  ///@param language The two character language code
  ///@param profileId The user selected profile id
  ///@param optIn The user setting for personalized recommendations
  ///@param sharedProfile Indicator of a shared profile (default) or a personal one
  ///@param encoding Supported encoding type for content instance selection
  ///@param maxRes The maximum resolution supported for content instance selection
  ///@param cityId City Identifier of the user.
  ///@param includeExternalProvider If present, the contents from the 'external provider(s)' are included in the results. Value can be a comma separated list.
  ///@param replayOptedInTime Parameter to pass on to the picker service for season count calculation.
  ///@param mergingOn Parameter to indicate whether season count merging has to be done by picker service.
  ///@param excludeAdult boolean flag when set to true indicating to remove any content that is adult
  ///@param featureFlags Comma Separated Values  of the features that clients supports
  ///@param x-cus Customer ID
  ///@param x-dev Device ID
  ///@param x-entitlements-token Token containing entitlements info
  Future<chopper.Response<Screen>> v2VodscreenRootIdCridGet({
    required String? rootId,
    required String? crid,
    required String? language,
    String? profileId,
    bool? optIn,
    bool? sharedProfile,
    enums.V2VodscreenRootIdCridGetEncoding? encoding,
    enums.V2VodscreenRootIdCridGetMaxRes? maxRes,
    String? cityId,
    String? includeExternalProvider,
    int? replayOptedInTime,
    bool? mergingOn,
    bool? excludeAdult,
    String? featureFlags,
    String? xCus = 'X-Cus',
    String? xDev,
    String? xEntitlementsToken = 'X-Entitlements-Token',
    String? cacheControl,
  }) {
    generatedMapping.putIfAbsent(Screen, () => Screen.fromJsonFactory);

    return _v2VodscreenRootIdCridGet(
        rootId: rootId,
        crid: crid,
        language: language,
        profileId: profileId,
        optIn: optIn,
        sharedProfile: sharedProfile,
        encoding: encoding?.value?.toString(),
        maxRes: maxRes?.value?.toString(),
        cityId: cityId,
        includeExternalProvider: includeExternalProvider,
        replayOptedInTime: replayOptedInTime,
        mergingOn: mergingOn,
        excludeAdult: excludeAdult,
        featureFlags: featureFlags,
        xCus: xCus,
        xDev: xDev,
        xEntitlementsToken: xEntitlementsToken,
        cacheControl: cacheControl);
  }

  ///Retrieves a vod screen
  ///@param rootId The root logical key of soft link
  ///@param crid The screen id
  ///@param language The two character language code
  ///@param profileId The user selected profile id
  ///@param optIn The user setting for personalized recommendations
  ///@param sharedProfile Indicator of a shared profile (default) or a personal one
  ///@param encoding Supported encoding type for content instance selection
  ///@param maxRes The maximum resolution supported for content instance selection
  ///@param cityId City Identifier of the user.
  ///@param includeExternalProvider If present, the contents from the 'external provider(s)' are included in the results. Value can be a comma separated list.
  ///@param replayOptedInTime Parameter to pass on to the picker service for season count calculation.
  ///@param mergingOn Parameter to indicate whether season count merging has to be done by picker service.
  ///@param excludeAdult boolean flag when set to true indicating to remove any content that is adult
  ///@param featureFlags Comma Separated Values  of the features that clients supports
  ///@param x-cus Customer ID
  ///@param x-dev Device ID
  ///@param x-entitlements-token Token containing entitlements info
  @Get(path: '/v2/vodscreen/{rootId}/{crid}')
  Future<chopper.Response<Screen>> _v2VodscreenRootIdCridGet({
    @Path('rootId') required String? rootId,
    @Path('crid') required String? crid,
    @Query('language') required String? language,
    @Query('profileId') String? profileId,
    @Query('optIn') bool? optIn,
    @Query('sharedProfile') bool? sharedProfile,
    @Query('encoding') String? encoding,
    @Query('maxRes') String? maxRes,
    @Query('cityId') String? cityId,
    @Query('includeExternalProvider') String? includeExternalProvider,
    @Query('replayOptedInTime') int? replayOptedInTime,
    @Query('mergingOn') bool? mergingOn,
    @Query('excludeAdult') bool? excludeAdult,
    @Query('featureFlags') String? featureFlags,
    @Header('x-cus') String? xCus = 'X-Cus',
    @Header('x-dev') String? xDev,
    @Header('x-entitlements-token')
        String? xEntitlementsToken = 'X-Entitlements-Token',
    @Header('Cache-Control') String? cacheControl,
  });

  ///Shows the validation report for the softlink
  ///@param rootId The root logical key of soft link
  ///@param language The two character language code
  Future<chopper.Response<Messages>> v2VodstructureRootIdValidationReportGet({
    required String? rootId,
    required String? language,
    String? cacheControl,
  }) {
    generatedMapping.putIfAbsent(Messages, () => Messages.fromJsonFactory);

    return _v2VodstructureRootIdValidationReportGet(
        rootId: rootId, language: language, cacheControl: cacheControl);
  }

  ///Shows the validation report for the softlink
  ///@param rootId The root logical key of soft link
  ///@param language The two character language code
  @Get(path: '/v2/vodstructure/{rootId}/validation-report')
  Future<chopper.Response<Messages>> _v2VodstructureRootIdValidationReportGet({
    @Path('rootId') required String? rootId,
    @Query('language') required String? language,
    @Header('Cache-Control') String? cacheControl,
  });

  ///Retrieves the vodstructure for a crid
  ///@param rootId The root logical key of soft link
  ///@param crid The crid associated with the structure
  ///@param language The two character language code
  ///@param encoding Supported encoding type for content instance selection
  ///@param maxRes The maximum resolution supported for content instance selection
  ///@param excludeAdult boolean flag when set to true indicating to remove any content that is adult
  ///@param featureFlags Comma Separated Values  of the features that clients supports
  ///@param x-cus Customer ID
  ///@param x-dev Device ID
  ///@param x-entitlements-token Token containing entitlements info
  Future<chopper.Response<Structure>> v2VodstructureRootIdCridGet({
    required String? rootId,
    required String? crid,
    required String? language,
    enums.V2VodstructureRootIdCridGetEncoding? encoding,
    enums.V2VodstructureRootIdCridGetMaxRes? maxRes,
    bool? excludeAdult,
    String? featureFlags,
    String? xCus = 'X-Cus',
    String? xDev,
    String? xEntitlementsToken = 'X-Entitlements-Token',
    String? cacheControl,
  }) {
    generatedMapping.putIfAbsent(Structure, () => Structure.fromJsonFactory);

    return _v2VodstructureRootIdCridGet(
        rootId: rootId,
        crid: crid,
        language: language,
        encoding: encoding?.value?.toString(),
        maxRes: maxRes?.value?.toString(),
        excludeAdult: excludeAdult,
        featureFlags: featureFlags,
        xCus: xCus,
        xDev: xDev,
        xEntitlementsToken: xEntitlementsToken,
        cacheControl: cacheControl);
  }

  ///Retrieves the vodstructure for a crid
  ///@param rootId The root logical key of soft link
  ///@param crid The crid associated with the structure
  ///@param language The two character language code
  ///@param encoding Supported encoding type for content instance selection
  ///@param maxRes The maximum resolution supported for content instance selection
  ///@param excludeAdult boolean flag when set to true indicating to remove any content that is adult
  ///@param featureFlags Comma Separated Values  of the features that clients supports
  ///@param x-cus Customer ID
  ///@param x-dev Device ID
  ///@param x-entitlements-token Token containing entitlements info
  @Get(path: '/v2/vodstructure/{rootId}/{crid}')
  Future<chopper.Response<Structure>> _v2VodstructureRootIdCridGet({
    @Path('rootId') required String? rootId,
    @Path('crid') required String? crid,
    @Query('language') required String? language,
    @Query('encoding') String? encoding,
    @Query('maxRes') String? maxRes,
    @Query('excludeAdult') bool? excludeAdult,
    @Query('featureFlags') String? featureFlags,
    @Header('x-cus') String? xCus = 'X-Cus',
    @Header('x-dev') String? xDev,
    @Header('x-entitlements-token')
        String? xEntitlementsToken = 'X-Entitlements-Token',
    @Header('Cache-Control') String? cacheControl,
  });

  ///Retrieves the person details for a person ID
  ///@param personId The person ID to retrieve the person details
  ///@param language The two character language code
  Future<chopper.Response<PersonDetail>> v2PersondetailPersonIdGet({
    required String? personId,
    required String? language,
    String? cacheControl,
  }) {
    generatedMapping.putIfAbsent(
        PersonDetail, () => PersonDetail.fromJsonFactory);

    return _v2PersondetailPersonIdGet(
        personId: personId, language: language, cacheControl: cacheControl);
  }

  ///Retrieves the person details for a person ID
  ///@param personId The person ID to retrieve the person details
  ///@param language The two character language code
  @Get(path: '/v2/persondetail/{personId}')
  Future<chopper.Response<PersonDetail>> _v2PersondetailPersonIdGet({
    @Path('personId') required String? personId,
    @Query('language') required String? language,
    @Header('Cache-Control') String? cacheControl,
  });

  ///Retrieves an editorial feed with sorted items
  ///@param categoryId The crid of the editorial category
  ///@param language The two character language code
  ///@param sortType The sort order for assets
  ///@param sortDirection The sort direction
  ///@param pagingOffset The page offset, integer >= 0
  ///@param pagingSize The page size, integer >= 1
  ///@param filters Comma separated filters, eg. 'downloadable'
  ///@param maxRes Max resolution supported by the CPE, eg. '4K'
  ///@param onlyGoPlayable When set to true only return titles/shows with an available OTT content
  ///@param cityId City Identifier of the user.
  ///@param includeExternalProvider If present, the contents from the 'external provider(s)' are included in the results. Value can be a comma separated list.
  Future<chopper.Response<EditorialFeed>> hzngoV1EditorialFeedCategoryIdGet({
    required String? categoryId,
    required String? language,
    required enums.HzngoV1EditorialFeedCategoryIdGetSortType? sortType,
    required enums.HzngoV1EditorialFeedCategoryIdGetSortDirection?
        sortDirection,
    String? pagingOffset,
    String? pagingSize,
    String? filters,
    String? maxRes,
    bool? onlyGoPlayable,
    String? cityId,
    String? includeExternalProvider,
    String? cacheControl,
  }) {
    generatedMapping.putIfAbsent(
        EditorialFeed, () => EditorialFeed.fromJsonFactory);

    return _hzngoV1EditorialFeedCategoryIdGet(
        categoryId: categoryId,
        language: language,
        sortType: sortType?.value?.toString(),
        sortDirection: sortDirection?.value?.toString(),
        pagingOffset: pagingOffset,
        pagingSize: pagingSize,
        filters: filters,
        maxRes: maxRes,
        onlyGoPlayable: onlyGoPlayable,
        cityId: cityId,
        includeExternalProvider: includeExternalProvider,
        cacheControl: cacheControl);
  }

  ///Retrieves an editorial feed with sorted items
  ///@param categoryId The crid of the editorial category
  ///@param language The two character language code
  ///@param sortType The sort order for assets
  ///@param sortDirection The sort direction
  ///@param pagingOffset The page offset, integer >= 0
  ///@param pagingSize The page size, integer >= 1
  ///@param filters Comma separated filters, eg. 'downloadable'
  ///@param maxRes Max resolution supported by the CPE, eg. '4K'
  ///@param onlyGoPlayable When set to true only return titles/shows with an available OTT content
  ///@param cityId City Identifier of the user.
  ///@param includeExternalProvider If present, the contents from the 'external provider(s)' are included in the results. Value can be a comma separated list.
  @Get(path: '/hzngo/v1/editorialFeed/{categoryId}')
  Future<chopper.Response<EditorialFeed>> _hzngoV1EditorialFeedCategoryIdGet({
    @Path('categoryId') required String? categoryId,
    @Query('language') required String? language,
    @Query('sortType') required String? sortType,
    @Query('sortDirection') required String? sortDirection,
    @Query('pagingOffset') String? pagingOffset,
    @Query('pagingSize') String? pagingSize,
    @Query('filters') String? filters,
    @Query('maxRes') String? maxRes,
    @Query('onlyGoPlayable') bool? onlyGoPlayable,
    @Query('cityId') String? cityId,
    @Query('includeExternalProvider') String? includeExternalProvider,
    @Header('Cache-Control') String? cacheControl,
  });

  ///Retrieves a list of genres related to that crid
  ///@param crid The crid of the item
  ///@param language The two character language code
  Future<chopper.Response<GenreListResponse>> hzngoV1FeedGenreListCridGet({
    required String? crid,
    required String? language,
    String? cacheControl,
  }) {
    generatedMapping.putIfAbsent(
        GenreListResponse, () => GenreListResponse.fromJsonFactory);

    return _hzngoV1FeedGenreListCridGet(
        crid: crid, language: language, cacheControl: cacheControl);
  }

  ///Retrieves a list of genres related to that crid
  ///@param crid The crid of the item
  ///@param language The two character language code
  @Get(path: '/hzngo/v1/feedGenreList/{crid}')
  Future<chopper.Response<GenreListResponse>> _hzngoV1FeedGenreListCridGet({
    @Path('crid') required String? crid,
    @Query('language') required String? language,
    @Header('Cache-Control') String? cacheControl,
  });
}

@JsonSerializable(explicitToJson: true)
class Program {
  Program({
    this.crid,
    this.type,
  });

  factory Program.fromJson(Map<String, dynamic> json) =>
      _$ProgramFromJson(json);

  @JsonKey(name: 'crid', includeIfNull: false, defaultValue: '')
  final String? crid;
  @JsonKey(
    name: 'type',
    includeIfNull: false,
    toJson: programTypeToJson,
    fromJson: programTypeFromJson,
  )
  final enums.ProgramType? type;
  static const fromJsonFactory = _$ProgramFromJson;
  static const toJsonFactory = _$ProgramToJson;
  Map<String, dynamic> toJson() => _$ProgramToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Program &&
            (identical(other.crid, crid) ||
                const DeepCollectionEquality().equals(other.crid, crid)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(crid) ^
      const DeepCollectionEquality().hash(type) ^
      runtimeType.hashCode;
}

extension $ProgramExtension on Program {
  Program copyWith({String? crid, enums.ProgramType? type}) {
    return Program(crid: crid ?? this.crid, type: type ?? this.type);
  }

  Program copyWithWrapped(
      {Wrapped<String?>? crid, Wrapped<enums.ProgramType?>? type}) {
    return Program(
        crid: (crid != null ? crid.value : this.crid),
        type: (type != null ? type.value : this.type));
  }
}

@JsonSerializable(explicitToJson: true)
class Show {
  Show({
    this.crid,
    this.type,
  });

  factory Show.fromJson(Map<String, dynamic> json) => _$ShowFromJson(json);

  @JsonKey(name: 'crid', includeIfNull: false, defaultValue: '')
  final String? crid;
  @JsonKey(
    name: 'type',
    includeIfNull: false,
    toJson: showTypeToJson,
    fromJson: showTypeFromJson,
  )
  final enums.ShowType? type;
  static const fromJsonFactory = _$ShowFromJson;
  static const toJsonFactory = _$ShowToJson;
  Map<String, dynamic> toJson() => _$ShowToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Show &&
            (identical(other.crid, crid) ||
                const DeepCollectionEquality().equals(other.crid, crid)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(crid) ^
      const DeepCollectionEquality().hash(type) ^
      runtimeType.hashCode;
}

extension $ShowExtension on Show {
  Show copyWith({String? crid, enums.ShowType? type}) {
    return Show(crid: crid ?? this.crid, type: type ?? this.type);
  }

  Show copyWithWrapped(
      {Wrapped<String?>? crid, Wrapped<enums.ShowType?>? type}) {
    return Show(
        crid: (crid != null ? crid.value : this.crid),
        type: (type != null ? type.value : this.type));
  }
}

@JsonSerializable(explicitToJson: true)
class Title {
  Title({
    this.crid,
    this.type,
  });

  factory Title.fromJson(Map<String, dynamic> json) => _$TitleFromJson(json);

  @JsonKey(name: 'crid', includeIfNull: false, defaultValue: '')
  final String? crid;
  @JsonKey(
    name: 'type',
    includeIfNull: false,
    toJson: titleTypeToJson,
    fromJson: titleTypeFromJson,
  )
  final enums.TitleType? type;
  static const fromJsonFactory = _$TitleFromJson;
  static const toJsonFactory = _$TitleToJson;
  Map<String, dynamic> toJson() => _$TitleToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Title &&
            (identical(other.crid, crid) ||
                const DeepCollectionEquality().equals(other.crid, crid)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(crid) ^
      const DeepCollectionEquality().hash(type) ^
      runtimeType.hashCode;
}

extension $TitleExtension on Title {
  Title copyWith({String? crid, enums.TitleType? type}) {
    return Title(crid: crid ?? this.crid, type: type ?? this.type);
  }

  Title copyWithWrapped(
      {Wrapped<String?>? crid, Wrapped<enums.TitleType?>? type}) {
    return Title(
        crid: (crid != null ? crid.value : this.crid),
        type: (type != null ? type.value : this.type));
  }
}

@JsonSerializable(explicitToJson: true)
class FeedComposerResponse {
  FeedComposerResponse({
    this.programs,
  });

  factory FeedComposerResponse.fromJson(Map<String, dynamic> json) =>
      _$FeedComposerResponseFromJson(json);

  @JsonKey(name: 'programs', includeIfNull: false, defaultValue: <Object>[])
  final List<Object>? programs;
  static const fromJsonFactory = _$FeedComposerResponseFromJson;
  static const toJsonFactory = _$FeedComposerResponseToJson;
  Map<String, dynamic> toJson() => _$FeedComposerResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is FeedComposerResponse &&
            (identical(other.programs, programs) ||
                const DeepCollectionEquality()
                    .equals(other.programs, programs)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(programs) ^ runtimeType.hashCode;
}

extension $FeedComposerResponseExtension on FeedComposerResponse {
  FeedComposerResponse copyWith({List<Object>? programs}) {
    return FeedComposerResponse(programs: programs ?? this.programs);
  }

  FeedComposerResponse copyWithWrapped({Wrapped<List<Object>?>? programs}) {
    return FeedComposerResponse(
        programs: (programs != null ? programs.value : this.programs));
  }
}

@JsonSerializable(explicitToJson: true)
class FeedComposerResponseWithTotalCount {
  FeedComposerResponseWithTotalCount({
    this.totalCount,
    this.programs,
  });

  factory FeedComposerResponseWithTotalCount.fromJson(
          Map<String, dynamic> json) =>
      _$FeedComposerResponseWithTotalCountFromJson(json);

  @JsonKey(name: 'totalCount', includeIfNull: false)
  final int? totalCount;
  @JsonKey(name: 'programs', includeIfNull: false, defaultValue: <Object>[])
  final List<Object>? programs;
  static const fromJsonFactory = _$FeedComposerResponseWithTotalCountFromJson;
  static const toJsonFactory = _$FeedComposerResponseWithTotalCountToJson;
  Map<String, dynamic> toJson() =>
      _$FeedComposerResponseWithTotalCountToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is FeedComposerResponseWithTotalCount &&
            (identical(other.totalCount, totalCount) ||
                const DeepCollectionEquality()
                    .equals(other.totalCount, totalCount)) &&
            (identical(other.programs, programs) ||
                const DeepCollectionEquality()
                    .equals(other.programs, programs)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(totalCount) ^
      const DeepCollectionEquality().hash(programs) ^
      runtimeType.hashCode;
}

extension $FeedComposerResponseWithTotalCountExtension
    on FeedComposerResponseWithTotalCount {
  FeedComposerResponseWithTotalCount copyWith(
      {int? totalCount, List<Object>? programs}) {
    return FeedComposerResponseWithTotalCount(
        totalCount: totalCount ?? this.totalCount,
        programs: programs ?? this.programs);
  }

  FeedComposerResponseWithTotalCount copyWithWrapped(
      {Wrapped<int?>? totalCount, Wrapped<List<Object>?>? programs}) {
    return FeedComposerResponseWithTotalCount(
        totalCount: (totalCount != null ? totalCount.value : this.totalCount),
        programs: (programs != null ? programs.value : this.programs));
  }
}

@JsonSerializable(explicitToJson: true)
class FeedComposerResponseWithSeedTitle {
  FeedComposerResponseWithSeedTitle({
    this.seedTitleCrid,
    this.programs,
  });

  factory FeedComposerResponseWithSeedTitle.fromJson(
          Map<String, dynamic> json) =>
      _$FeedComposerResponseWithSeedTitleFromJson(json);

  @JsonKey(name: 'seedTitleCrid', includeIfNull: false, defaultValue: '')
  final String? seedTitleCrid;
  @JsonKey(name: 'programs', includeIfNull: false, defaultValue: <Object>[])
  final List<Object>? programs;
  static const fromJsonFactory = _$FeedComposerResponseWithSeedTitleFromJson;
  static const toJsonFactory = _$FeedComposerResponseWithSeedTitleToJson;
  Map<String, dynamic> toJson() =>
      _$FeedComposerResponseWithSeedTitleToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is FeedComposerResponseWithSeedTitle &&
            (identical(other.seedTitleCrid, seedTitleCrid) ||
                const DeepCollectionEquality()
                    .equals(other.seedTitleCrid, seedTitleCrid)) &&
            (identical(other.programs, programs) ||
                const DeepCollectionEquality()
                    .equals(other.programs, programs)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(seedTitleCrid) ^
      const DeepCollectionEquality().hash(programs) ^
      runtimeType.hashCode;
}

extension $FeedComposerResponseWithSeedTitleExtension
    on FeedComposerResponseWithSeedTitle {
  FeedComposerResponseWithSeedTitle copyWith(
      {String? seedTitleCrid, List<Object>? programs}) {
    return FeedComposerResponseWithSeedTitle(
        seedTitleCrid: seedTitleCrid ?? this.seedTitleCrid,
        programs: programs ?? this.programs);
  }

  FeedComposerResponseWithSeedTitle copyWithWrapped(
      {Wrapped<String?>? seedTitleCrid, Wrapped<List<Object>?>? programs}) {
    return FeedComposerResponseWithSeedTitle(
        seedTitleCrid:
            (seedTitleCrid != null ? seedTitleCrid.value : this.seedTitleCrid),
        programs: (programs != null ? programs.value : this.programs));
  }
}

@JsonSerializable(explicitToJson: true)
class FeedComposerResponseWithSeedTitleAndGenre {
  FeedComposerResponseWithSeedTitleAndGenre({
    this.seedContentGenreTermId,
    this.seedTitleCrid,
    this.programs,
  });

  factory FeedComposerResponseWithSeedTitleAndGenre.fromJson(
          Map<String, dynamic> json) =>
      _$FeedComposerResponseWithSeedTitleAndGenreFromJson(json);

  @JsonKey(
      name: 'seedContentGenreTermId', includeIfNull: false, defaultValue: '')
  final String? seedContentGenreTermId;
  @JsonKey(name: 'seedTitleCrid', includeIfNull: false, defaultValue: '')
  final String? seedTitleCrid;
  @JsonKey(name: 'programs', includeIfNull: false, defaultValue: <Object>[])
  final List<Object>? programs;
  static const fromJsonFactory =
      _$FeedComposerResponseWithSeedTitleAndGenreFromJson;
  static const toJsonFactory =
      _$FeedComposerResponseWithSeedTitleAndGenreToJson;
  Map<String, dynamic> toJson() =>
      _$FeedComposerResponseWithSeedTitleAndGenreToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is FeedComposerResponseWithSeedTitleAndGenre &&
            (identical(other.seedContentGenreTermId, seedContentGenreTermId) ||
                const DeepCollectionEquality().equals(
                    other.seedContentGenreTermId, seedContentGenreTermId)) &&
            (identical(other.seedTitleCrid, seedTitleCrid) ||
                const DeepCollectionEquality()
                    .equals(other.seedTitleCrid, seedTitleCrid)) &&
            (identical(other.programs, programs) ||
                const DeepCollectionEquality()
                    .equals(other.programs, programs)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(seedContentGenreTermId) ^
      const DeepCollectionEquality().hash(seedTitleCrid) ^
      const DeepCollectionEquality().hash(programs) ^
      runtimeType.hashCode;
}

extension $FeedComposerResponseWithSeedTitleAndGenreExtension
    on FeedComposerResponseWithSeedTitleAndGenre {
  FeedComposerResponseWithSeedTitleAndGenre copyWith(
      {String? seedContentGenreTermId,
      String? seedTitleCrid,
      List<Object>? programs}) {
    return FeedComposerResponseWithSeedTitleAndGenre(
        seedContentGenreTermId:
            seedContentGenreTermId ?? this.seedContentGenreTermId,
        seedTitleCrid: seedTitleCrid ?? this.seedTitleCrid,
        programs: programs ?? this.programs);
  }

  FeedComposerResponseWithSeedTitleAndGenre copyWithWrapped(
      {Wrapped<String?>? seedContentGenreTermId,
      Wrapped<String?>? seedTitleCrid,
      Wrapped<List<Object>?>? programs}) {
    return FeedComposerResponseWithSeedTitleAndGenre(
        seedContentGenreTermId: (seedContentGenreTermId != null
            ? seedContentGenreTermId.value
            : this.seedContentGenreTermId),
        seedTitleCrid:
            (seedTitleCrid != null ? seedTitleCrid.value : this.seedTitleCrid),
        programs: (programs != null ? programs.value : this.programs));
  }
}

@JsonSerializable(explicitToJson: true)
class FeedComposerResponseForPurchasedProgram {
  FeedComposerResponseForPurchasedProgram({
    this.programs,
  });

  factory FeedComposerResponseForPurchasedProgram.fromJson(
          Map<String, dynamic> json) =>
      _$FeedComposerResponseForPurchasedProgramFromJson(json);

  @JsonKey(
      name: 'programs',
      includeIfNull: false,
      defaultValue: <PurchasedProgram>[])
  final List<PurchasedProgram>? programs;
  static const fromJsonFactory =
      _$FeedComposerResponseForPurchasedProgramFromJson;
  static const toJsonFactory = _$FeedComposerResponseForPurchasedProgramToJson;
  Map<String, dynamic> toJson() =>
      _$FeedComposerResponseForPurchasedProgramToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is FeedComposerResponseForPurchasedProgram &&
            (identical(other.programs, programs) ||
                const DeepCollectionEquality()
                    .equals(other.programs, programs)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(programs) ^ runtimeType.hashCode;
}

extension $FeedComposerResponseForPurchasedProgramExtension
    on FeedComposerResponseForPurchasedProgram {
  FeedComposerResponseForPurchasedProgram copyWith(
      {List<PurchasedProgram>? programs}) {
    return FeedComposerResponseForPurchasedProgram(
        programs: programs ?? this.programs);
  }

  FeedComposerResponseForPurchasedProgram copyWithWrapped(
      {Wrapped<List<PurchasedProgram>?>? programs}) {
    return FeedComposerResponseForPurchasedProgram(
        programs: (programs != null ? programs.value : this.programs));
  }
}

@JsonSerializable(explicitToJson: true)
class PurchasedProgram {
  PurchasedProgram({
    this.crid,
    this.type,
    this.brandingProviderId,
    this.productId,
  });

  factory PurchasedProgram.fromJson(Map<String, dynamic> json) =>
      _$PurchasedProgramFromJson(json);

  @JsonKey(name: 'crid', includeIfNull: false, defaultValue: '')
  final String? crid;
  @JsonKey(
    name: 'type',
    includeIfNull: false,
    toJson: purchasedProgramTypeToJson,
    fromJson: purchasedProgramTypeFromJson,
  )
  final enums.PurchasedProgramType? type;
  @JsonKey(name: 'brandingProviderId', includeIfNull: false, defaultValue: '')
  final String? brandingProviderId;
  @JsonKey(name: 'productId', includeIfNull: false, defaultValue: '')
  final String? productId;
  static const fromJsonFactory = _$PurchasedProgramFromJson;
  static const toJsonFactory = _$PurchasedProgramToJson;
  Map<String, dynamic> toJson() => _$PurchasedProgramToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PurchasedProgram &&
            (identical(other.crid, crid) ||
                const DeepCollectionEquality().equals(other.crid, crid)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.brandingProviderId, brandingProviderId) ||
                const DeepCollectionEquality()
                    .equals(other.brandingProviderId, brandingProviderId)) &&
            (identical(other.productId, productId) ||
                const DeepCollectionEquality()
                    .equals(other.productId, productId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(crid) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(brandingProviderId) ^
      const DeepCollectionEquality().hash(productId) ^
      runtimeType.hashCode;
}

extension $PurchasedProgramExtension on PurchasedProgram {
  PurchasedProgram copyWith(
      {String? crid,
      enums.PurchasedProgramType? type,
      String? brandingProviderId,
      String? productId}) {
    return PurchasedProgram(
        crid: crid ?? this.crid,
        type: type ?? this.type,
        brandingProviderId: brandingProviderId ?? this.brandingProviderId,
        productId: productId ?? this.productId);
  }

  PurchasedProgram copyWithWrapped(
      {Wrapped<String?>? crid,
      Wrapped<enums.PurchasedProgramType?>? type,
      Wrapped<String?>? brandingProviderId,
      Wrapped<String?>? productId}) {
    return PurchasedProgram(
        crid: (crid != null ? crid.value : this.crid),
        type: (type != null ? type.value : this.type),
        brandingProviderId: (brandingProviderId != null
            ? brandingProviderId.value
            : this.brandingProviderId),
        productId: (productId != null ? productId.value : this.productId));
  }
}

@JsonSerializable(explicitToJson: true)
class ASpot {
  ASpot({
    this.id,
    this.mergedId,
    this.title,
    this.isAdult,
    this.imageVersion,
    this.screenLayout,
    this.background,
    this.treatment,
    this.gridLink,
    this.synopsis,
    this.isBoxset,
  });

  factory ASpot.fromJson(Map<String, dynamic> json) => _$ASpotFromJson(json);

  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String? id;
  @JsonKey(name: 'mergedId', includeIfNull: false, defaultValue: '')
  final String? mergedId;
  @JsonKey(name: 'title', includeIfNull: false, defaultValue: '')
  final String? title;
  @JsonKey(name: 'isAdult', includeIfNull: false)
  final bool? isAdult;
  @JsonKey(name: 'imageVersion', includeIfNull: false, defaultValue: '')
  final String? imageVersion;
  @JsonKey(name: 'screenLayout', includeIfNull: false, defaultValue: '')
  final String? screenLayout;
  @JsonKey(name: 'background', includeIfNull: false, defaultValue: '')
  final String? background;
  @JsonKey(name: 'treatment', includeIfNull: false, defaultValue: '')
  final String? treatment;
  @JsonKey(name: 'gridLink', includeIfNull: false)
  final GridLink? gridLink;
  @JsonKey(name: 'synopsis', includeIfNull: false, defaultValue: '')
  final String? synopsis;
  @JsonKey(name: 'isBoxset', includeIfNull: false)
  final bool? isBoxset;
  static const fromJsonFactory = _$ASpotFromJson;
  static const toJsonFactory = _$ASpotToJson;
  Map<String, dynamic> toJson() => _$ASpotToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ASpot &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.mergedId, mergedId) ||
                const DeepCollectionEquality()
                    .equals(other.mergedId, mergedId)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.isAdult, isAdult) ||
                const DeepCollectionEquality()
                    .equals(other.isAdult, isAdult)) &&
            (identical(other.imageVersion, imageVersion) ||
                const DeepCollectionEquality()
                    .equals(other.imageVersion, imageVersion)) &&
            (identical(other.screenLayout, screenLayout) ||
                const DeepCollectionEquality()
                    .equals(other.screenLayout, screenLayout)) &&
            (identical(other.background, background) ||
                const DeepCollectionEquality()
                    .equals(other.background, background)) &&
            (identical(other.treatment, treatment) ||
                const DeepCollectionEquality()
                    .equals(other.treatment, treatment)) &&
            (identical(other.gridLink, gridLink) ||
                const DeepCollectionEquality()
                    .equals(other.gridLink, gridLink)) &&
            (identical(other.synopsis, synopsis) ||
                const DeepCollectionEquality()
                    .equals(other.synopsis, synopsis)) &&
            (identical(other.isBoxset, isBoxset) ||
                const DeepCollectionEquality()
                    .equals(other.isBoxset, isBoxset)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(mergedId) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(isAdult) ^
      const DeepCollectionEquality().hash(imageVersion) ^
      const DeepCollectionEquality().hash(screenLayout) ^
      const DeepCollectionEquality().hash(background) ^
      const DeepCollectionEquality().hash(treatment) ^
      const DeepCollectionEquality().hash(gridLink) ^
      const DeepCollectionEquality().hash(synopsis) ^
      const DeepCollectionEquality().hash(isBoxset) ^
      runtimeType.hashCode;
}

extension $ASpotExtension on ASpot {
  ASpot copyWith(
      {String? id,
      String? mergedId,
      String? title,
      bool? isAdult,
      String? imageVersion,
      String? screenLayout,
      String? background,
      String? treatment,
      GridLink? gridLink,
      String? synopsis,
      bool? isBoxset}) {
    return ASpot(
        id: id ?? this.id,
        mergedId: mergedId ?? this.mergedId,
        title: title ?? this.title,
        isAdult: isAdult ?? this.isAdult,
        imageVersion: imageVersion ?? this.imageVersion,
        screenLayout: screenLayout ?? this.screenLayout,
        background: background ?? this.background,
        treatment: treatment ?? this.treatment,
        gridLink: gridLink ?? this.gridLink,
        synopsis: synopsis ?? this.synopsis,
        isBoxset: isBoxset ?? this.isBoxset);
  }

  ASpot copyWithWrapped(
      {Wrapped<String?>? id,
      Wrapped<String?>? mergedId,
      Wrapped<String?>? title,
      Wrapped<bool?>? isAdult,
      Wrapped<String?>? imageVersion,
      Wrapped<String?>? screenLayout,
      Wrapped<String?>? background,
      Wrapped<String?>? treatment,
      Wrapped<GridLink?>? gridLink,
      Wrapped<String?>? synopsis,
      Wrapped<bool?>? isBoxset}) {
    return ASpot(
        id: (id != null ? id.value : this.id),
        mergedId: (mergedId != null ? mergedId.value : this.mergedId),
        title: (title != null ? title.value : this.title),
        isAdult: (isAdult != null ? isAdult.value : this.isAdult),
        imageVersion:
            (imageVersion != null ? imageVersion.value : this.imageVersion),
        screenLayout:
            (screenLayout != null ? screenLayout.value : this.screenLayout),
        background: (background != null ? background.value : this.background),
        treatment: (treatment != null ? treatment.value : this.treatment),
        gridLink: (gridLink != null ? gridLink.value : this.gridLink),
        synopsis: (synopsis != null ? synopsis.value : this.synopsis),
        isBoxset: (isBoxset != null ? isBoxset.value : this.isBoxset));
  }
}

@JsonSerializable(explicitToJson: true)
class Collection {
  Collection({
    this.id,
    this.title,
    this.ordinal,
    this.type,
    this.isAdult,
    this.collectionLayout,
    this.contentType,
    this.totalCount,
    this.gridLink,
    this.collectionTheme,
    this.items,
  });

  factory Collection.fromJson(Map<String, dynamic> json) =>
      _$CollectionFromJson(json);

  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String? id;
  @JsonKey(name: 'title', includeIfNull: false, defaultValue: '')
  final String? title;
  @JsonKey(name: 'ordinal', includeIfNull: false)
  final int? ordinal;
  @JsonKey(name: 'type', includeIfNull: false, defaultValue: '')
  final String? type;
  @JsonKey(name: 'isAdult', includeIfNull: false)
  final bool? isAdult;
  @JsonKey(name: 'collectionLayout', includeIfNull: false, defaultValue: '')
  final String? collectionLayout;
  @JsonKey(name: 'contentType', includeIfNull: false, defaultValue: '')
  final String? contentType;
  @JsonKey(name: 'totalCount', includeIfNull: false)
  final int? totalCount;
  @JsonKey(name: 'gridLink', includeIfNull: false)
  final GridLink? gridLink;
  @JsonKey(name: 'collectionTheme', includeIfNull: false)
  final CollectionTheme? collectionTheme;
  @JsonKey(name: 'items', includeIfNull: false, defaultValue: <Item>[])
  final List<Item>? items;
  static const fromJsonFactory = _$CollectionFromJson;
  static const toJsonFactory = _$CollectionToJson;
  Map<String, dynamic> toJson() => _$CollectionToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Collection &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.ordinal, ordinal) ||
                const DeepCollectionEquality()
                    .equals(other.ordinal, ordinal)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.isAdult, isAdult) ||
                const DeepCollectionEquality()
                    .equals(other.isAdult, isAdult)) &&
            (identical(other.collectionLayout, collectionLayout) ||
                const DeepCollectionEquality()
                    .equals(other.collectionLayout, collectionLayout)) &&
            (identical(other.contentType, contentType) ||
                const DeepCollectionEquality()
                    .equals(other.contentType, contentType)) &&
            (identical(other.totalCount, totalCount) ||
                const DeepCollectionEquality()
                    .equals(other.totalCount, totalCount)) &&
            (identical(other.gridLink, gridLink) ||
                const DeepCollectionEquality()
                    .equals(other.gridLink, gridLink)) &&
            (identical(other.collectionTheme, collectionTheme) ||
                const DeepCollectionEquality()
                    .equals(other.collectionTheme, collectionTheme)) &&
            (identical(other.items, items) ||
                const DeepCollectionEquality().equals(other.items, items)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(ordinal) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(isAdult) ^
      const DeepCollectionEquality().hash(collectionLayout) ^
      const DeepCollectionEquality().hash(contentType) ^
      const DeepCollectionEquality().hash(totalCount) ^
      const DeepCollectionEquality().hash(gridLink) ^
      const DeepCollectionEquality().hash(collectionTheme) ^
      const DeepCollectionEquality().hash(items) ^
      runtimeType.hashCode;
}

extension $CollectionExtension on Collection {
  Collection copyWith(
      {String? id,
      String? title,
      int? ordinal,
      String? type,
      bool? isAdult,
      String? collectionLayout,
      String? contentType,
      int? totalCount,
      GridLink? gridLink,
      CollectionTheme? collectionTheme,
      List<Item>? items}) {
    return Collection(
        id: id ?? this.id,
        title: title ?? this.title,
        ordinal: ordinal ?? this.ordinal,
        type: type ?? this.type,
        isAdult: isAdult ?? this.isAdult,
        collectionLayout: collectionLayout ?? this.collectionLayout,
        contentType: contentType ?? this.contentType,
        totalCount: totalCount ?? this.totalCount,
        gridLink: gridLink ?? this.gridLink,
        collectionTheme: collectionTheme ?? this.collectionTheme,
        items: items ?? this.items);
  }

  Collection copyWithWrapped(
      {Wrapped<String?>? id,
      Wrapped<String?>? title,
      Wrapped<int?>? ordinal,
      Wrapped<String?>? type,
      Wrapped<bool?>? isAdult,
      Wrapped<String?>? collectionLayout,
      Wrapped<String?>? contentType,
      Wrapped<int?>? totalCount,
      Wrapped<GridLink?>? gridLink,
      Wrapped<CollectionTheme?>? collectionTheme,
      Wrapped<List<Item>?>? items}) {
    return Collection(
        id: (id != null ? id.value : this.id),
        title: (title != null ? title.value : this.title),
        ordinal: (ordinal != null ? ordinal.value : this.ordinal),
        type: (type != null ? type.value : this.type),
        isAdult: (isAdult != null ? isAdult.value : this.isAdult),
        collectionLayout: (collectionLayout != null
            ? collectionLayout.value
            : this.collectionLayout),
        contentType:
            (contentType != null ? contentType.value : this.contentType),
        totalCount: (totalCount != null ? totalCount.value : this.totalCount),
        gridLink: (gridLink != null ? gridLink.value : this.gridLink),
        collectionTheme: (collectionTheme != null
            ? collectionTheme.value
            : this.collectionTheme),
        items: (items != null ? items.value : this.items));
  }
}

@JsonSerializable(explicitToJson: true)
class GridLink {
  GridLink({
    this.id,
    this.type,
    this.softLinkType,
    this.title,
    this.theme,
  });

  factory GridLink.fromJson(Map<String, dynamic> json) =>
      _$GridLinkFromJson(json);

  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String? id;
  @JsonKey(name: 'type', includeIfNull: false, defaultValue: '')
  final String? type;
  @JsonKey(name: 'softLinkType', includeIfNull: false, defaultValue: '')
  final String? softLinkType;
  @JsonKey(name: 'title', includeIfNull: false, defaultValue: '')
  final String? title;
  @JsonKey(name: 'theme', includeIfNull: false)
  final Theme? theme;
  static const fromJsonFactory = _$GridLinkFromJson;
  static const toJsonFactory = _$GridLinkToJson;
  Map<String, dynamic> toJson() => _$GridLinkToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is GridLink &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.softLinkType, softLinkType) ||
                const DeepCollectionEquality()
                    .equals(other.softLinkType, softLinkType)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.theme, theme) ||
                const DeepCollectionEquality().equals(other.theme, theme)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(softLinkType) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(theme) ^
      runtimeType.hashCode;
}

extension $GridLinkExtension on GridLink {
  GridLink copyWith(
      {String? id,
      String? type,
      String? softLinkType,
      String? title,
      Theme? theme}) {
    return GridLink(
        id: id ?? this.id,
        type: type ?? this.type,
        softLinkType: softLinkType ?? this.softLinkType,
        title: title ?? this.title,
        theme: theme ?? this.theme);
  }

  GridLink copyWithWrapped(
      {Wrapped<String?>? id,
      Wrapped<String?>? type,
      Wrapped<String?>? softLinkType,
      Wrapped<String?>? title,
      Wrapped<Theme?>? theme}) {
    return GridLink(
        id: (id != null ? id.value : this.id),
        type: (type != null ? type.value : this.type),
        softLinkType:
            (softLinkType != null ? softLinkType.value : this.softLinkType),
        title: (title != null ? title.value : this.title),
        theme: (theme != null ? theme.value : this.theme));
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionTheme {
  CollectionTheme({
    this.backgroundColor,
    this.showProviderLogo,
  });

  factory CollectionTheme.fromJson(Map<String, dynamic> json) =>
      _$CollectionThemeFromJson(json);

  @JsonKey(name: 'backgroundColor', includeIfNull: false, defaultValue: '')
  final String? backgroundColor;
  @JsonKey(name: 'showProviderLogo', includeIfNull: false)
  final bool? showProviderLogo;
  static const fromJsonFactory = _$CollectionThemeFromJson;
  static const toJsonFactory = _$CollectionThemeToJson;
  Map<String, dynamic> toJson() => _$CollectionThemeToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CollectionTheme &&
            (identical(other.backgroundColor, backgroundColor) ||
                const DeepCollectionEquality()
                    .equals(other.backgroundColor, backgroundColor)) &&
            (identical(other.showProviderLogo, showProviderLogo) ||
                const DeepCollectionEquality()
                    .equals(other.showProviderLogo, showProviderLogo)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(backgroundColor) ^
      const DeepCollectionEquality().hash(showProviderLogo) ^
      runtimeType.hashCode;
}

extension $CollectionThemeExtension on CollectionTheme {
  CollectionTheme copyWith({String? backgroundColor, bool? showProviderLogo}) {
    return CollectionTheme(
        backgroundColor: backgroundColor ?? this.backgroundColor,
        showProviderLogo: showProviderLogo ?? this.showProviderLogo);
  }

  CollectionTheme copyWithWrapped(
      {Wrapped<String?>? backgroundColor, Wrapped<bool?>? showProviderLogo}) {
    return CollectionTheme(
        backgroundColor: (backgroundColor != null
            ? backgroundColor.value
            : this.backgroundColor),
        showProviderLogo: (showProviderLogo != null
            ? showProviderLogo.value
            : this.showProviderLogo));
  }
}

@JsonSerializable(explicitToJson: true)
class Hotlinks {
  Hotlinks({
    this.rentScreen,
    this.adultRentScreen,
    this.mainMenuPromo,
  });

  factory Hotlinks.fromJson(Map<String, dynamic> json) =>
      _$HotlinksFromJson(json);

  @JsonKey(name: 'rentScreen', includeIfNull: false)
  final Screen? rentScreen;
  @JsonKey(name: 'adultRentScreen', includeIfNull: false)
  final Screen? adultRentScreen;
  @JsonKey(name: 'mainMenuPromo', includeIfNull: false)
  final Screen? mainMenuPromo;
  static const fromJsonFactory = _$HotlinksFromJson;
  static const toJsonFactory = _$HotlinksToJson;
  Map<String, dynamic> toJson() => _$HotlinksToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Hotlinks &&
            (identical(other.rentScreen, rentScreen) ||
                const DeepCollectionEquality()
                    .equals(other.rentScreen, rentScreen)) &&
            (identical(other.adultRentScreen, adultRentScreen) ||
                const DeepCollectionEquality()
                    .equals(other.adultRentScreen, adultRentScreen)) &&
            (identical(other.mainMenuPromo, mainMenuPromo) ||
                const DeepCollectionEquality()
                    .equals(other.mainMenuPromo, mainMenuPromo)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(rentScreen) ^
      const DeepCollectionEquality().hash(adultRentScreen) ^
      const DeepCollectionEquality().hash(mainMenuPromo) ^
      runtimeType.hashCode;
}

extension $HotlinksExtension on Hotlinks {
  Hotlinks copyWith(
      {Screen? rentScreen, Screen? adultRentScreen, Screen? mainMenuPromo}) {
    return Hotlinks(
        rentScreen: rentScreen ?? this.rentScreen,
        adultRentScreen: adultRentScreen ?? this.adultRentScreen,
        mainMenuPromo: mainMenuPromo ?? this.mainMenuPromo);
  }

  Hotlinks copyWithWrapped(
      {Wrapped<Screen?>? rentScreen,
      Wrapped<Screen?>? adultRentScreen,
      Wrapped<Screen?>? mainMenuPromo}) {
    return Hotlinks(
        rentScreen: (rentScreen != null ? rentScreen.value : this.rentScreen),
        adultRentScreen: (adultRentScreen != null
            ? adultRentScreen.value
            : this.adultRentScreen),
        mainMenuPromo:
            (mainMenuPromo != null ? mainMenuPromo.value : this.mainMenuPromo));
  }
}

@JsonSerializable(explicitToJson: true)
class HttpCall {
  HttpCall({
    this.method,
    this.result,
    this.time,
  });

  factory HttpCall.fromJson(Map<String, dynamic> json) =>
      _$HttpCallFromJson(json);

  @JsonKey(name: 'method', includeIfNull: false, defaultValue: '')
  final String? method;
  @JsonKey(name: 'result', includeIfNull: false, defaultValue: '')
  final String? result;
  @JsonKey(name: 'time', includeIfNull: false, defaultValue: '')
  final String? time;
  static const fromJsonFactory = _$HttpCallFromJson;
  static const toJsonFactory = _$HttpCallToJson;
  Map<String, dynamic> toJson() => _$HttpCallToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is HttpCall &&
            (identical(other.method, method) ||
                const DeepCollectionEquality().equals(other.method, method)) &&
            (identical(other.result, result) ||
                const DeepCollectionEquality().equals(other.result, result)) &&
            (identical(other.time, time) ||
                const DeepCollectionEquality().equals(other.time, time)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(method) ^
      const DeepCollectionEquality().hash(result) ^
      const DeepCollectionEquality().hash(time) ^
      runtimeType.hashCode;
}

extension $HttpCallExtension on HttpCall {
  HttpCall copyWith({String? method, String? result, String? time}) {
    return HttpCall(
        method: method ?? this.method,
        result: result ?? this.result,
        time: time ?? this.time);
  }

  HttpCall copyWithWrapped(
      {Wrapped<String?>? method,
      Wrapped<String?>? result,
      Wrapped<String?>? time}) {
    return HttpCall(
        method: (method != null ? method.value : this.method),
        result: (result != null ? result.value : this.result),
        time: (time != null ? time.value : this.time));
  }
}

@JsonSerializable(explicitToJson: true)
class Item {
  Item({
    this.id,
    this.mergedId,
    this.type,
    this.assetType,
    this.title,
    this.subTitle,
    this.ordinal,
    this.isAdult,
    this.ageRating,
    this.duration,
    this.image,
    this.price,
    this.priceDisplay,
    this.minPrice,
    this.minPriceDisplay,
    this.seriesId,
    this.seriesTitle,
    this.seasonId,
    this.season,
    this.seasonCount,
    this.episode,
    this.gridLink,
    this.userInteractedWithSeries,
    this.bookmark,
    this.tvodEntitlementEnd,
    this.broadcastDate,
    this.channelName,
    this.screenLayout,
    this.promoVideoUrl,
    this.promoVideoEndImage,
    this.promoVideoEndText,
    this.isBoxset,
    this.goPlayable,
    this.brandingProviderId,
    this.minResolution,
    this.imageVersion,
  });

  factory Item.fromJson(Map<String, dynamic> json) => _$ItemFromJson(json);

  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String? id;
  @JsonKey(name: 'mergedId', includeIfNull: false, defaultValue: '')
  final String? mergedId;
  @JsonKey(
    name: 'type',
    includeIfNull: false,
    toJson: itemTypeToJson,
    fromJson: itemTypeFromJson,
  )
  final enums.ItemType? type;
  @JsonKey(
    name: 'assetType',
    includeIfNull: false,
    toJson: itemAssetTypeToJson,
    fromJson: itemAssetTypeFromJson,
  )
  final enums.ItemAssetType? assetType;
  @JsonKey(name: 'title', includeIfNull: false, defaultValue: '')
  final String? title;
  @JsonKey(name: 'subTitle', includeIfNull: false, defaultValue: '')
  final String? subTitle;
  @JsonKey(name: 'ordinal', includeIfNull: false)
  final int? ordinal;
  @JsonKey(name: 'isAdult', includeIfNull: false)
  final bool? isAdult;
  @JsonKey(name: 'ageRating', includeIfNull: false, defaultValue: '')
  final String? ageRating;
  @JsonKey(name: 'duration', includeIfNull: false)
  final int? duration;
  @JsonKey(name: 'image', includeIfNull: false, defaultValue: '')
  final String? image;
  @JsonKey(name: 'price', includeIfNull: false, defaultValue: '')
  final String? price;
  @JsonKey(name: 'priceDisplay', includeIfNull: false, defaultValue: '')
  final String? priceDisplay;
  @JsonKey(name: 'minPrice', includeIfNull: false, defaultValue: '')
  final String? minPrice;
  @JsonKey(name: 'minPriceDisplay', includeIfNull: false, defaultValue: '')
  final String? minPriceDisplay;
  @JsonKey(name: 'seriesId', includeIfNull: false, defaultValue: '')
  final String? seriesId;
  @JsonKey(name: 'seriesTitle', includeIfNull: false, defaultValue: '')
  final String? seriesTitle;
  @JsonKey(name: 'seasonId', includeIfNull: false, defaultValue: '')
  final String? seasonId;
  @JsonKey(name: 'season', includeIfNull: false, defaultValue: '')
  final String? season;
  @JsonKey(name: 'seasonCount', includeIfNull: false)
  final int? seasonCount;
  @JsonKey(name: 'episode', includeIfNull: false, defaultValue: '')
  final String? episode;
  @JsonKey(name: 'gridLink', includeIfNull: false)
  final GridLink? gridLink;
  @JsonKey(name: 'userInteractedWithSeries', includeIfNull: false)
  final bool? userInteractedWithSeries;
  @JsonKey(name: 'bookmark', includeIfNull: false)
  final int? bookmark;
  @JsonKey(name: 'tvodEntitlementEnd', includeIfNull: false)
  final DateTime? tvodEntitlementEnd;
  @JsonKey(name: 'broadcastDate', includeIfNull: false)
  final DateTime? broadcastDate;
  @JsonKey(name: 'channelName', includeIfNull: false, defaultValue: '')
  final String? channelName;
  @JsonKey(name: 'screenLayout', includeIfNull: false, defaultValue: '')
  final String? screenLayout;
  @JsonKey(name: 'promoVideoUrl', includeIfNull: false, defaultValue: '')
  final String? promoVideoUrl;
  @JsonKey(name: 'promoVideoEndImage', includeIfNull: false, defaultValue: '')
  final String? promoVideoEndImage;
  @JsonKey(name: 'promoVideoEndText', includeIfNull: false, defaultValue: '')
  final String? promoVideoEndText;
  @JsonKey(name: 'isBoxset', includeIfNull: false)
  final bool? isBoxset;
  @JsonKey(name: 'goPlayable', includeIfNull: false)
  final bool? goPlayable;
  @JsonKey(name: 'brandingProviderId', includeIfNull: false, defaultValue: '')
  final String? brandingProviderId;
  @JsonKey(
    name: 'minResolution',
    includeIfNull: false,
    toJson: itemMinResolutionToJson,
    fromJson: itemMinResolutionFromJson,
  )
  final enums.ItemMinResolution? minResolution;
  @JsonKey(name: 'imageVersion', includeIfNull: false, defaultValue: '')
  final String? imageVersion;
  static const fromJsonFactory = _$ItemFromJson;
  static const toJsonFactory = _$ItemToJson;
  Map<String, dynamic> toJson() => _$ItemToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Item &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.mergedId, mergedId) ||
                const DeepCollectionEquality()
                    .equals(other.mergedId, mergedId)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.assetType, assetType) ||
                const DeepCollectionEquality()
                    .equals(other.assetType, assetType)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.subTitle, subTitle) ||
                const DeepCollectionEquality()
                    .equals(other.subTitle, subTitle)) &&
            (identical(other.ordinal, ordinal) ||
                const DeepCollectionEquality()
                    .equals(other.ordinal, ordinal)) &&
            (identical(other.isAdult, isAdult) ||
                const DeepCollectionEquality()
                    .equals(other.isAdult, isAdult)) &&
            (identical(other.ageRating, ageRating) ||
                const DeepCollectionEquality()
                    .equals(other.ageRating, ageRating)) &&
            (identical(other.duration, duration) ||
                const DeepCollectionEquality()
                    .equals(other.duration, duration)) &&
            (identical(other.image, image) ||
                const DeepCollectionEquality().equals(other.image, image)) &&
            (identical(other.price, price) ||
                const DeepCollectionEquality().equals(other.price, price)) &&
            (identical(other.priceDisplay, priceDisplay) ||
                const DeepCollectionEquality()
                    .equals(other.priceDisplay, priceDisplay)) &&
            (identical(other.minPrice, minPrice) ||
                const DeepCollectionEquality()
                    .equals(other.minPrice, minPrice)) &&
            (identical(other.minPriceDisplay, minPriceDisplay) ||
                const DeepCollectionEquality()
                    .equals(other.minPriceDisplay, minPriceDisplay)) &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)) &&
            (identical(other.seriesTitle, seriesTitle) ||
                const DeepCollectionEquality()
                    .equals(other.seriesTitle, seriesTitle)) &&
            (identical(other.seasonId, seasonId) ||
                const DeepCollectionEquality()
                    .equals(other.seasonId, seasonId)) &&
            (identical(other.season, season) ||
                const DeepCollectionEquality().equals(other.season, season)) &&
            (identical(other.seasonCount, seasonCount) ||
                const DeepCollectionEquality()
                    .equals(other.seasonCount, seasonCount)) &&
            (identical(other.episode, episode) ||
                const DeepCollectionEquality()
                    .equals(other.episode, episode)) &&
            (identical(other.gridLink, gridLink) ||
                const DeepCollectionEquality()
                    .equals(other.gridLink, gridLink)) &&
            (identical(other.userInteractedWithSeries, userInteractedWithSeries) ||
                const DeepCollectionEquality().equals(
                    other.userInteractedWithSeries,
                    userInteractedWithSeries)) &&
            (identical(other.bookmark, bookmark) ||
                const DeepCollectionEquality().equals(other.bookmark, bookmark)) &&
            (identical(other.tvodEntitlementEnd, tvodEntitlementEnd) || const DeepCollectionEquality().equals(other.tvodEntitlementEnd, tvodEntitlementEnd)) &&
            (identical(other.broadcastDate, broadcastDate) || const DeepCollectionEquality().equals(other.broadcastDate, broadcastDate)) &&
            (identical(other.channelName, channelName) || const DeepCollectionEquality().equals(other.channelName, channelName)) &&
            (identical(other.screenLayout, screenLayout) || const DeepCollectionEquality().equals(other.screenLayout, screenLayout)) &&
            (identical(other.promoVideoUrl, promoVideoUrl) || const DeepCollectionEquality().equals(other.promoVideoUrl, promoVideoUrl)) &&
            (identical(other.promoVideoEndImage, promoVideoEndImage) || const DeepCollectionEquality().equals(other.promoVideoEndImage, promoVideoEndImage)) &&
            (identical(other.promoVideoEndText, promoVideoEndText) || const DeepCollectionEquality().equals(other.promoVideoEndText, promoVideoEndText)) &&
            (identical(other.isBoxset, isBoxset) || const DeepCollectionEquality().equals(other.isBoxset, isBoxset)) &&
            (identical(other.goPlayable, goPlayable) || const DeepCollectionEquality().equals(other.goPlayable, goPlayable)) &&
            (identical(other.brandingProviderId, brandingProviderId) || const DeepCollectionEquality().equals(other.brandingProviderId, brandingProviderId)) &&
            (identical(other.minResolution, minResolution) || const DeepCollectionEquality().equals(other.minResolution, minResolution)) &&
            (identical(other.imageVersion, imageVersion) || const DeepCollectionEquality().equals(other.imageVersion, imageVersion)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(mergedId) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(assetType) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(subTitle) ^
      const DeepCollectionEquality().hash(ordinal) ^
      const DeepCollectionEquality().hash(isAdult) ^
      const DeepCollectionEquality().hash(ageRating) ^
      const DeepCollectionEquality().hash(duration) ^
      const DeepCollectionEquality().hash(image) ^
      const DeepCollectionEquality().hash(price) ^
      const DeepCollectionEquality().hash(priceDisplay) ^
      const DeepCollectionEquality().hash(minPrice) ^
      const DeepCollectionEquality().hash(minPriceDisplay) ^
      const DeepCollectionEquality().hash(seriesId) ^
      const DeepCollectionEquality().hash(seriesTitle) ^
      const DeepCollectionEquality().hash(seasonId) ^
      const DeepCollectionEquality().hash(season) ^
      const DeepCollectionEquality().hash(seasonCount) ^
      const DeepCollectionEquality().hash(episode) ^
      const DeepCollectionEquality().hash(gridLink) ^
      const DeepCollectionEquality().hash(userInteractedWithSeries) ^
      const DeepCollectionEquality().hash(bookmark) ^
      const DeepCollectionEquality().hash(tvodEntitlementEnd) ^
      const DeepCollectionEquality().hash(broadcastDate) ^
      const DeepCollectionEquality().hash(channelName) ^
      const DeepCollectionEquality().hash(screenLayout) ^
      const DeepCollectionEquality().hash(promoVideoUrl) ^
      const DeepCollectionEquality().hash(promoVideoEndImage) ^
      const DeepCollectionEquality().hash(promoVideoEndText) ^
      const DeepCollectionEquality().hash(isBoxset) ^
      const DeepCollectionEquality().hash(goPlayable) ^
      const DeepCollectionEquality().hash(brandingProviderId) ^
      const DeepCollectionEquality().hash(minResolution) ^
      const DeepCollectionEquality().hash(imageVersion) ^
      runtimeType.hashCode;
}

extension $ItemExtension on Item {
  Item copyWith(
      {String? id,
      String? mergedId,
      enums.ItemType? type,
      enums.ItemAssetType? assetType,
      String? title,
      String? subTitle,
      int? ordinal,
      bool? isAdult,
      String? ageRating,
      int? duration,
      String? image,
      String? price,
      String? priceDisplay,
      String? minPrice,
      String? minPriceDisplay,
      String? seriesId,
      String? seriesTitle,
      String? seasonId,
      String? season,
      int? seasonCount,
      String? episode,
      GridLink? gridLink,
      bool? userInteractedWithSeries,
      int? bookmark,
      DateTime? tvodEntitlementEnd,
      DateTime? broadcastDate,
      String? channelName,
      String? screenLayout,
      String? promoVideoUrl,
      String? promoVideoEndImage,
      String? promoVideoEndText,
      bool? isBoxset,
      bool? goPlayable,
      String? brandingProviderId,
      enums.ItemMinResolution? minResolution,
      String? imageVersion}) {
    return Item(
        id: id ?? this.id,
        mergedId: mergedId ?? this.mergedId,
        type: type ?? this.type,
        assetType: assetType ?? this.assetType,
        title: title ?? this.title,
        subTitle: subTitle ?? this.subTitle,
        ordinal: ordinal ?? this.ordinal,
        isAdult: isAdult ?? this.isAdult,
        ageRating: ageRating ?? this.ageRating,
        duration: duration ?? this.duration,
        image: image ?? this.image,
        price: price ?? this.price,
        priceDisplay: priceDisplay ?? this.priceDisplay,
        minPrice: minPrice ?? this.minPrice,
        minPriceDisplay: minPriceDisplay ?? this.minPriceDisplay,
        seriesId: seriesId ?? this.seriesId,
        seriesTitle: seriesTitle ?? this.seriesTitle,
        seasonId: seasonId ?? this.seasonId,
        season: season ?? this.season,
        seasonCount: seasonCount ?? this.seasonCount,
        episode: episode ?? this.episode,
        gridLink: gridLink ?? this.gridLink,
        userInteractedWithSeries:
            userInteractedWithSeries ?? this.userInteractedWithSeries,
        bookmark: bookmark ?? this.bookmark,
        tvodEntitlementEnd: tvodEntitlementEnd ?? this.tvodEntitlementEnd,
        broadcastDate: broadcastDate ?? this.broadcastDate,
        channelName: channelName ?? this.channelName,
        screenLayout: screenLayout ?? this.screenLayout,
        promoVideoUrl: promoVideoUrl ?? this.promoVideoUrl,
        promoVideoEndImage: promoVideoEndImage ?? this.promoVideoEndImage,
        promoVideoEndText: promoVideoEndText ?? this.promoVideoEndText,
        isBoxset: isBoxset ?? this.isBoxset,
        goPlayable: goPlayable ?? this.goPlayable,
        brandingProviderId: brandingProviderId ?? this.brandingProviderId,
        minResolution: minResolution ?? this.minResolution,
        imageVersion: imageVersion ?? this.imageVersion);
  }

  Item copyWithWrapped(
      {Wrapped<String?>? id,
      Wrapped<String?>? mergedId,
      Wrapped<enums.ItemType?>? type,
      Wrapped<enums.ItemAssetType?>? assetType,
      Wrapped<String?>? title,
      Wrapped<String?>? subTitle,
      Wrapped<int?>? ordinal,
      Wrapped<bool?>? isAdult,
      Wrapped<String?>? ageRating,
      Wrapped<int?>? duration,
      Wrapped<String?>? image,
      Wrapped<String?>? price,
      Wrapped<String?>? priceDisplay,
      Wrapped<String?>? minPrice,
      Wrapped<String?>? minPriceDisplay,
      Wrapped<String?>? seriesId,
      Wrapped<String?>? seriesTitle,
      Wrapped<String?>? seasonId,
      Wrapped<String?>? season,
      Wrapped<int?>? seasonCount,
      Wrapped<String?>? episode,
      Wrapped<GridLink?>? gridLink,
      Wrapped<bool?>? userInteractedWithSeries,
      Wrapped<int?>? bookmark,
      Wrapped<DateTime?>? tvodEntitlementEnd,
      Wrapped<DateTime?>? broadcastDate,
      Wrapped<String?>? channelName,
      Wrapped<String?>? screenLayout,
      Wrapped<String?>? promoVideoUrl,
      Wrapped<String?>? promoVideoEndImage,
      Wrapped<String?>? promoVideoEndText,
      Wrapped<bool?>? isBoxset,
      Wrapped<bool?>? goPlayable,
      Wrapped<String?>? brandingProviderId,
      Wrapped<enums.ItemMinResolution?>? minResolution,
      Wrapped<String?>? imageVersion}) {
    return Item(
        id: (id != null ? id.value : this.id),
        mergedId: (mergedId != null ? mergedId.value : this.mergedId),
        type: (type != null ? type.value : this.type),
        assetType: (assetType != null ? assetType.value : this.assetType),
        title: (title != null ? title.value : this.title),
        subTitle: (subTitle != null ? subTitle.value : this.subTitle),
        ordinal: (ordinal != null ? ordinal.value : this.ordinal),
        isAdult: (isAdult != null ? isAdult.value : this.isAdult),
        ageRating: (ageRating != null ? ageRating.value : this.ageRating),
        duration: (duration != null ? duration.value : this.duration),
        image: (image != null ? image.value : this.image),
        price: (price != null ? price.value : this.price),
        priceDisplay:
            (priceDisplay != null ? priceDisplay.value : this.priceDisplay),
        minPrice: (minPrice != null ? minPrice.value : this.minPrice),
        minPriceDisplay: (minPriceDisplay != null
            ? minPriceDisplay.value
            : this.minPriceDisplay),
        seriesId: (seriesId != null ? seriesId.value : this.seriesId),
        seriesTitle:
            (seriesTitle != null ? seriesTitle.value : this.seriesTitle),
        seasonId: (seasonId != null ? seasonId.value : this.seasonId),
        season: (season != null ? season.value : this.season),
        seasonCount:
            (seasonCount != null ? seasonCount.value : this.seasonCount),
        episode: (episode != null ? episode.value : this.episode),
        gridLink: (gridLink != null ? gridLink.value : this.gridLink),
        userInteractedWithSeries: (userInteractedWithSeries != null
            ? userInteractedWithSeries.value
            : this.userInteractedWithSeries),
        bookmark: (bookmark != null ? bookmark.value : this.bookmark),
        tvodEntitlementEnd: (tvodEntitlementEnd != null
            ? tvodEntitlementEnd.value
            : this.tvodEntitlementEnd),
        broadcastDate:
            (broadcastDate != null ? broadcastDate.value : this.broadcastDate),
        channelName:
            (channelName != null ? channelName.value : this.channelName),
        screenLayout:
            (screenLayout != null ? screenLayout.value : this.screenLayout),
        promoVideoUrl:
            (promoVideoUrl != null ? promoVideoUrl.value : this.promoVideoUrl),
        promoVideoEndImage: (promoVideoEndImage != null
            ? promoVideoEndImage.value
            : this.promoVideoEndImage),
        promoVideoEndText: (promoVideoEndText != null
            ? promoVideoEndText.value
            : this.promoVideoEndText),
        isBoxset: (isBoxset != null ? isBoxset.value : this.isBoxset),
        goPlayable: (goPlayable != null ? goPlayable.value : this.goPlayable),
        brandingProviderId: (brandingProviderId != null
            ? brandingProviderId.value
            : this.brandingProviderId),
        minResolution:
            (minResolution != null ? minResolution.value : this.minResolution),
        imageVersion:
            (imageVersion != null ? imageVersion.value : this.imageVersion));
  }
}

@JsonSerializable(explicitToJson: true)
class PerformanceData {
  PerformanceData({
    this.totalTime,
    this.numberOfErrors,
    this.traxis,
    this.reng,
    this.unknown,
  });

  factory PerformanceData.fromJson(Map<String, dynamic> json) =>
      _$PerformanceDataFromJson(json);

  @JsonKey(name: 'totalTime', includeIfNull: false, defaultValue: '')
  final String? totalTime;
  @JsonKey(name: 'numberOfErrors', includeIfNull: false)
  final int? numberOfErrors;
  @JsonKey(name: 'traxis', includeIfNull: false, defaultValue: <HttpCall>[])
  final List<HttpCall>? traxis;
  @JsonKey(name: 'reng', includeIfNull: false, defaultValue: <HttpCall>[])
  final List<HttpCall>? reng;
  @JsonKey(name: 'unknown', includeIfNull: false, defaultValue: <HttpCall>[])
  final List<HttpCall>? unknown;
  static const fromJsonFactory = _$PerformanceDataFromJson;
  static const toJsonFactory = _$PerformanceDataToJson;
  Map<String, dynamic> toJson() => _$PerformanceDataToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PerformanceData &&
            (identical(other.totalTime, totalTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalTime, totalTime)) &&
            (identical(other.numberOfErrors, numberOfErrors) ||
                const DeepCollectionEquality()
                    .equals(other.numberOfErrors, numberOfErrors)) &&
            (identical(other.traxis, traxis) ||
                const DeepCollectionEquality().equals(other.traxis, traxis)) &&
            (identical(other.reng, reng) ||
                const DeepCollectionEquality().equals(other.reng, reng)) &&
            (identical(other.unknown, unknown) ||
                const DeepCollectionEquality().equals(other.unknown, unknown)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(totalTime) ^
      const DeepCollectionEquality().hash(numberOfErrors) ^
      const DeepCollectionEquality().hash(traxis) ^
      const DeepCollectionEquality().hash(reng) ^
      const DeepCollectionEquality().hash(unknown) ^
      runtimeType.hashCode;
}

extension $PerformanceDataExtension on PerformanceData {
  PerformanceData copyWith(
      {String? totalTime,
      int? numberOfErrors,
      List<HttpCall>? traxis,
      List<HttpCall>? reng,
      List<HttpCall>? unknown}) {
    return PerformanceData(
        totalTime: totalTime ?? this.totalTime,
        numberOfErrors: numberOfErrors ?? this.numberOfErrors,
        traxis: traxis ?? this.traxis,
        reng: reng ?? this.reng,
        unknown: unknown ?? this.unknown);
  }

  PerformanceData copyWithWrapped(
      {Wrapped<String?>? totalTime,
      Wrapped<int?>? numberOfErrors,
      Wrapped<List<HttpCall>?>? traxis,
      Wrapped<List<HttpCall>?>? reng,
      Wrapped<List<HttpCall>?>? unknown}) {
    return PerformanceData(
        totalTime: (totalTime != null ? totalTime.value : this.totalTime),
        numberOfErrors: (numberOfErrors != null
            ? numberOfErrors.value
            : this.numberOfErrors),
        traxis: (traxis != null ? traxis.value : this.traxis),
        reng: (reng != null ? reng.value : this.reng),
        unknown: (unknown != null ? unknown.value : this.unknown));
  }
}

@JsonSerializable(explicitToJson: true)
class Screen {
  Screen({
    this.id,
    this.structureId,
    this.title,
    this.ordinal,
    this.isAdult,
    this.screenLayout,
    this.theme,
    this.image,
    this.abTestGroup,
    this.brandingProviderId,
    this.isBoxset,
    this.aspot,
    this.collections,
    this.performanceData,
  });

  factory Screen.fromJson(Map<String, dynamic> json) => _$ScreenFromJson(json);

  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String? id;
  @JsonKey(name: 'structureId', includeIfNull: false, defaultValue: '')
  final String? structureId;
  @JsonKey(name: 'title', includeIfNull: false, defaultValue: '')
  final String? title;
  @JsonKey(name: 'ordinal', includeIfNull: false)
  final int? ordinal;
  @JsonKey(name: 'isAdult', includeIfNull: false)
  final bool? isAdult;
  @JsonKey(name: 'screenLayout', includeIfNull: false, defaultValue: '')
  final String? screenLayout;
  @JsonKey(name: 'theme', includeIfNull: false)
  final Theme? theme;
  @JsonKey(name: 'image', includeIfNull: false, defaultValue: '')
  final String? image;
  @JsonKey(name: 'abTestGroup', includeIfNull: false, defaultValue: '')
  final String? abTestGroup;
  @JsonKey(name: 'brandingProviderId', includeIfNull: false, defaultValue: '')
  final String? brandingProviderId;
  @JsonKey(name: 'isBoxset', includeIfNull: false)
  final bool? isBoxset;
  @JsonKey(name: 'aspot', includeIfNull: false)
  final ASpot? aspot;
  @JsonKey(
      name: 'collections', includeIfNull: false, defaultValue: <Collection>[])
  final List<Collection>? collections;
  @JsonKey(name: '_performanceData', includeIfNull: false)
  final PerformanceData? performanceData;
  static const fromJsonFactory = _$ScreenFromJson;
  static const toJsonFactory = _$ScreenToJson;
  Map<String, dynamic> toJson() => _$ScreenToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Screen &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.structureId, structureId) ||
                const DeepCollectionEquality()
                    .equals(other.structureId, structureId)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.ordinal, ordinal) ||
                const DeepCollectionEquality()
                    .equals(other.ordinal, ordinal)) &&
            (identical(other.isAdult, isAdult) ||
                const DeepCollectionEquality()
                    .equals(other.isAdult, isAdult)) &&
            (identical(other.screenLayout, screenLayout) ||
                const DeepCollectionEquality()
                    .equals(other.screenLayout, screenLayout)) &&
            (identical(other.theme, theme) ||
                const DeepCollectionEquality().equals(other.theme, theme)) &&
            (identical(other.image, image) ||
                const DeepCollectionEquality().equals(other.image, image)) &&
            (identical(other.abTestGroup, abTestGroup) ||
                const DeepCollectionEquality()
                    .equals(other.abTestGroup, abTestGroup)) &&
            (identical(other.brandingProviderId, brandingProviderId) ||
                const DeepCollectionEquality()
                    .equals(other.brandingProviderId, brandingProviderId)) &&
            (identical(other.isBoxset, isBoxset) ||
                const DeepCollectionEquality()
                    .equals(other.isBoxset, isBoxset)) &&
            (identical(other.aspot, aspot) ||
                const DeepCollectionEquality().equals(other.aspot, aspot)) &&
            (identical(other.collections, collections) ||
                const DeepCollectionEquality()
                    .equals(other.collections, collections)) &&
            (identical(other.performanceData, performanceData) ||
                const DeepCollectionEquality()
                    .equals(other.performanceData, performanceData)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(structureId) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(ordinal) ^
      const DeepCollectionEquality().hash(isAdult) ^
      const DeepCollectionEquality().hash(screenLayout) ^
      const DeepCollectionEquality().hash(theme) ^
      const DeepCollectionEquality().hash(image) ^
      const DeepCollectionEquality().hash(abTestGroup) ^
      const DeepCollectionEquality().hash(brandingProviderId) ^
      const DeepCollectionEquality().hash(isBoxset) ^
      const DeepCollectionEquality().hash(aspot) ^
      const DeepCollectionEquality().hash(collections) ^
      const DeepCollectionEquality().hash(performanceData) ^
      runtimeType.hashCode;
}

extension $ScreenExtension on Screen {
  Screen copyWith(
      {String? id,
      String? structureId,
      String? title,
      int? ordinal,
      bool? isAdult,
      String? screenLayout,
      Theme? theme,
      String? image,
      String? abTestGroup,
      String? brandingProviderId,
      bool? isBoxset,
      ASpot? aspot,
      List<Collection>? collections,
      PerformanceData? performanceData}) {
    return Screen(
        id: id ?? this.id,
        structureId: structureId ?? this.structureId,
        title: title ?? this.title,
        ordinal: ordinal ?? this.ordinal,
        isAdult: isAdult ?? this.isAdult,
        screenLayout: screenLayout ?? this.screenLayout,
        theme: theme ?? this.theme,
        image: image ?? this.image,
        abTestGroup: abTestGroup ?? this.abTestGroup,
        brandingProviderId: brandingProviderId ?? this.brandingProviderId,
        isBoxset: isBoxset ?? this.isBoxset,
        aspot: aspot ?? this.aspot,
        collections: collections ?? this.collections,
        performanceData: performanceData ?? this.performanceData);
  }

  Screen copyWithWrapped(
      {Wrapped<String?>? id,
      Wrapped<String?>? structureId,
      Wrapped<String?>? title,
      Wrapped<int?>? ordinal,
      Wrapped<bool?>? isAdult,
      Wrapped<String?>? screenLayout,
      Wrapped<Theme?>? theme,
      Wrapped<String?>? image,
      Wrapped<String?>? abTestGroup,
      Wrapped<String?>? brandingProviderId,
      Wrapped<bool?>? isBoxset,
      Wrapped<ASpot?>? aspot,
      Wrapped<List<Collection>?>? collections,
      Wrapped<PerformanceData?>? performanceData}) {
    return Screen(
        id: (id != null ? id.value : this.id),
        structureId:
            (structureId != null ? structureId.value : this.structureId),
        title: (title != null ? title.value : this.title),
        ordinal: (ordinal != null ? ordinal.value : this.ordinal),
        isAdult: (isAdult != null ? isAdult.value : this.isAdult),
        screenLayout:
            (screenLayout != null ? screenLayout.value : this.screenLayout),
        theme: (theme != null ? theme.value : this.theme),
        image: (image != null ? image.value : this.image),
        abTestGroup:
            (abTestGroup != null ? abTestGroup.value : this.abTestGroup),
        brandingProviderId: (brandingProviderId != null
            ? brandingProviderId.value
            : this.brandingProviderId),
        isBoxset: (isBoxset != null ? isBoxset.value : this.isBoxset),
        aspot: (aspot != null ? aspot.value : this.aspot),
        collections:
            (collections != null ? collections.value : this.collections),
        performanceData: (performanceData != null
            ? performanceData.value
            : this.performanceData));
  }
}

@JsonSerializable(explicitToJson: true)
class Structure {
  Structure({
    this.rootId,
    this.id,
    this.title,
    this.theme,
    this.screens,
    this.hotlinks,
  });

  factory Structure.fromJson(Map<String, dynamic> json) =>
      _$StructureFromJson(json);

  @JsonKey(name: 'rootId', includeIfNull: false, defaultValue: '')
  final String? rootId;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String? id;
  @JsonKey(name: 'title', includeIfNull: false, defaultValue: '')
  final String? title;
  @JsonKey(name: 'theme', includeIfNull: false)
  final Theme? theme;
  @JsonKey(name: 'screens', includeIfNull: false, defaultValue: <Screen>[])
  final List<Screen>? screens;
  @JsonKey(name: 'hotlinks', includeIfNull: false)
  final Hotlinks? hotlinks;
  static const fromJsonFactory = _$StructureFromJson;
  static const toJsonFactory = _$StructureToJson;
  Map<String, dynamic> toJson() => _$StructureToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Structure &&
            (identical(other.rootId, rootId) ||
                const DeepCollectionEquality().equals(other.rootId, rootId)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.theme, theme) ||
                const DeepCollectionEquality().equals(other.theme, theme)) &&
            (identical(other.screens, screens) ||
                const DeepCollectionEquality()
                    .equals(other.screens, screens)) &&
            (identical(other.hotlinks, hotlinks) ||
                const DeepCollectionEquality()
                    .equals(other.hotlinks, hotlinks)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(rootId) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(theme) ^
      const DeepCollectionEquality().hash(screens) ^
      const DeepCollectionEquality().hash(hotlinks) ^
      runtimeType.hashCode;
}

extension $StructureExtension on Structure {
  Structure copyWith(
      {String? rootId,
      String? id,
      String? title,
      Theme? theme,
      List<Screen>? screens,
      Hotlinks? hotlinks}) {
    return Structure(
        rootId: rootId ?? this.rootId,
        id: id ?? this.id,
        title: title ?? this.title,
        theme: theme ?? this.theme,
        screens: screens ?? this.screens,
        hotlinks: hotlinks ?? this.hotlinks);
  }

  Structure copyWithWrapped(
      {Wrapped<String?>? rootId,
      Wrapped<String?>? id,
      Wrapped<String?>? title,
      Wrapped<Theme?>? theme,
      Wrapped<List<Screen>?>? screens,
      Wrapped<Hotlinks?>? hotlinks}) {
    return Structure(
        rootId: (rootId != null ? rootId.value : this.rootId),
        id: (id != null ? id.value : this.id),
        title: (title != null ? title.value : this.title),
        theme: (theme != null ? theme.value : this.theme),
        screens: (screens != null ? screens.value : this.screens),
        hotlinks: (hotlinks != null ? hotlinks.value : this.hotlinks));
  }
}

@JsonSerializable(explicitToJson: true)
class Theme {
  Theme({
    this.name,
    this.background,
    this.aspotBackground,
    this.logoFocused,
    this.logoNonfocused,
    this.editorialImage,
    this.brandLogoImage,
  });

  factory Theme.fromJson(Map<String, dynamic> json) => _$ThemeFromJson(json);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String? name;
  @JsonKey(name: 'background', includeIfNull: false, defaultValue: '')
  final String? background;
  @JsonKey(name: 'aspotBackground', includeIfNull: false, defaultValue: '')
  final String? aspotBackground;
  @JsonKey(name: 'logoFocused', includeIfNull: false, defaultValue: '')
  final String? logoFocused;
  @JsonKey(name: 'logoNonfocused', includeIfNull: false, defaultValue: '')
  final String? logoNonfocused;
  @JsonKey(name: 'editorialImage', includeIfNull: false, defaultValue: '')
  final String? editorialImage;
  @JsonKey(name: 'brandLogoImage', includeIfNull: false, defaultValue: '')
  final String? brandLogoImage;
  static const fromJsonFactory = _$ThemeFromJson;
  static const toJsonFactory = _$ThemeToJson;
  Map<String, dynamic> toJson() => _$ThemeToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Theme &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.background, background) ||
                const DeepCollectionEquality()
                    .equals(other.background, background)) &&
            (identical(other.aspotBackground, aspotBackground) ||
                const DeepCollectionEquality()
                    .equals(other.aspotBackground, aspotBackground)) &&
            (identical(other.logoFocused, logoFocused) ||
                const DeepCollectionEquality()
                    .equals(other.logoFocused, logoFocused)) &&
            (identical(other.logoNonfocused, logoNonfocused) ||
                const DeepCollectionEquality()
                    .equals(other.logoNonfocused, logoNonfocused)) &&
            (identical(other.editorialImage, editorialImage) ||
                const DeepCollectionEquality()
                    .equals(other.editorialImage, editorialImage)) &&
            (identical(other.brandLogoImage, brandLogoImage) ||
                const DeepCollectionEquality()
                    .equals(other.brandLogoImage, brandLogoImage)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(background) ^
      const DeepCollectionEquality().hash(aspotBackground) ^
      const DeepCollectionEquality().hash(logoFocused) ^
      const DeepCollectionEquality().hash(logoNonfocused) ^
      const DeepCollectionEquality().hash(editorialImage) ^
      const DeepCollectionEquality().hash(brandLogoImage) ^
      runtimeType.hashCode;
}

extension $ThemeExtension on Theme {
  Theme copyWith(
      {String? name,
      String? background,
      String? aspotBackground,
      String? logoFocused,
      String? logoNonfocused,
      String? editorialImage,
      String? brandLogoImage}) {
    return Theme(
        name: name ?? this.name,
        background: background ?? this.background,
        aspotBackground: aspotBackground ?? this.aspotBackground,
        logoFocused: logoFocused ?? this.logoFocused,
        logoNonfocused: logoNonfocused ?? this.logoNonfocused,
        editorialImage: editorialImage ?? this.editorialImage,
        brandLogoImage: brandLogoImage ?? this.brandLogoImage);
  }

  Theme copyWithWrapped(
      {Wrapped<String?>? name,
      Wrapped<String?>? background,
      Wrapped<String?>? aspotBackground,
      Wrapped<String?>? logoFocused,
      Wrapped<String?>? logoNonfocused,
      Wrapped<String?>? editorialImage,
      Wrapped<String?>? brandLogoImage}) {
    return Theme(
        name: (name != null ? name.value : this.name),
        background: (background != null ? background.value : this.background),
        aspotBackground: (aspotBackground != null
            ? aspotBackground.value
            : this.aspotBackground),
        logoFocused:
            (logoFocused != null ? logoFocused.value : this.logoFocused),
        logoNonfocused: (logoNonfocused != null
            ? logoNonfocused.value
            : this.logoNonfocused),
        editorialImage: (editorialImage != null
            ? editorialImage.value
            : this.editorialImage),
        brandLogoImage: (brandLogoImage != null
            ? brandLogoImage.value
            : this.brandLogoImage));
  }
}

@JsonSerializable(explicitToJson: true)
class RentalScreen {
  RentalScreen({
    this.hasAdultRentals,
    this.id,
    this.title,
    this.screenLayout,
    this.isAdult,
    this.background,
    this.logoThumbnail,
    this.brandingProviderId,
    this.indexStart,
    this.itemCount,
    this.totalCount,
    this.items,
  });

  factory RentalScreen.fromJson(Map<String, dynamic> json) =>
      _$RentalScreenFromJson(json);

  @JsonKey(name: 'hasAdultRentals', includeIfNull: false)
  final bool? hasAdultRentals;
  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String? id;
  @JsonKey(name: 'title', includeIfNull: false, defaultValue: '')
  final String? title;
  @JsonKey(name: 'screenLayout', includeIfNull: false, defaultValue: '')
  final String? screenLayout;
  @JsonKey(name: 'isAdult', includeIfNull: false)
  final bool? isAdult;
  @JsonKey(name: 'background', includeIfNull: false, defaultValue: '')
  final String? background;
  @JsonKey(name: 'logoThumbnail', includeIfNull: false, defaultValue: '')
  final String? logoThumbnail;
  @JsonKey(name: 'brandingProviderId', includeIfNull: false, defaultValue: '')
  final String? brandingProviderId;
  @JsonKey(name: 'indexStart', includeIfNull: false)
  final int? indexStart;
  @JsonKey(name: 'itemCount', includeIfNull: false)
  final int? itemCount;
  @JsonKey(name: 'totalCount', includeIfNull: false)
  final int? totalCount;
  @JsonKey(name: 'items', includeIfNull: false, defaultValue: <Item>[])
  final List<Item>? items;
  static const fromJsonFactory = _$RentalScreenFromJson;
  static const toJsonFactory = _$RentalScreenToJson;
  Map<String, dynamic> toJson() => _$RentalScreenToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is RentalScreen &&
            (identical(other.hasAdultRentals, hasAdultRentals) ||
                const DeepCollectionEquality()
                    .equals(other.hasAdultRentals, hasAdultRentals)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.screenLayout, screenLayout) ||
                const DeepCollectionEquality()
                    .equals(other.screenLayout, screenLayout)) &&
            (identical(other.isAdult, isAdult) ||
                const DeepCollectionEquality()
                    .equals(other.isAdult, isAdult)) &&
            (identical(other.background, background) ||
                const DeepCollectionEquality()
                    .equals(other.background, background)) &&
            (identical(other.logoThumbnail, logoThumbnail) ||
                const DeepCollectionEquality()
                    .equals(other.logoThumbnail, logoThumbnail)) &&
            (identical(other.brandingProviderId, brandingProviderId) ||
                const DeepCollectionEquality()
                    .equals(other.brandingProviderId, brandingProviderId)) &&
            (identical(other.indexStart, indexStart) ||
                const DeepCollectionEquality()
                    .equals(other.indexStart, indexStart)) &&
            (identical(other.itemCount, itemCount) ||
                const DeepCollectionEquality()
                    .equals(other.itemCount, itemCount)) &&
            (identical(other.totalCount, totalCount) ||
                const DeepCollectionEquality()
                    .equals(other.totalCount, totalCount)) &&
            (identical(other.items, items) ||
                const DeepCollectionEquality().equals(other.items, items)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(hasAdultRentals) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(screenLayout) ^
      const DeepCollectionEquality().hash(isAdult) ^
      const DeepCollectionEquality().hash(background) ^
      const DeepCollectionEquality().hash(logoThumbnail) ^
      const DeepCollectionEquality().hash(brandingProviderId) ^
      const DeepCollectionEquality().hash(indexStart) ^
      const DeepCollectionEquality().hash(itemCount) ^
      const DeepCollectionEquality().hash(totalCount) ^
      const DeepCollectionEquality().hash(items) ^
      runtimeType.hashCode;
}

extension $RentalScreenExtension on RentalScreen {
  RentalScreen copyWith(
      {bool? hasAdultRentals,
      String? id,
      String? title,
      String? screenLayout,
      bool? isAdult,
      String? background,
      String? logoThumbnail,
      String? brandingProviderId,
      int? indexStart,
      int? itemCount,
      int? totalCount,
      List<Item>? items}) {
    return RentalScreen(
        hasAdultRentals: hasAdultRentals ?? this.hasAdultRentals,
        id: id ?? this.id,
        title: title ?? this.title,
        screenLayout: screenLayout ?? this.screenLayout,
        isAdult: isAdult ?? this.isAdult,
        background: background ?? this.background,
        logoThumbnail: logoThumbnail ?? this.logoThumbnail,
        brandingProviderId: brandingProviderId ?? this.brandingProviderId,
        indexStart: indexStart ?? this.indexStart,
        itemCount: itemCount ?? this.itemCount,
        totalCount: totalCount ?? this.totalCount,
        items: items ?? this.items);
  }

  RentalScreen copyWithWrapped(
      {Wrapped<bool?>? hasAdultRentals,
      Wrapped<String?>? id,
      Wrapped<String?>? title,
      Wrapped<String?>? screenLayout,
      Wrapped<bool?>? isAdult,
      Wrapped<String?>? background,
      Wrapped<String?>? logoThumbnail,
      Wrapped<String?>? brandingProviderId,
      Wrapped<int?>? indexStart,
      Wrapped<int?>? itemCount,
      Wrapped<int?>? totalCount,
      Wrapped<List<Item>?>? items}) {
    return RentalScreen(
        hasAdultRentals: (hasAdultRentals != null
            ? hasAdultRentals.value
            : this.hasAdultRentals),
        id: (id != null ? id.value : this.id),
        title: (title != null ? title.value : this.title),
        screenLayout:
            (screenLayout != null ? screenLayout.value : this.screenLayout),
        isAdult: (isAdult != null ? isAdult.value : this.isAdult),
        background: (background != null ? background.value : this.background),
        logoThumbnail:
            (logoThumbnail != null ? logoThumbnail.value : this.logoThumbnail),
        brandingProviderId: (brandingProviderId != null
            ? brandingProviderId.value
            : this.brandingProviderId),
        indexStart: (indexStart != null ? indexStart.value : this.indexStart),
        itemCount: (itemCount != null ? itemCount.value : this.itemCount),
        totalCount: (totalCount != null ? totalCount.value : this.totalCount),
        items: (items != null ? items.value : this.items));
  }
}

@JsonSerializable(explicitToJson: true)
class CastAndCrew {
  CastAndCrew({
    this.id,
    this.name,
    this.role,
    this.image,
  });

  factory CastAndCrew.fromJson(Map<String, dynamic> json) =>
      _$CastAndCrewFromJson(json);

  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String? id;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String? name;
  @JsonKey(name: 'role', includeIfNull: false, defaultValue: '')
  final String? role;
  @JsonKey(name: 'image', includeIfNull: false, defaultValue: '')
  final String? image;
  static const fromJsonFactory = _$CastAndCrewFromJson;
  static const toJsonFactory = _$CastAndCrewToJson;
  Map<String, dynamic> toJson() => _$CastAndCrewToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CastAndCrew &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.role, role) ||
                const DeepCollectionEquality().equals(other.role, role)) &&
            (identical(other.image, image) ||
                const DeepCollectionEquality().equals(other.image, image)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(role) ^
      const DeepCollectionEquality().hash(image) ^
      runtimeType.hashCode;
}

extension $CastAndCrewExtension on CastAndCrew {
  CastAndCrew copyWith(
      {String? id, String? name, String? role, String? image}) {
    return CastAndCrew(
        id: id ?? this.id,
        name: name ?? this.name,
        role: role ?? this.role,
        image: image ?? this.image);
  }

  CastAndCrew copyWithWrapped(
      {Wrapped<String?>? id,
      Wrapped<String?>? name,
      Wrapped<String?>? role,
      Wrapped<String?>? image}) {
    return CastAndCrew(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        role: (role != null ? role.value : this.role),
        image: (image != null ? image.value : this.image));
  }
}

@JsonSerializable(explicitToJson: true)
class TrailerInfo {
  TrailerInfo({
    this.id,
    this.title,
    this.duration,
    this.synopsis,
    this.parentTitleId,
    this.instances,
  });

  factory TrailerInfo.fromJson(Map<String, dynamic> json) =>
      _$TrailerInfoFromJson(json);

  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String? id;
  @JsonKey(name: 'title', includeIfNull: false, defaultValue: '')
  final String? title;
  @JsonKey(name: 'duration', includeIfNull: false)
  final int? duration;
  @JsonKey(name: 'synopsis', includeIfNull: false, defaultValue: '')
  final String? synopsis;
  @JsonKey(name: 'parentTitleId', includeIfNull: false, defaultValue: '')
  final String? parentTitleId;
  @JsonKey(
      name: 'instances',
      includeIfNull: false,
      defaultValue: <TrailerInstance>[])
  final List<TrailerInstance>? instances;
  static const fromJsonFactory = _$TrailerInfoFromJson;
  static const toJsonFactory = _$TrailerInfoToJson;
  Map<String, dynamic> toJson() => _$TrailerInfoToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TrailerInfo &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.duration, duration) ||
                const DeepCollectionEquality()
                    .equals(other.duration, duration)) &&
            (identical(other.synopsis, synopsis) ||
                const DeepCollectionEquality()
                    .equals(other.synopsis, synopsis)) &&
            (identical(other.parentTitleId, parentTitleId) ||
                const DeepCollectionEquality()
                    .equals(other.parentTitleId, parentTitleId)) &&
            (identical(other.instances, instances) ||
                const DeepCollectionEquality()
                    .equals(other.instances, instances)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(duration) ^
      const DeepCollectionEquality().hash(synopsis) ^
      const DeepCollectionEquality().hash(parentTitleId) ^
      const DeepCollectionEquality().hash(instances) ^
      runtimeType.hashCode;
}

extension $TrailerInfoExtension on TrailerInfo {
  TrailerInfo copyWith(
      {String? id,
      String? title,
      int? duration,
      String? synopsis,
      String? parentTitleId,
      List<TrailerInstance>? instances}) {
    return TrailerInfo(
        id: id ?? this.id,
        title: title ?? this.title,
        duration: duration ?? this.duration,
        synopsis: synopsis ?? this.synopsis,
        parentTitleId: parentTitleId ?? this.parentTitleId,
        instances: instances ?? this.instances);
  }

  TrailerInfo copyWithWrapped(
      {Wrapped<String?>? id,
      Wrapped<String?>? title,
      Wrapped<int?>? duration,
      Wrapped<String?>? synopsis,
      Wrapped<String?>? parentTitleId,
      Wrapped<List<TrailerInstance>?>? instances}) {
    return TrailerInfo(
        id: (id != null ? id.value : this.id),
        title: (title != null ? title.value : this.title),
        duration: (duration != null ? duration.value : this.duration),
        synopsis: (synopsis != null ? synopsis.value : this.synopsis),
        parentTitleId:
            (parentTitleId != null ? parentTitleId.value : this.parentTitleId),
        instances: (instances != null ? instances.value : this.instances));
  }
}

@JsonSerializable(explicitToJson: true)
class DetailScreen {
  DetailScreen({
    this.id,
    this.mergedId,
    this.imageVersion,
    this.type,
    this.assetType,
    this.title,
    this.subTitle,
    this.ordinal,
    this.isPreview,
    this.parentTitleId,
    this.isAdult,
    this.ageRating,
    this.duration,
    this.image,
    this.price,
    this.priceDisplay,
    this.minPrice,
    this.minPriceDisplay,
    this.seriesId,
    this.seriesTitle,
    this.seasonId,
    this.season,
    this.episode,
    this.gridLink,
    this.userInteractedWithSeries,
    this.bookmark,
    this.tvodEntitlementEnd,
    this.broadcastDate,
    this.channelName,
    this.screenLayout,
    this.totalEpisodes,
    this.parentalGuidanceText,
    this.onWatchlist,
    this.genres,
    this.synopsis,
    this.longSynopsis,
    this.audioLanguages,
    this.signLanguages,
    this.country,
    this.subtitles,
    this.supplementalAudioDescriptions,
    this.icons,
    this.trailers,
    this.trailerInfo,
    this.castAndCrew,
    this.castCollection,
    this.crewCollection,
    this.instances,
    this.prodYear,
    this.seasonCount,
    this.promoVideoUrl,
    this.promoVideoEndImage,
    this.promoVideoEndText,
    this.minResolution,
    this.isBoxset,
    this.goPlayable,
    this.brandingProviderId,
    this.sources,
  });

  factory DetailScreen.fromJson(Map<String, dynamic> json) =>
      _$DetailScreenFromJson(json);

  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String? id;
  @JsonKey(name: 'mergedId', includeIfNull: false, defaultValue: '')
  final String? mergedId;
  @JsonKey(name: 'imageVersion', includeIfNull: false, defaultValue: '')
  final String? imageVersion;
  @JsonKey(
    name: 'type',
    includeIfNull: false,
    toJson: detailScreenTypeToJson,
    fromJson: detailScreenTypeFromJson,
  )
  final enums.DetailScreenType? type;
  @JsonKey(
    name: 'assetType',
    includeIfNull: false,
    toJson: detailScreenAssetTypeToJson,
    fromJson: detailScreenAssetTypeFromJson,
  )
  final enums.DetailScreenAssetType? assetType;
  @JsonKey(name: 'title', includeIfNull: false, defaultValue: '')
  final String? title;
  @JsonKey(name: 'subTitle', includeIfNull: false, defaultValue: '')
  final String? subTitle;
  @JsonKey(name: 'ordinal', includeIfNull: false)
  final int? ordinal;
  @JsonKey(name: 'isPreview', includeIfNull: false)
  final bool? isPreview;
  @JsonKey(name: 'parentTitleId', includeIfNull: false, defaultValue: '')
  final String? parentTitleId;
  @JsonKey(name: 'isAdult', includeIfNull: false)
  final bool? isAdult;
  @JsonKey(name: 'ageRating', includeIfNull: false, defaultValue: '')
  final String? ageRating;
  @JsonKey(name: 'duration', includeIfNull: false)
  final int? duration;
  @JsonKey(name: 'image', includeIfNull: false, defaultValue: '')
  final String? image;
  @JsonKey(name: 'price', includeIfNull: false, defaultValue: '')
  final String? price;
  @JsonKey(name: 'priceDisplay', includeIfNull: false, defaultValue: '')
  final String? priceDisplay;
  @JsonKey(name: 'minPrice', includeIfNull: false, defaultValue: '')
  final String? minPrice;
  @JsonKey(name: 'minPriceDisplay', includeIfNull: false, defaultValue: '')
  final String? minPriceDisplay;
  @JsonKey(name: 'seriesId', includeIfNull: false, defaultValue: '')
  final String? seriesId;
  @JsonKey(name: 'seriesTitle', includeIfNull: false, defaultValue: '')
  final String? seriesTitle;
  @JsonKey(name: 'seasonId', includeIfNull: false, defaultValue: '')
  final String? seasonId;
  @JsonKey(name: 'season', includeIfNull: false, defaultValue: '')
  final String? season;
  @JsonKey(name: 'episode', includeIfNull: false, defaultValue: '')
  final String? episode;
  @JsonKey(name: 'gridLink', includeIfNull: false)
  final GridLink? gridLink;
  @JsonKey(name: 'userInteractedWithSeries', includeIfNull: false)
  final bool? userInteractedWithSeries;
  @JsonKey(name: 'bookmark', includeIfNull: false)
  final int? bookmark;
  @JsonKey(name: 'tvodEntitlementEnd', includeIfNull: false)
  final DateTime? tvodEntitlementEnd;
  @JsonKey(name: 'broadcastDate', includeIfNull: false)
  final DateTime? broadcastDate;
  @JsonKey(name: 'channelName', includeIfNull: false, defaultValue: '')
  final String? channelName;
  @JsonKey(name: 'screenLayout', includeIfNull: false, defaultValue: '')
  final String? screenLayout;
  @JsonKey(name: 'totalEpisodes', includeIfNull: false)
  final int? totalEpisodes;
  @JsonKey(name: 'parentalGuidanceText', includeIfNull: false, defaultValue: '')
  final String? parentalGuidanceText;
  @JsonKey(name: 'onWatchlist', includeIfNull: false)
  final bool? onWatchlist;
  @JsonKey(name: 'genres', includeIfNull: false, defaultValue: <String>[])
  final List<String>? genres;
  @JsonKey(name: 'synopsis', includeIfNull: false, defaultValue: '')
  final String? synopsis;
  @JsonKey(name: 'longSynopsis', includeIfNull: false, defaultValue: '')
  final String? longSynopsis;
  @JsonKey(
      name: 'audioLanguages', includeIfNull: false, defaultValue: <String>[])
  final List<String>? audioLanguages;
  @JsonKey(
      name: 'signLanguages', includeIfNull: false, defaultValue: <String>[])
  final List<String>? signLanguages;
  @JsonKey(name: 'country', includeIfNull: false, defaultValue: <String>[])
  final List<String>? country;
  @JsonKey(name: 'subtitles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? subtitles;
  @JsonKey(
      name: 'supplementalAudioDescriptions',
      includeIfNull: false,
      defaultValue: <String>[])
  final List<String>? supplementalAudioDescriptions;
  @JsonKey(name: 'icons', includeIfNull: false, defaultValue: <String>[])
  final List<String>? icons;
  @JsonKey(name: 'trailers', includeIfNull: false, defaultValue: <String>[])
  final List<String>? trailers;
  @JsonKey(
      name: 'trailerInfo', includeIfNull: false, defaultValue: <TrailerInfo>[])
  final List<TrailerInfo>? trailerInfo;
  @JsonKey(
      name: 'castAndCrew', includeIfNull: false, defaultValue: <CastAndCrew>[])
  final List<CastAndCrew>? castAndCrew;
  @JsonKey(
      name: 'castCollection',
      includeIfNull: false,
      defaultValue: <CastAndCrew>[])
  final List<CastAndCrew>? castCollection;
  @JsonKey(
      name: 'crewCollection',
      includeIfNull: false,
      defaultValue: <CastAndCrew>[])
  final List<CastAndCrew>? crewCollection;
  @JsonKey(name: 'instances', includeIfNull: false, defaultValue: <Instance>[])
  final List<Instance>? instances;
  @JsonKey(name: 'prodYear', includeIfNull: false, defaultValue: '')
  final String? prodYear;
  @JsonKey(name: 'seasonCount', includeIfNull: false)
  final int? seasonCount;
  @JsonKey(name: 'promoVideoUrl', includeIfNull: false, defaultValue: '')
  final String? promoVideoUrl;
  @JsonKey(name: 'promoVideoEndImage', includeIfNull: false, defaultValue: '')
  final String? promoVideoEndImage;
  @JsonKey(name: 'promoVideoEndText', includeIfNull: false, defaultValue: '')
  final String? promoVideoEndText;
  @JsonKey(
    name: 'minResolution',
    includeIfNull: false,
    toJson: detailScreenMinResolutionToJson,
    fromJson: detailScreenMinResolutionFromJson,
  )
  final enums.DetailScreenMinResolution? minResolution;
  @JsonKey(name: 'isBoxset', includeIfNull: false)
  final bool? isBoxset;
  @JsonKey(name: 'goPlayable', includeIfNull: false)
  final bool? goPlayable;
  @JsonKey(name: 'brandingProviderId', includeIfNull: false, defaultValue: '')
  final String? brandingProviderId;
  @JsonKey(name: 'sources', includeIfNull: false, defaultValue: <SourceExt>[])
  final List<SourceExt>? sources;
  static const fromJsonFactory = _$DetailScreenFromJson;
  static const toJsonFactory = _$DetailScreenToJson;
  Map<String, dynamic> toJson() => _$DetailScreenToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DetailScreen &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.mergedId, mergedId) ||
                const DeepCollectionEquality()
                    .equals(other.mergedId, mergedId)) &&
            (identical(other.imageVersion, imageVersion) ||
                const DeepCollectionEquality()
                    .equals(other.imageVersion, imageVersion)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.assetType, assetType) ||
                const DeepCollectionEquality()
                    .equals(other.assetType, assetType)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.subTitle, subTitle) ||
                const DeepCollectionEquality()
                    .equals(other.subTitle, subTitle)) &&
            (identical(other.ordinal, ordinal) ||
                const DeepCollectionEquality()
                    .equals(other.ordinal, ordinal)) &&
            (identical(other.isPreview, isPreview) ||
                const DeepCollectionEquality()
                    .equals(other.isPreview, isPreview)) &&
            (identical(other.parentTitleId, parentTitleId) ||
                const DeepCollectionEquality()
                    .equals(other.parentTitleId, parentTitleId)) &&
            (identical(other.isAdult, isAdult) ||
                const DeepCollectionEquality()
                    .equals(other.isAdult, isAdult)) &&
            (identical(other.ageRating, ageRating) ||
                const DeepCollectionEquality()
                    .equals(other.ageRating, ageRating)) &&
            (identical(other.duration, duration) ||
                const DeepCollectionEquality()
                    .equals(other.duration, duration)) &&
            (identical(other.image, image) ||
                const DeepCollectionEquality().equals(other.image, image)) &&
            (identical(other.price, price) ||
                const DeepCollectionEquality().equals(other.price, price)) &&
            (identical(other.priceDisplay, priceDisplay) ||
                const DeepCollectionEquality()
                    .equals(other.priceDisplay, priceDisplay)) &&
            (identical(other.minPrice, minPrice) ||
                const DeepCollectionEquality()
                    .equals(other.minPrice, minPrice)) &&
            (identical(other.minPriceDisplay, minPriceDisplay) ||
                const DeepCollectionEquality()
                    .equals(other.minPriceDisplay, minPriceDisplay)) &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)) &&
            (identical(other.seriesTitle, seriesTitle) ||
                const DeepCollectionEquality()
                    .equals(other.seriesTitle, seriesTitle)) &&
            (identical(other.seasonId, seasonId) ||
                const DeepCollectionEquality()
                    .equals(other.seasonId, seasonId)) &&
            (identical(other.season, season) ||
                const DeepCollectionEquality().equals(other.season, season)) &&
            (identical(other.episode, episode) ||
                const DeepCollectionEquality()
                    .equals(other.episode, episode)) &&
            (identical(other.gridLink, gridLink) ||
                const DeepCollectionEquality()
                    .equals(other.gridLink, gridLink)) &&
            (identical(other.userInteractedWithSeries, userInteractedWithSeries) ||
                const DeepCollectionEquality().equals(other.userInteractedWithSeries, userInteractedWithSeries)) &&
            (identical(other.bookmark, bookmark) || const DeepCollectionEquality().equals(other.bookmark, bookmark)) &&
            (identical(other.tvodEntitlementEnd, tvodEntitlementEnd) || const DeepCollectionEquality().equals(other.tvodEntitlementEnd, tvodEntitlementEnd)) &&
            (identical(other.broadcastDate, broadcastDate) || const DeepCollectionEquality().equals(other.broadcastDate, broadcastDate)) &&
            (identical(other.channelName, channelName) || const DeepCollectionEquality().equals(other.channelName, channelName)) &&
            (identical(other.screenLayout, screenLayout) || const DeepCollectionEquality().equals(other.screenLayout, screenLayout)) &&
            (identical(other.totalEpisodes, totalEpisodes) || const DeepCollectionEquality().equals(other.totalEpisodes, totalEpisodes)) &&
            (identical(other.parentalGuidanceText, parentalGuidanceText) || const DeepCollectionEquality().equals(other.parentalGuidanceText, parentalGuidanceText)) &&
            (identical(other.onWatchlist, onWatchlist) || const DeepCollectionEquality().equals(other.onWatchlist, onWatchlist)) &&
            (identical(other.genres, genres) || const DeepCollectionEquality().equals(other.genres, genres)) &&
            (identical(other.synopsis, synopsis) || const DeepCollectionEquality().equals(other.synopsis, synopsis)) &&
            (identical(other.longSynopsis, longSynopsis) || const DeepCollectionEquality().equals(other.longSynopsis, longSynopsis)) &&
            (identical(other.audioLanguages, audioLanguages) || const DeepCollectionEquality().equals(other.audioLanguages, audioLanguages)) &&
            (identical(other.signLanguages, signLanguages) || const DeepCollectionEquality().equals(other.signLanguages, signLanguages)) &&
            (identical(other.country, country) || const DeepCollectionEquality().equals(other.country, country)) &&
            (identical(other.subtitles, subtitles) || const DeepCollectionEquality().equals(other.subtitles, subtitles)) &&
            (identical(other.supplementalAudioDescriptions, supplementalAudioDescriptions) || const DeepCollectionEquality().equals(other.supplementalAudioDescriptions, supplementalAudioDescriptions)) &&
            (identical(other.icons, icons) || const DeepCollectionEquality().equals(other.icons, icons)) &&
            (identical(other.trailers, trailers) || const DeepCollectionEquality().equals(other.trailers, trailers)) &&
            (identical(other.trailerInfo, trailerInfo) || const DeepCollectionEquality().equals(other.trailerInfo, trailerInfo)) &&
            (identical(other.castAndCrew, castAndCrew) || const DeepCollectionEquality().equals(other.castAndCrew, castAndCrew)) &&
            (identical(other.castCollection, castCollection) || const DeepCollectionEquality().equals(other.castCollection, castCollection)) &&
            (identical(other.crewCollection, crewCollection) || const DeepCollectionEquality().equals(other.crewCollection, crewCollection)) &&
            (identical(other.instances, instances) || const DeepCollectionEquality().equals(other.instances, instances)) &&
            (identical(other.prodYear, prodYear) || const DeepCollectionEquality().equals(other.prodYear, prodYear)) &&
            (identical(other.seasonCount, seasonCount) || const DeepCollectionEquality().equals(other.seasonCount, seasonCount)) &&
            (identical(other.promoVideoUrl, promoVideoUrl) || const DeepCollectionEquality().equals(other.promoVideoUrl, promoVideoUrl)) &&
            (identical(other.promoVideoEndImage, promoVideoEndImage) || const DeepCollectionEquality().equals(other.promoVideoEndImage, promoVideoEndImage)) &&
            (identical(other.promoVideoEndText, promoVideoEndText) || const DeepCollectionEquality().equals(other.promoVideoEndText, promoVideoEndText)) &&
            (identical(other.minResolution, minResolution) || const DeepCollectionEquality().equals(other.minResolution, minResolution)) &&
            (identical(other.isBoxset, isBoxset) || const DeepCollectionEquality().equals(other.isBoxset, isBoxset)) &&
            (identical(other.goPlayable, goPlayable) || const DeepCollectionEquality().equals(other.goPlayable, goPlayable)) &&
            (identical(other.brandingProviderId, brandingProviderId) || const DeepCollectionEquality().equals(other.brandingProviderId, brandingProviderId)) &&
            (identical(other.sources, sources) || const DeepCollectionEquality().equals(other.sources, sources)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(mergedId) ^
      const DeepCollectionEquality().hash(imageVersion) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(assetType) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(subTitle) ^
      const DeepCollectionEquality().hash(ordinal) ^
      const DeepCollectionEquality().hash(isPreview) ^
      const DeepCollectionEquality().hash(parentTitleId) ^
      const DeepCollectionEquality().hash(isAdult) ^
      const DeepCollectionEquality().hash(ageRating) ^
      const DeepCollectionEquality().hash(duration) ^
      const DeepCollectionEquality().hash(image) ^
      const DeepCollectionEquality().hash(price) ^
      const DeepCollectionEquality().hash(priceDisplay) ^
      const DeepCollectionEquality().hash(minPrice) ^
      const DeepCollectionEquality().hash(minPriceDisplay) ^
      const DeepCollectionEquality().hash(seriesId) ^
      const DeepCollectionEquality().hash(seriesTitle) ^
      const DeepCollectionEquality().hash(seasonId) ^
      const DeepCollectionEquality().hash(season) ^
      const DeepCollectionEquality().hash(episode) ^
      const DeepCollectionEquality().hash(gridLink) ^
      const DeepCollectionEquality().hash(userInteractedWithSeries) ^
      const DeepCollectionEquality().hash(bookmark) ^
      const DeepCollectionEquality().hash(tvodEntitlementEnd) ^
      const DeepCollectionEquality().hash(broadcastDate) ^
      const DeepCollectionEquality().hash(channelName) ^
      const DeepCollectionEquality().hash(screenLayout) ^
      const DeepCollectionEquality().hash(totalEpisodes) ^
      const DeepCollectionEquality().hash(parentalGuidanceText) ^
      const DeepCollectionEquality().hash(onWatchlist) ^
      const DeepCollectionEquality().hash(genres) ^
      const DeepCollectionEquality().hash(synopsis) ^
      const DeepCollectionEquality().hash(longSynopsis) ^
      const DeepCollectionEquality().hash(audioLanguages) ^
      const DeepCollectionEquality().hash(signLanguages) ^
      const DeepCollectionEquality().hash(country) ^
      const DeepCollectionEquality().hash(subtitles) ^
      const DeepCollectionEquality().hash(supplementalAudioDescriptions) ^
      const DeepCollectionEquality().hash(icons) ^
      const DeepCollectionEquality().hash(trailers) ^
      const DeepCollectionEquality().hash(trailerInfo) ^
      const DeepCollectionEquality().hash(castAndCrew) ^
      const DeepCollectionEquality().hash(castCollection) ^
      const DeepCollectionEquality().hash(crewCollection) ^
      const DeepCollectionEquality().hash(instances) ^
      const DeepCollectionEquality().hash(prodYear) ^
      const DeepCollectionEquality().hash(seasonCount) ^
      const DeepCollectionEquality().hash(promoVideoUrl) ^
      const DeepCollectionEquality().hash(promoVideoEndImage) ^
      const DeepCollectionEquality().hash(promoVideoEndText) ^
      const DeepCollectionEquality().hash(minResolution) ^
      const DeepCollectionEquality().hash(isBoxset) ^
      const DeepCollectionEquality().hash(goPlayable) ^
      const DeepCollectionEquality().hash(brandingProviderId) ^
      const DeepCollectionEquality().hash(sources) ^
      runtimeType.hashCode;
}

extension $DetailScreenExtension on DetailScreen {
  DetailScreen copyWith(
      {String? id,
      String? mergedId,
      String? imageVersion,
      enums.DetailScreenType? type,
      enums.DetailScreenAssetType? assetType,
      String? title,
      String? subTitle,
      int? ordinal,
      bool? isPreview,
      String? parentTitleId,
      bool? isAdult,
      String? ageRating,
      int? duration,
      String? image,
      String? price,
      String? priceDisplay,
      String? minPrice,
      String? minPriceDisplay,
      String? seriesId,
      String? seriesTitle,
      String? seasonId,
      String? season,
      String? episode,
      GridLink? gridLink,
      bool? userInteractedWithSeries,
      int? bookmark,
      DateTime? tvodEntitlementEnd,
      DateTime? broadcastDate,
      String? channelName,
      String? screenLayout,
      int? totalEpisodes,
      String? parentalGuidanceText,
      bool? onWatchlist,
      List<String>? genres,
      String? synopsis,
      String? longSynopsis,
      List<String>? audioLanguages,
      List<String>? signLanguages,
      List<String>? country,
      List<String>? subtitles,
      List<String>? supplementalAudioDescriptions,
      List<String>? icons,
      List<String>? trailers,
      List<TrailerInfo>? trailerInfo,
      List<CastAndCrew>? castAndCrew,
      List<CastAndCrew>? castCollection,
      List<CastAndCrew>? crewCollection,
      List<Instance>? instances,
      String? prodYear,
      int? seasonCount,
      String? promoVideoUrl,
      String? promoVideoEndImage,
      String? promoVideoEndText,
      enums.DetailScreenMinResolution? minResolution,
      bool? isBoxset,
      bool? goPlayable,
      String? brandingProviderId,
      List<SourceExt>? sources}) {
    return DetailScreen(
        id: id ?? this.id,
        mergedId: mergedId ?? this.mergedId,
        imageVersion: imageVersion ?? this.imageVersion,
        type: type ?? this.type,
        assetType: assetType ?? this.assetType,
        title: title ?? this.title,
        subTitle: subTitle ?? this.subTitle,
        ordinal: ordinal ?? this.ordinal,
        isPreview: isPreview ?? this.isPreview,
        parentTitleId: parentTitleId ?? this.parentTitleId,
        isAdult: isAdult ?? this.isAdult,
        ageRating: ageRating ?? this.ageRating,
        duration: duration ?? this.duration,
        image: image ?? this.image,
        price: price ?? this.price,
        priceDisplay: priceDisplay ?? this.priceDisplay,
        minPrice: minPrice ?? this.minPrice,
        minPriceDisplay: minPriceDisplay ?? this.minPriceDisplay,
        seriesId: seriesId ?? this.seriesId,
        seriesTitle: seriesTitle ?? this.seriesTitle,
        seasonId: seasonId ?? this.seasonId,
        season: season ?? this.season,
        episode: episode ?? this.episode,
        gridLink: gridLink ?? this.gridLink,
        userInteractedWithSeries:
            userInteractedWithSeries ?? this.userInteractedWithSeries,
        bookmark: bookmark ?? this.bookmark,
        tvodEntitlementEnd: tvodEntitlementEnd ?? this.tvodEntitlementEnd,
        broadcastDate: broadcastDate ?? this.broadcastDate,
        channelName: channelName ?? this.channelName,
        screenLayout: screenLayout ?? this.screenLayout,
        totalEpisodes: totalEpisodes ?? this.totalEpisodes,
        parentalGuidanceText: parentalGuidanceText ?? this.parentalGuidanceText,
        onWatchlist: onWatchlist ?? this.onWatchlist,
        genres: genres ?? this.genres,
        synopsis: synopsis ?? this.synopsis,
        longSynopsis: longSynopsis ?? this.longSynopsis,
        audioLanguages: audioLanguages ?? this.audioLanguages,
        signLanguages: signLanguages ?? this.signLanguages,
        country: country ?? this.country,
        subtitles: subtitles ?? this.subtitles,
        supplementalAudioDescriptions:
            supplementalAudioDescriptions ?? this.supplementalAudioDescriptions,
        icons: icons ?? this.icons,
        trailers: trailers ?? this.trailers,
        trailerInfo: trailerInfo ?? this.trailerInfo,
        castAndCrew: castAndCrew ?? this.castAndCrew,
        castCollection: castCollection ?? this.castCollection,
        crewCollection: crewCollection ?? this.crewCollection,
        instances: instances ?? this.instances,
        prodYear: prodYear ?? this.prodYear,
        seasonCount: seasonCount ?? this.seasonCount,
        promoVideoUrl: promoVideoUrl ?? this.promoVideoUrl,
        promoVideoEndImage: promoVideoEndImage ?? this.promoVideoEndImage,
        promoVideoEndText: promoVideoEndText ?? this.promoVideoEndText,
        minResolution: minResolution ?? this.minResolution,
        isBoxset: isBoxset ?? this.isBoxset,
        goPlayable: goPlayable ?? this.goPlayable,
        brandingProviderId: brandingProviderId ?? this.brandingProviderId,
        sources: sources ?? this.sources);
  }

  DetailScreen copyWithWrapped(
      {Wrapped<String?>? id,
      Wrapped<String?>? mergedId,
      Wrapped<String?>? imageVersion,
      Wrapped<enums.DetailScreenType?>? type,
      Wrapped<enums.DetailScreenAssetType?>? assetType,
      Wrapped<String?>? title,
      Wrapped<String?>? subTitle,
      Wrapped<int?>? ordinal,
      Wrapped<bool?>? isPreview,
      Wrapped<String?>? parentTitleId,
      Wrapped<bool?>? isAdult,
      Wrapped<String?>? ageRating,
      Wrapped<int?>? duration,
      Wrapped<String?>? image,
      Wrapped<String?>? price,
      Wrapped<String?>? priceDisplay,
      Wrapped<String?>? minPrice,
      Wrapped<String?>? minPriceDisplay,
      Wrapped<String?>? seriesId,
      Wrapped<String?>? seriesTitle,
      Wrapped<String?>? seasonId,
      Wrapped<String?>? season,
      Wrapped<String?>? episode,
      Wrapped<GridLink?>? gridLink,
      Wrapped<bool?>? userInteractedWithSeries,
      Wrapped<int?>? bookmark,
      Wrapped<DateTime?>? tvodEntitlementEnd,
      Wrapped<DateTime?>? broadcastDate,
      Wrapped<String?>? channelName,
      Wrapped<String?>? screenLayout,
      Wrapped<int?>? totalEpisodes,
      Wrapped<String?>? parentalGuidanceText,
      Wrapped<bool?>? onWatchlist,
      Wrapped<List<String>?>? genres,
      Wrapped<String?>? synopsis,
      Wrapped<String?>? longSynopsis,
      Wrapped<List<String>?>? audioLanguages,
      Wrapped<List<String>?>? signLanguages,
      Wrapped<List<String>?>? country,
      Wrapped<List<String>?>? subtitles,
      Wrapped<List<String>?>? supplementalAudioDescriptions,
      Wrapped<List<String>?>? icons,
      Wrapped<List<String>?>? trailers,
      Wrapped<List<TrailerInfo>?>? trailerInfo,
      Wrapped<List<CastAndCrew>?>? castAndCrew,
      Wrapped<List<CastAndCrew>?>? castCollection,
      Wrapped<List<CastAndCrew>?>? crewCollection,
      Wrapped<List<Instance>?>? instances,
      Wrapped<String?>? prodYear,
      Wrapped<int?>? seasonCount,
      Wrapped<String?>? promoVideoUrl,
      Wrapped<String?>? promoVideoEndImage,
      Wrapped<String?>? promoVideoEndText,
      Wrapped<enums.DetailScreenMinResolution?>? minResolution,
      Wrapped<bool?>? isBoxset,
      Wrapped<bool?>? goPlayable,
      Wrapped<String?>? brandingProviderId,
      Wrapped<List<SourceExt>?>? sources}) {
    return DetailScreen(
        id: (id != null ? id.value : this.id),
        mergedId: (mergedId != null ? mergedId.value : this.mergedId),
        imageVersion:
            (imageVersion != null ? imageVersion.value : this.imageVersion),
        type: (type != null ? type.value : this.type),
        assetType: (assetType != null ? assetType.value : this.assetType),
        title: (title != null ? title.value : this.title),
        subTitle: (subTitle != null ? subTitle.value : this.subTitle),
        ordinal: (ordinal != null ? ordinal.value : this.ordinal),
        isPreview: (isPreview != null ? isPreview.value : this.isPreview),
        parentTitleId:
            (parentTitleId != null ? parentTitleId.value : this.parentTitleId),
        isAdult: (isAdult != null ? isAdult.value : this.isAdult),
        ageRating: (ageRating != null ? ageRating.value : this.ageRating),
        duration: (duration != null ? duration.value : this.duration),
        image: (image != null ? image.value : this.image),
        price: (price != null ? price.value : this.price),
        priceDisplay:
            (priceDisplay != null ? priceDisplay.value : this.priceDisplay),
        minPrice: (minPrice != null ? minPrice.value : this.minPrice),
        minPriceDisplay: (minPriceDisplay != null
            ? minPriceDisplay.value
            : this.minPriceDisplay),
        seriesId: (seriesId != null ? seriesId.value : this.seriesId),
        seriesTitle:
            (seriesTitle != null ? seriesTitle.value : this.seriesTitle),
        seasonId: (seasonId != null ? seasonId.value : this.seasonId),
        season: (season != null ? season.value : this.season),
        episode: (episode != null ? episode.value : this.episode),
        gridLink: (gridLink != null ? gridLink.value : this.gridLink),
        userInteractedWithSeries: (userInteractedWithSeries != null
            ? userInteractedWithSeries.value
            : this.userInteractedWithSeries),
        bookmark: (bookmark != null ? bookmark.value : this.bookmark),
        tvodEntitlementEnd: (tvodEntitlementEnd != null
            ? tvodEntitlementEnd.value
            : this.tvodEntitlementEnd),
        broadcastDate:
            (broadcastDate != null ? broadcastDate.value : this.broadcastDate),
        channelName:
            (channelName != null ? channelName.value : this.channelName),
        screenLayout:
            (screenLayout != null ? screenLayout.value : this.screenLayout),
        totalEpisodes:
            (totalEpisodes != null ? totalEpisodes.value : this.totalEpisodes),
        parentalGuidanceText: (parentalGuidanceText != null
            ? parentalGuidanceText.value
            : this.parentalGuidanceText),
        onWatchlist:
            (onWatchlist != null ? onWatchlist.value : this.onWatchlist),
        genres: (genres != null ? genres.value : this.genres),
        synopsis: (synopsis != null ? synopsis.value : this.synopsis),
        longSynopsis:
            (longSynopsis != null ? longSynopsis.value : this.longSynopsis),
        audioLanguages: (audioLanguages != null
            ? audioLanguages.value
            : this.audioLanguages),
        signLanguages:
            (signLanguages != null ? signLanguages.value : this.signLanguages),
        country: (country != null ? country.value : this.country),
        subtitles: (subtitles != null ? subtitles.value : this.subtitles),
        supplementalAudioDescriptions: (supplementalAudioDescriptions != null
            ? supplementalAudioDescriptions.value
            : this.supplementalAudioDescriptions),
        icons: (icons != null ? icons.value : this.icons),
        trailers: (trailers != null ? trailers.value : this.trailers),
        trailerInfo:
            (trailerInfo != null ? trailerInfo.value : this.trailerInfo),
        castAndCrew:
            (castAndCrew != null ? castAndCrew.value : this.castAndCrew),
        castCollection: (castCollection != null
            ? castCollection.value
            : this.castCollection),
        crewCollection: (crewCollection != null
            ? crewCollection.value
            : this.crewCollection),
        instances: (instances != null ? instances.value : this.instances),
        prodYear: (prodYear != null ? prodYear.value : this.prodYear),
        seasonCount:
            (seasonCount != null ? seasonCount.value : this.seasonCount),
        promoVideoUrl:
            (promoVideoUrl != null ? promoVideoUrl.value : this.promoVideoUrl),
        promoVideoEndImage: (promoVideoEndImage != null
            ? promoVideoEndImage.value
            : this.promoVideoEndImage),
        promoVideoEndText: (promoVideoEndText != null
            ? promoVideoEndText.value
            : this.promoVideoEndText),
        minResolution:
            (minResolution != null ? minResolution.value : this.minResolution),
        isBoxset: (isBoxset != null ? isBoxset.value : this.isBoxset),
        goPlayable: (goPlayable != null ? goPlayable.value : this.goPlayable),
        brandingProviderId: (brandingProviderId != null
            ? brandingProviderId.value
            : this.brandingProviderId),
        sources: (sources != null ? sources.value : this.sources));
  }
}

@JsonSerializable(explicitToJson: true)
class EstInstanceData {
  EstInstanceData({
    this.minPriceDisplay,
    this.currency,
    this.videoHost,
    this.videoUrl,
  });

  factory EstInstanceData.fromJson(Map<String, dynamic> json) =>
      _$EstInstanceDataFromJson(json);

  @JsonKey(name: 'minPriceDisplay', includeIfNull: false, defaultValue: '')
  final String? minPriceDisplay;
  @JsonKey(name: 'currency', includeIfNull: false, defaultValue: '')
  final String? currency;
  @JsonKey(name: 'videoHost', includeIfNull: false, defaultValue: '')
  final String? videoHost;
  @JsonKey(name: 'videoUrl', includeIfNull: false, defaultValue: '')
  final String? videoUrl;
  static const fromJsonFactory = _$EstInstanceDataFromJson;
  static const toJsonFactory = _$EstInstanceDataToJson;
  Map<String, dynamic> toJson() => _$EstInstanceDataToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EstInstanceData &&
            (identical(other.minPriceDisplay, minPriceDisplay) ||
                const DeepCollectionEquality()
                    .equals(other.minPriceDisplay, minPriceDisplay)) &&
            (identical(other.currency, currency) ||
                const DeepCollectionEquality()
                    .equals(other.currency, currency)) &&
            (identical(other.videoHost, videoHost) ||
                const DeepCollectionEquality()
                    .equals(other.videoHost, videoHost)) &&
            (identical(other.videoUrl, videoUrl) ||
                const DeepCollectionEquality()
                    .equals(other.videoUrl, videoUrl)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(minPriceDisplay) ^
      const DeepCollectionEquality().hash(currency) ^
      const DeepCollectionEquality().hash(videoHost) ^
      const DeepCollectionEquality().hash(videoUrl) ^
      runtimeType.hashCode;
}

extension $EstInstanceDataExtension on EstInstanceData {
  EstInstanceData copyWith(
      {String? minPriceDisplay,
      String? currency,
      String? videoHost,
      String? videoUrl}) {
    return EstInstanceData(
        minPriceDisplay: minPriceDisplay ?? this.minPriceDisplay,
        currency: currency ?? this.currency,
        videoHost: videoHost ?? this.videoHost,
        videoUrl: videoUrl ?? this.videoUrl);
  }

  EstInstanceData copyWithWrapped(
      {Wrapped<String?>? minPriceDisplay,
      Wrapped<String?>? currency,
      Wrapped<String?>? videoHost,
      Wrapped<String?>? videoUrl}) {
    return EstInstanceData(
        minPriceDisplay: (minPriceDisplay != null
            ? minPriceDisplay.value
            : this.minPriceDisplay),
        currency: (currency != null ? currency.value : this.currency),
        videoHost: (videoHost != null ? videoHost.value : this.videoHost),
        videoUrl: (videoUrl != null ? videoUrl.value : this.videoUrl));
  }
}

@JsonSerializable(explicitToJson: true)
class TrailerInstance {
  TrailerInstance({
    this.id,
    this.resolution,
    this.goPlayable,
    this.brandingProviderId,
  });

  factory TrailerInstance.fromJson(Map<String, dynamic> json) =>
      _$TrailerInstanceFromJson(json);

  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String? id;
  @JsonKey(name: 'resolution', includeIfNull: false, defaultValue: '')
  final String? resolution;
  @JsonKey(name: 'goPlayable', includeIfNull: false)
  final bool? goPlayable;
  @JsonKey(name: 'brandingProviderId', includeIfNull: false, defaultValue: '')
  final String? brandingProviderId;
  static const fromJsonFactory = _$TrailerInstanceFromJson;
  static const toJsonFactory = _$TrailerInstanceToJson;
  Map<String, dynamic> toJson() => _$TrailerInstanceToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TrailerInstance &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.resolution, resolution) ||
                const DeepCollectionEquality()
                    .equals(other.resolution, resolution)) &&
            (identical(other.goPlayable, goPlayable) ||
                const DeepCollectionEquality()
                    .equals(other.goPlayable, goPlayable)) &&
            (identical(other.brandingProviderId, brandingProviderId) ||
                const DeepCollectionEquality()
                    .equals(other.brandingProviderId, brandingProviderId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(resolution) ^
      const DeepCollectionEquality().hash(goPlayable) ^
      const DeepCollectionEquality().hash(brandingProviderId) ^
      runtimeType.hashCode;
}

extension $TrailerInstanceExtension on TrailerInstance {
  TrailerInstance copyWith(
      {String? id,
      String? resolution,
      bool? goPlayable,
      String? brandingProviderId}) {
    return TrailerInstance(
        id: id ?? this.id,
        resolution: resolution ?? this.resolution,
        goPlayable: goPlayable ?? this.goPlayable,
        brandingProviderId: brandingProviderId ?? this.brandingProviderId);
  }

  TrailerInstance copyWithWrapped(
      {Wrapped<String?>? id,
      Wrapped<String?>? resolution,
      Wrapped<bool?>? goPlayable,
      Wrapped<String?>? brandingProviderId}) {
    return TrailerInstance(
        id: (id != null ? id.value : this.id),
        resolution: (resolution != null ? resolution.value : this.resolution),
        goPlayable: (goPlayable != null ? goPlayable.value : this.goPlayable),
        brandingProviderId: (brandingProviderId != null
            ? brandingProviderId.value
            : this.brandingProviderId));
  }
}

@JsonSerializable(explicitToJson: true)
class Instance {
  Instance({
    this.id,
    this.resolution,
    this.isDolby,
    this.audioLang,
    this.subtitles,
    this.supplementalAudioDescriptions,
    this.signLanguages,
    this.availabilityStart,
    this.availabilityEnd,
    this.startIntroTime,
    this.endIntroTime,
    this.est,
    this.broadcastDate,
    this.broadcaster,
    this.brandingProviderId,
    this.channelName,
    this.endCreditsTimestamp,
    this.goPlayable,
    this.goDownloadable,
    this.isAdEnabled,
    this.supportedExternalStreamingProtocols,
    this.offers,
    this.download,
  });

  factory Instance.fromJson(Map<String, dynamic> json) =>
      _$InstanceFromJson(json);

  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String? id;
  @JsonKey(name: 'resolution', includeIfNull: false, defaultValue: '')
  final String? resolution;
  @JsonKey(name: 'isDolby', includeIfNull: false)
  final bool? isDolby;
  @JsonKey(name: 'audioLang', includeIfNull: false, defaultValue: '')
  final String? audioLang;
  @JsonKey(name: 'subtitles', includeIfNull: false, defaultValue: '')
  final String? subtitles;
  @JsonKey(
      name: 'supplementalAudioDescriptions',
      includeIfNull: false,
      defaultValue: <String>[])
  final List<String>? supplementalAudioDescriptions;
  @JsonKey(
      name: 'signLanguages', includeIfNull: false, defaultValue: <String>[])
  final List<String>? signLanguages;
  @JsonKey(name: 'availabilityStart', includeIfNull: false)
  final DateTime? availabilityStart;
  @JsonKey(name: 'availabilityEnd', includeIfNull: false)
  final DateTime? availabilityEnd;
  @JsonKey(name: 'startIntroTime', includeIfNull: false)
  final int? startIntroTime;
  @JsonKey(name: 'endIntroTime', includeIfNull: false)
  final int? endIntroTime;
  @JsonKey(name: 'est', includeIfNull: false)
  final EstInstanceData? est;
  @JsonKey(name: 'broadcastDate', includeIfNull: false)
  final DateTime? broadcastDate;
  @JsonKey(name: 'broadcaster', includeIfNull: false, defaultValue: '')
  final String? broadcaster;
  @JsonKey(name: 'brandingProviderId', includeIfNull: false, defaultValue: '')
  final String? brandingProviderId;
  @JsonKey(name: 'channelName', includeIfNull: false, defaultValue: '')
  final String? channelName;
  @JsonKey(name: 'endCreditsTimestamp', includeIfNull: false)
  final int? endCreditsTimestamp;
  @JsonKey(name: 'goPlayable', includeIfNull: false)
  final bool? goPlayable;
  @JsonKey(name: 'goDownloadable', includeIfNull: false)
  final bool? goDownloadable;
  @JsonKey(name: 'isAdEnabled', includeIfNull: false)
  final bool? isAdEnabled;
  @JsonKey(
      name: 'supportedExternalStreamingProtocols',
      includeIfNull: false,
      defaultValue: <String>[])
  final List<String>? supportedExternalStreamingProtocols;
  @JsonKey(name: 'offers', includeIfNull: false, defaultValue: <Offer>[])
  final List<Offer>? offers;
  @JsonKey(name: 'download', includeIfNull: false)
  final Download? download;
  static const fromJsonFactory = _$InstanceFromJson;
  static const toJsonFactory = _$InstanceToJson;
  Map<String, dynamic> toJson() => _$InstanceToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Instance &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.resolution, resolution) ||
                const DeepCollectionEquality()
                    .equals(other.resolution, resolution)) &&
            (identical(other.isDolby, isDolby) ||
                const DeepCollectionEquality()
                    .equals(other.isDolby, isDolby)) &&
            (identical(other.audioLang, audioLang) ||
                const DeepCollectionEquality()
                    .equals(other.audioLang, audioLang)) &&
            (identical(other.subtitles, subtitles) ||
                const DeepCollectionEquality()
                    .equals(other.subtitles, subtitles)) &&
            (identical(other.supplementalAudioDescriptions, supplementalAudioDescriptions) ||
                const DeepCollectionEquality().equals(
                    other.supplementalAudioDescriptions,
                    supplementalAudioDescriptions)) &&
            (identical(other.signLanguages, signLanguages) ||
                const DeepCollectionEquality()
                    .equals(other.signLanguages, signLanguages)) &&
            (identical(other.availabilityStart, availabilityStart) ||
                const DeepCollectionEquality()
                    .equals(other.availabilityStart, availabilityStart)) &&
            (identical(other.availabilityEnd, availabilityEnd) ||
                const DeepCollectionEquality()
                    .equals(other.availabilityEnd, availabilityEnd)) &&
            (identical(other.startIntroTime, startIntroTime) ||
                const DeepCollectionEquality()
                    .equals(other.startIntroTime, startIntroTime)) &&
            (identical(other.endIntroTime, endIntroTime) ||
                const DeepCollectionEquality()
                    .equals(other.endIntroTime, endIntroTime)) &&
            (identical(other.est, est) ||
                const DeepCollectionEquality().equals(other.est, est)) &&
            (identical(other.broadcastDate, broadcastDate) ||
                const DeepCollectionEquality()
                    .equals(other.broadcastDate, broadcastDate)) &&
            (identical(other.broadcaster, broadcaster) ||
                const DeepCollectionEquality()
                    .equals(other.broadcaster, broadcaster)) &&
            (identical(other.brandingProviderId, brandingProviderId) ||
                const DeepCollectionEquality()
                    .equals(other.brandingProviderId, brandingProviderId)) &&
            (identical(other.channelName, channelName) ||
                const DeepCollectionEquality()
                    .equals(other.channelName, channelName)) &&
            (identical(other.endCreditsTimestamp, endCreditsTimestamp) ||
                const DeepCollectionEquality()
                    .equals(other.endCreditsTimestamp, endCreditsTimestamp)) &&
            (identical(other.goPlayable, goPlayable) ||
                const DeepCollectionEquality()
                    .equals(other.goPlayable, goPlayable)) &&
            (identical(other.goDownloadable, goDownloadable) || const DeepCollectionEquality().equals(other.goDownloadable, goDownloadable)) &&
            (identical(other.isAdEnabled, isAdEnabled) || const DeepCollectionEquality().equals(other.isAdEnabled, isAdEnabled)) &&
            (identical(other.supportedExternalStreamingProtocols, supportedExternalStreamingProtocols) || const DeepCollectionEquality().equals(other.supportedExternalStreamingProtocols, supportedExternalStreamingProtocols)) &&
            (identical(other.offers, offers) || const DeepCollectionEquality().equals(other.offers, offers)) &&
            (identical(other.download, download) || const DeepCollectionEquality().equals(other.download, download)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(resolution) ^
      const DeepCollectionEquality().hash(isDolby) ^
      const DeepCollectionEquality().hash(audioLang) ^
      const DeepCollectionEquality().hash(subtitles) ^
      const DeepCollectionEquality().hash(supplementalAudioDescriptions) ^
      const DeepCollectionEquality().hash(signLanguages) ^
      const DeepCollectionEquality().hash(availabilityStart) ^
      const DeepCollectionEquality().hash(availabilityEnd) ^
      const DeepCollectionEquality().hash(startIntroTime) ^
      const DeepCollectionEquality().hash(endIntroTime) ^
      const DeepCollectionEquality().hash(est) ^
      const DeepCollectionEquality().hash(broadcastDate) ^
      const DeepCollectionEquality().hash(broadcaster) ^
      const DeepCollectionEquality().hash(brandingProviderId) ^
      const DeepCollectionEquality().hash(channelName) ^
      const DeepCollectionEquality().hash(endCreditsTimestamp) ^
      const DeepCollectionEquality().hash(goPlayable) ^
      const DeepCollectionEquality().hash(goDownloadable) ^
      const DeepCollectionEquality().hash(isAdEnabled) ^
      const DeepCollectionEquality().hash(supportedExternalStreamingProtocols) ^
      const DeepCollectionEquality().hash(offers) ^
      const DeepCollectionEquality().hash(download) ^
      runtimeType.hashCode;
}

extension $InstanceExtension on Instance {
  Instance copyWith(
      {String? id,
      String? resolution,
      bool? isDolby,
      String? audioLang,
      String? subtitles,
      List<String>? supplementalAudioDescriptions,
      List<String>? signLanguages,
      DateTime? availabilityStart,
      DateTime? availabilityEnd,
      int? startIntroTime,
      int? endIntroTime,
      EstInstanceData? est,
      DateTime? broadcastDate,
      String? broadcaster,
      String? brandingProviderId,
      String? channelName,
      int? endCreditsTimestamp,
      bool? goPlayable,
      bool? goDownloadable,
      bool? isAdEnabled,
      List<String>? supportedExternalStreamingProtocols,
      List<Offer>? offers,
      Download? download}) {
    return Instance(
        id: id ?? this.id,
        resolution: resolution ?? this.resolution,
        isDolby: isDolby ?? this.isDolby,
        audioLang: audioLang ?? this.audioLang,
        subtitles: subtitles ?? this.subtitles,
        supplementalAudioDescriptions:
            supplementalAudioDescriptions ?? this.supplementalAudioDescriptions,
        signLanguages: signLanguages ?? this.signLanguages,
        availabilityStart: availabilityStart ?? this.availabilityStart,
        availabilityEnd: availabilityEnd ?? this.availabilityEnd,
        startIntroTime: startIntroTime ?? this.startIntroTime,
        endIntroTime: endIntroTime ?? this.endIntroTime,
        est: est ?? this.est,
        broadcastDate: broadcastDate ?? this.broadcastDate,
        broadcaster: broadcaster ?? this.broadcaster,
        brandingProviderId: brandingProviderId ?? this.brandingProviderId,
        channelName: channelName ?? this.channelName,
        endCreditsTimestamp: endCreditsTimestamp ?? this.endCreditsTimestamp,
        goPlayable: goPlayable ?? this.goPlayable,
        goDownloadable: goDownloadable ?? this.goDownloadable,
        isAdEnabled: isAdEnabled ?? this.isAdEnabled,
        supportedExternalStreamingProtocols:
            supportedExternalStreamingProtocols ??
                this.supportedExternalStreamingProtocols,
        offers: offers ?? this.offers,
        download: download ?? this.download);
  }

  Instance copyWithWrapped(
      {Wrapped<String?>? id,
      Wrapped<String?>? resolution,
      Wrapped<bool?>? isDolby,
      Wrapped<String?>? audioLang,
      Wrapped<String?>? subtitles,
      Wrapped<List<String>?>? supplementalAudioDescriptions,
      Wrapped<List<String>?>? signLanguages,
      Wrapped<DateTime?>? availabilityStart,
      Wrapped<DateTime?>? availabilityEnd,
      Wrapped<int?>? startIntroTime,
      Wrapped<int?>? endIntroTime,
      Wrapped<EstInstanceData?>? est,
      Wrapped<DateTime?>? broadcastDate,
      Wrapped<String?>? broadcaster,
      Wrapped<String?>? brandingProviderId,
      Wrapped<String?>? channelName,
      Wrapped<int?>? endCreditsTimestamp,
      Wrapped<bool?>? goPlayable,
      Wrapped<bool?>? goDownloadable,
      Wrapped<bool?>? isAdEnabled,
      Wrapped<List<String>?>? supportedExternalStreamingProtocols,
      Wrapped<List<Offer>?>? offers,
      Wrapped<Download?>? download}) {
    return Instance(
        id: (id != null ? id.value : this.id),
        resolution: (resolution != null ? resolution.value : this.resolution),
        isDolby: (isDolby != null ? isDolby.value : this.isDolby),
        audioLang: (audioLang != null ? audioLang.value : this.audioLang),
        subtitles: (subtitles != null ? subtitles.value : this.subtitles),
        supplementalAudioDescriptions: (supplementalAudioDescriptions != null
            ? supplementalAudioDescriptions.value
            : this.supplementalAudioDescriptions),
        signLanguages:
            (signLanguages != null ? signLanguages.value : this.signLanguages),
        availabilityStart: (availabilityStart != null
            ? availabilityStart.value
            : this.availabilityStart),
        availabilityEnd: (availabilityEnd != null
            ? availabilityEnd.value
            : this.availabilityEnd),
        startIntroTime: (startIntroTime != null
            ? startIntroTime.value
            : this.startIntroTime),
        endIntroTime:
            (endIntroTime != null ? endIntroTime.value : this.endIntroTime),
        est: (est != null ? est.value : this.est),
        broadcastDate:
            (broadcastDate != null ? broadcastDate.value : this.broadcastDate),
        broadcaster:
            (broadcaster != null ? broadcaster.value : this.broadcaster),
        brandingProviderId: (brandingProviderId != null
            ? brandingProviderId.value
            : this.brandingProviderId),
        channelName:
            (channelName != null ? channelName.value : this.channelName),
        endCreditsTimestamp: (endCreditsTimestamp != null
            ? endCreditsTimestamp.value
            : this.endCreditsTimestamp),
        goPlayable: (goPlayable != null ? goPlayable.value : this.goPlayable),
        goDownloadable: (goDownloadable != null
            ? goDownloadable.value
            : this.goDownloadable),
        isAdEnabled:
            (isAdEnabled != null ? isAdEnabled.value : this.isAdEnabled),
        supportedExternalStreamingProtocols:
            (supportedExternalStreamingProtocols != null
                ? supportedExternalStreamingProtocols.value
                : this.supportedExternalStreamingProtocols),
        offers: (offers != null ? offers.value : this.offers),
        download: (download != null ? download.value : this.download));
  }
}

@JsonSerializable(explicitToJson: true)
class Download {
  Download({
    this.expirySecondsAfterDownload,
    this.expirySecondsAfterPlay,
    this.lastAvailabilty,
    this.maxDownloads,
  });

  factory Download.fromJson(Map<String, dynamic> json) =>
      _$DownloadFromJson(json);

  @JsonKey(name: 'expirySecondsAfterDownload', includeIfNull: false)
  final double? expirySecondsAfterDownload;
  @JsonKey(name: 'expirySecondsAfterPlay', includeIfNull: false)
  final double? expirySecondsAfterPlay;
  @JsonKey(name: 'lastAvailabilty', includeIfNull: false)
  final DateTime? lastAvailabilty;
  @JsonKey(name: 'maxDownloads', includeIfNull: false)
  final double? maxDownloads;
  static const fromJsonFactory = _$DownloadFromJson;
  static const toJsonFactory = _$DownloadToJson;
  Map<String, dynamic> toJson() => _$DownloadToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Download &&
            (identical(other.expirySecondsAfterDownload,
                    expirySecondsAfterDownload) ||
                const DeepCollectionEquality().equals(
                    other.expirySecondsAfterDownload,
                    expirySecondsAfterDownload)) &&
            (identical(other.expirySecondsAfterPlay, expirySecondsAfterPlay) ||
                const DeepCollectionEquality().equals(
                    other.expirySecondsAfterPlay, expirySecondsAfterPlay)) &&
            (identical(other.lastAvailabilty, lastAvailabilty) ||
                const DeepCollectionEquality()
                    .equals(other.lastAvailabilty, lastAvailabilty)) &&
            (identical(other.maxDownloads, maxDownloads) ||
                const DeepCollectionEquality()
                    .equals(other.maxDownloads, maxDownloads)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(expirySecondsAfterDownload) ^
      const DeepCollectionEquality().hash(expirySecondsAfterPlay) ^
      const DeepCollectionEquality().hash(lastAvailabilty) ^
      const DeepCollectionEquality().hash(maxDownloads) ^
      runtimeType.hashCode;
}

extension $DownloadExtension on Download {
  Download copyWith(
      {double? expirySecondsAfterDownload,
      double? expirySecondsAfterPlay,
      DateTime? lastAvailabilty,
      double? maxDownloads}) {
    return Download(
        expirySecondsAfterDownload:
            expirySecondsAfterDownload ?? this.expirySecondsAfterDownload,
        expirySecondsAfterPlay:
            expirySecondsAfterPlay ?? this.expirySecondsAfterPlay,
        lastAvailabilty: lastAvailabilty ?? this.lastAvailabilty,
        maxDownloads: maxDownloads ?? this.maxDownloads);
  }

  Download copyWithWrapped(
      {Wrapped<double?>? expirySecondsAfterDownload,
      Wrapped<double?>? expirySecondsAfterPlay,
      Wrapped<DateTime?>? lastAvailabilty,
      Wrapped<double?>? maxDownloads}) {
    return Download(
        expirySecondsAfterDownload: (expirySecondsAfterDownload != null
            ? expirySecondsAfterDownload.value
            : this.expirySecondsAfterDownload),
        expirySecondsAfterPlay: (expirySecondsAfterPlay != null
            ? expirySecondsAfterPlay.value
            : this.expirySecondsAfterPlay),
        lastAvailabilty: (lastAvailabilty != null
            ? lastAvailabilty.value
            : this.lastAvailabilty),
        maxDownloads:
            (maxDownloads != null ? maxDownloads.value : this.maxDownloads));
  }
}

@JsonSerializable(explicitToJson: true)
class Offer {
  Offer({
    this.id,
    this.entitled,
    this.offerId,
    this.name,
    this.type,
    this.titleCount,
    this.price,
    this.priceDisplay,
    this.currency,
    this.period,
    this.entitlementEnd,
    this.image,
    this.edsProductId,
    this.relationAvailabilityStart,
    this.relationAvailabilityEnd,
  });

  factory Offer.fromJson(Map<String, dynamic> json) => _$OfferFromJson(json);

  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String? id;
  @JsonKey(name: 'entitled', includeIfNull: false)
  final bool? entitled;
  @JsonKey(name: 'offerId', includeIfNull: false, defaultValue: '')
  final String? offerId;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String? name;
  @JsonKey(name: 'type', includeIfNull: false, defaultValue: '')
  final String? type;
  @JsonKey(name: 'titleCount', includeIfNull: false)
  final int? titleCount;
  @JsonKey(name: 'price', includeIfNull: false, defaultValue: '')
  final String? price;
  @JsonKey(name: 'priceDisplay', includeIfNull: false, defaultValue: '')
  final String? priceDisplay;
  @JsonKey(name: 'currency', includeIfNull: false, defaultValue: '')
  final String? currency;
  @JsonKey(name: 'period', includeIfNull: false)
  final int? period;
  @JsonKey(name: 'entitlementEnd', includeIfNull: false)
  final DateTime? entitlementEnd;
  @JsonKey(name: 'image', includeIfNull: false, defaultValue: '')
  final String? image;
  @JsonKey(name: 'edsProductId', includeIfNull: false, defaultValue: '')
  final String? edsProductId;
  @JsonKey(name: 'relationAvailabilityStart', includeIfNull: false)
  final DateTime? relationAvailabilityStart;
  @JsonKey(name: 'relationAvailabilityEnd', includeIfNull: false)
  final DateTime? relationAvailabilityEnd;
  static const fromJsonFactory = _$OfferFromJson;
  static const toJsonFactory = _$OfferToJson;
  Map<String, dynamic> toJson() => _$OfferToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Offer &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.entitled, entitled) ||
                const DeepCollectionEquality()
                    .equals(other.entitled, entitled)) &&
            (identical(other.offerId, offerId) ||
                const DeepCollectionEquality()
                    .equals(other.offerId, offerId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.titleCount, titleCount) ||
                const DeepCollectionEquality()
                    .equals(other.titleCount, titleCount)) &&
            (identical(other.price, price) ||
                const DeepCollectionEquality().equals(other.price, price)) &&
            (identical(other.priceDisplay, priceDisplay) ||
                const DeepCollectionEquality()
                    .equals(other.priceDisplay, priceDisplay)) &&
            (identical(other.currency, currency) ||
                const DeepCollectionEquality()
                    .equals(other.currency, currency)) &&
            (identical(other.period, period) ||
                const DeepCollectionEquality().equals(other.period, period)) &&
            (identical(other.entitlementEnd, entitlementEnd) ||
                const DeepCollectionEquality()
                    .equals(other.entitlementEnd, entitlementEnd)) &&
            (identical(other.image, image) ||
                const DeepCollectionEquality().equals(other.image, image)) &&
            (identical(other.edsProductId, edsProductId) ||
                const DeepCollectionEquality()
                    .equals(other.edsProductId, edsProductId)) &&
            (identical(other.relationAvailabilityStart,
                    relationAvailabilityStart) ||
                const DeepCollectionEquality().equals(
                    other.relationAvailabilityStart,
                    relationAvailabilityStart)) &&
            (identical(
                    other.relationAvailabilityEnd, relationAvailabilityEnd) ||
                const DeepCollectionEquality().equals(
                    other.relationAvailabilityEnd, relationAvailabilityEnd)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(entitled) ^
      const DeepCollectionEquality().hash(offerId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(titleCount) ^
      const DeepCollectionEquality().hash(price) ^
      const DeepCollectionEquality().hash(priceDisplay) ^
      const DeepCollectionEquality().hash(currency) ^
      const DeepCollectionEquality().hash(period) ^
      const DeepCollectionEquality().hash(entitlementEnd) ^
      const DeepCollectionEquality().hash(image) ^
      const DeepCollectionEquality().hash(edsProductId) ^
      const DeepCollectionEquality().hash(relationAvailabilityStart) ^
      const DeepCollectionEquality().hash(relationAvailabilityEnd) ^
      runtimeType.hashCode;
}

extension $OfferExtension on Offer {
  Offer copyWith(
      {String? id,
      bool? entitled,
      String? offerId,
      String? name,
      String? type,
      int? titleCount,
      String? price,
      String? priceDisplay,
      String? currency,
      int? period,
      DateTime? entitlementEnd,
      String? image,
      String? edsProductId,
      DateTime? relationAvailabilityStart,
      DateTime? relationAvailabilityEnd}) {
    return Offer(
        id: id ?? this.id,
        entitled: entitled ?? this.entitled,
        offerId: offerId ?? this.offerId,
        name: name ?? this.name,
        type: type ?? this.type,
        titleCount: titleCount ?? this.titleCount,
        price: price ?? this.price,
        priceDisplay: priceDisplay ?? this.priceDisplay,
        currency: currency ?? this.currency,
        period: period ?? this.period,
        entitlementEnd: entitlementEnd ?? this.entitlementEnd,
        image: image ?? this.image,
        edsProductId: edsProductId ?? this.edsProductId,
        relationAvailabilityStart:
            relationAvailabilityStart ?? this.relationAvailabilityStart,
        relationAvailabilityEnd:
            relationAvailabilityEnd ?? this.relationAvailabilityEnd);
  }

  Offer copyWithWrapped(
      {Wrapped<String?>? id,
      Wrapped<bool?>? entitled,
      Wrapped<String?>? offerId,
      Wrapped<String?>? name,
      Wrapped<String?>? type,
      Wrapped<int?>? titleCount,
      Wrapped<String?>? price,
      Wrapped<String?>? priceDisplay,
      Wrapped<String?>? currency,
      Wrapped<int?>? period,
      Wrapped<DateTime?>? entitlementEnd,
      Wrapped<String?>? image,
      Wrapped<String?>? edsProductId,
      Wrapped<DateTime?>? relationAvailabilityStart,
      Wrapped<DateTime?>? relationAvailabilityEnd}) {
    return Offer(
        id: (id != null ? id.value : this.id),
        entitled: (entitled != null ? entitled.value : this.entitled),
        offerId: (offerId != null ? offerId.value : this.offerId),
        name: (name != null ? name.value : this.name),
        type: (type != null ? type.value : this.type),
        titleCount: (titleCount != null ? titleCount.value : this.titleCount),
        price: (price != null ? price.value : this.price),
        priceDisplay:
            (priceDisplay != null ? priceDisplay.value : this.priceDisplay),
        currency: (currency != null ? currency.value : this.currency),
        period: (period != null ? period.value : this.period),
        entitlementEnd: (entitlementEnd != null
            ? entitlementEnd.value
            : this.entitlementEnd),
        image: (image != null ? image.value : this.image),
        edsProductId:
            (edsProductId != null ? edsProductId.value : this.edsProductId),
        relationAvailabilityStart: (relationAvailabilityStart != null
            ? relationAvailabilityStart.value
            : this.relationAvailabilityStart),
        relationAvailabilityEnd: (relationAvailabilityEnd != null
            ? relationAvailabilityEnd.value
            : this.relationAvailabilityEnd));
  }
}

@JsonSerializable(explicitToJson: true)
class OttSource {
  OttSource({
    this.id,
    this.titleId,
    this.minPriceDisplay,
    this.currency,
    this.videoHost,
    this.videoUrl,
    this.isEST,
    this.brandingProviderId,
    this.goPlayable,
    this.goDownloadable,
  });

  factory OttSource.fromJson(Map<String, dynamic> json) =>
      _$OttSourceFromJson(json);

  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String? id;
  @JsonKey(name: 'titleId', includeIfNull: false, defaultValue: '')
  final String? titleId;
  @JsonKey(name: 'minPriceDisplay', includeIfNull: false, defaultValue: '')
  final String? minPriceDisplay;
  @JsonKey(name: 'currency', includeIfNull: false, defaultValue: '')
  final String? currency;
  @JsonKey(name: 'videoHost', includeIfNull: false, defaultValue: '')
  final String? videoHost;
  @JsonKey(name: 'videoUrl', includeIfNull: false, defaultValue: '')
  final String? videoUrl;
  @JsonKey(name: 'isEST', includeIfNull: false)
  final bool? isEST;
  @JsonKey(name: 'brandingProviderId', includeIfNull: false, defaultValue: '')
  final String? brandingProviderId;
  @JsonKey(name: 'goPlayable', includeIfNull: false)
  final bool? goPlayable;
  @JsonKey(name: 'goDownloadable', includeIfNull: false)
  final bool? goDownloadable;
  static const fromJsonFactory = _$OttSourceFromJson;
  static const toJsonFactory = _$OttSourceToJson;
  Map<String, dynamic> toJson() => _$OttSourceToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is OttSource &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.titleId, titleId) ||
                const DeepCollectionEquality()
                    .equals(other.titleId, titleId)) &&
            (identical(other.minPriceDisplay, minPriceDisplay) ||
                const DeepCollectionEquality()
                    .equals(other.minPriceDisplay, minPriceDisplay)) &&
            (identical(other.currency, currency) ||
                const DeepCollectionEquality()
                    .equals(other.currency, currency)) &&
            (identical(other.videoHost, videoHost) ||
                const DeepCollectionEquality()
                    .equals(other.videoHost, videoHost)) &&
            (identical(other.videoUrl, videoUrl) ||
                const DeepCollectionEquality()
                    .equals(other.videoUrl, videoUrl)) &&
            (identical(other.isEST, isEST) ||
                const DeepCollectionEquality().equals(other.isEST, isEST)) &&
            (identical(other.brandingProviderId, brandingProviderId) ||
                const DeepCollectionEquality()
                    .equals(other.brandingProviderId, brandingProviderId)) &&
            (identical(other.goPlayable, goPlayable) ||
                const DeepCollectionEquality()
                    .equals(other.goPlayable, goPlayable)) &&
            (identical(other.goDownloadable, goDownloadable) ||
                const DeepCollectionEquality()
                    .equals(other.goDownloadable, goDownloadable)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(titleId) ^
      const DeepCollectionEquality().hash(minPriceDisplay) ^
      const DeepCollectionEquality().hash(currency) ^
      const DeepCollectionEquality().hash(videoHost) ^
      const DeepCollectionEquality().hash(videoUrl) ^
      const DeepCollectionEquality().hash(isEST) ^
      const DeepCollectionEquality().hash(brandingProviderId) ^
      const DeepCollectionEquality().hash(goPlayable) ^
      const DeepCollectionEquality().hash(goDownloadable) ^
      runtimeType.hashCode;
}

extension $OttSourceExtension on OttSource {
  OttSource copyWith(
      {String? id,
      String? titleId,
      String? minPriceDisplay,
      String? currency,
      String? videoHost,
      String? videoUrl,
      bool? isEST,
      String? brandingProviderId,
      bool? goPlayable,
      bool? goDownloadable}) {
    return OttSource(
        id: id ?? this.id,
        titleId: titleId ?? this.titleId,
        minPriceDisplay: minPriceDisplay ?? this.minPriceDisplay,
        currency: currency ?? this.currency,
        videoHost: videoHost ?? this.videoHost,
        videoUrl: videoUrl ?? this.videoUrl,
        isEST: isEST ?? this.isEST,
        brandingProviderId: brandingProviderId ?? this.brandingProviderId,
        goPlayable: goPlayable ?? this.goPlayable,
        goDownloadable: goDownloadable ?? this.goDownloadable);
  }

  OttSource copyWithWrapped(
      {Wrapped<String?>? id,
      Wrapped<String?>? titleId,
      Wrapped<String?>? minPriceDisplay,
      Wrapped<String?>? currency,
      Wrapped<String?>? videoHost,
      Wrapped<String?>? videoUrl,
      Wrapped<bool?>? isEST,
      Wrapped<String?>? brandingProviderId,
      Wrapped<bool?>? goPlayable,
      Wrapped<bool?>? goDownloadable}) {
    return OttSource(
        id: (id != null ? id.value : this.id),
        titleId: (titleId != null ? titleId.value : this.titleId),
        minPriceDisplay: (minPriceDisplay != null
            ? minPriceDisplay.value
            : this.minPriceDisplay),
        currency: (currency != null ? currency.value : this.currency),
        videoHost: (videoHost != null ? videoHost.value : this.videoHost),
        videoUrl: (videoUrl != null ? videoUrl.value : this.videoUrl),
        isEST: (isEST != null ? isEST.value : this.isEST),
        brandingProviderId: (brandingProviderId != null
            ? brandingProviderId.value
            : this.brandingProviderId),
        goPlayable: (goPlayable != null ? goPlayable.value : this.goPlayable),
        goDownloadable: (goDownloadable != null
            ? goDownloadable.value
            : this.goDownloadable));
  }
}

@JsonSerializable(explicitToJson: true)
class SourceExt {
  SourceExt({
    this.sourceType,
    this.source,
  });

  factory SourceExt.fromJson(Map<String, dynamic> json) =>
      _$SourceExtFromJson(json);

  @JsonKey(
    name: 'sourceType',
    includeIfNull: false,
    toJson: sourceExtSourceTypeToJson,
    fromJson: sourceExtSourceTypeFromJson,
  )
  final enums.SourceExtSourceType? sourceType;
  @JsonKey(name: 'source', includeIfNull: false)
  final OttSource? source;
  static const fromJsonFactory = _$SourceExtFromJson;
  static const toJsonFactory = _$SourceExtToJson;
  Map<String, dynamic> toJson() => _$SourceExtToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SourceExt &&
            (identical(other.sourceType, sourceType) ||
                const DeepCollectionEquality()
                    .equals(other.sourceType, sourceType)) &&
            (identical(other.source, source) ||
                const DeepCollectionEquality().equals(other.source, source)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(sourceType) ^
      const DeepCollectionEquality().hash(source) ^
      runtimeType.hashCode;
}

extension $SourceExtExtension on SourceExt {
  SourceExt copyWith(
      {enums.SourceExtSourceType? sourceType, OttSource? source}) {
    return SourceExt(
        sourceType: sourceType ?? this.sourceType,
        source: source ?? this.source);
  }

  SourceExt copyWithWrapped(
      {Wrapped<enums.SourceExtSourceType?>? sourceType,
      Wrapped<OttSource?>? source}) {
    return SourceExt(
        sourceType: (sourceType != null ? sourceType.value : this.sourceType),
        source: (source != null ? source.value : this.source));
  }
}

@JsonSerializable(explicitToJson: true)
class SourceOtt {
  SourceOtt({
    this.source,
    this.sourceType,
  });

  factory SourceOtt.fromJson(Map<String, dynamic> json) =>
      _$SourceOttFromJson(json);

  @JsonKey(name: 'source', includeIfNull: false)
  final OttSource? source;
  @JsonKey(
    name: 'sourceType',
    includeIfNull: false,
    toJson: sourceOttSourceTypeToJson,
    fromJson: sourceOttSourceTypeFromJson,
  )
  final enums.SourceOttSourceType? sourceType;
  static const fromJsonFactory = _$SourceOttFromJson;
  static const toJsonFactory = _$SourceOttToJson;
  Map<String, dynamic> toJson() => _$SourceOttToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SourceOtt &&
            (identical(other.source, source) ||
                const DeepCollectionEquality().equals(other.source, source)) &&
            (identical(other.sourceType, sourceType) ||
                const DeepCollectionEquality()
                    .equals(other.sourceType, sourceType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(source) ^
      const DeepCollectionEquality().hash(sourceType) ^
      runtimeType.hashCode;
}

extension $SourceOttExtension on SourceOtt {
  SourceOtt copyWith(
      {OttSource? source, enums.SourceOttSourceType? sourceType}) {
    return SourceOtt(
        source: source ?? this.source,
        sourceType: sourceType ?? this.sourceType);
  }

  SourceOtt copyWithWrapped(
      {Wrapped<OttSource?>? source,
      Wrapped<enums.SourceOttSourceType?>? sourceType}) {
    return SourceOtt(
        source: (source != null ? source.value : this.source),
        sourceType: (sourceType != null ? sourceType.value : this.sourceType));
  }
}

@JsonSerializable(explicitToJson: true)
class GridFilterOption {
  GridFilterOption({
    this.name,
    this.crid,
    this.titlesCount,
    this.seriesCount,
    this.isAdult,
  });

  factory GridFilterOption.fromJson(Map<String, dynamic> json) =>
      _$GridFilterOptionFromJson(json);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String? name;
  @JsonKey(name: 'crid', includeIfNull: false, defaultValue: '')
  final String? crid;
  @JsonKey(name: 'titlesCount', includeIfNull: false)
  final int? titlesCount;
  @JsonKey(name: 'seriesCount', includeIfNull: false)
  final int? seriesCount;
  @JsonKey(name: 'isAdult', includeIfNull: false)
  final bool? isAdult;
  static const fromJsonFactory = _$GridFilterOptionFromJson;
  static const toJsonFactory = _$GridFilterOptionToJson;
  Map<String, dynamic> toJson() => _$GridFilterOptionToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is GridFilterOption &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.crid, crid) ||
                const DeepCollectionEquality().equals(other.crid, crid)) &&
            (identical(other.titlesCount, titlesCount) ||
                const DeepCollectionEquality()
                    .equals(other.titlesCount, titlesCount)) &&
            (identical(other.seriesCount, seriesCount) ||
                const DeepCollectionEquality()
                    .equals(other.seriesCount, seriesCount)) &&
            (identical(other.isAdult, isAdult) ||
                const DeepCollectionEquality().equals(other.isAdult, isAdult)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(crid) ^
      const DeepCollectionEquality().hash(titlesCount) ^
      const DeepCollectionEquality().hash(seriesCount) ^
      const DeepCollectionEquality().hash(isAdult) ^
      runtimeType.hashCode;
}

extension $GridFilterOptionExtension on GridFilterOption {
  GridFilterOption copyWith(
      {String? name,
      String? crid,
      int? titlesCount,
      int? seriesCount,
      bool? isAdult}) {
    return GridFilterOption(
        name: name ?? this.name,
        crid: crid ?? this.crid,
        titlesCount: titlesCount ?? this.titlesCount,
        seriesCount: seriesCount ?? this.seriesCount,
        isAdult: isAdult ?? this.isAdult);
  }

  GridFilterOption copyWithWrapped(
      {Wrapped<String?>? name,
      Wrapped<String?>? crid,
      Wrapped<int?>? titlesCount,
      Wrapped<int?>? seriesCount,
      Wrapped<bool?>? isAdult}) {
    return GridFilterOption(
        name: (name != null ? name.value : this.name),
        crid: (crid != null ? crid.value : this.crid),
        titlesCount:
            (titlesCount != null ? titlesCount.value : this.titlesCount),
        seriesCount:
            (seriesCount != null ? seriesCount.value : this.seriesCount),
        isAdult: (isAdult != null ? isAdult.value : this.isAdult));
  }
}

@JsonSerializable(explicitToJson: true)
class GridFilterOptions {
  GridFilterOptions({
    this.newArrivals,
    this.lastChance,
    this.goDownloadable,
    this.genres,
  });

  factory GridFilterOptions.fromJson(Map<String, dynamic> json) =>
      _$GridFilterOptionsFromJson(json);

  @JsonKey(name: 'newArrivals', includeIfNull: false)
  final bool? newArrivals;
  @JsonKey(name: 'lastChance', includeIfNull: false)
  final bool? lastChance;
  @JsonKey(name: 'goDownloadable', includeIfNull: false)
  final bool? goDownloadable;
  @JsonKey(
      name: 'genres', includeIfNull: false, defaultValue: <GridFilterOption>[])
  final List<GridFilterOption>? genres;
  static const fromJsonFactory = _$GridFilterOptionsFromJson;
  static const toJsonFactory = _$GridFilterOptionsToJson;
  Map<String, dynamic> toJson() => _$GridFilterOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is GridFilterOptions &&
            (identical(other.newArrivals, newArrivals) ||
                const DeepCollectionEquality()
                    .equals(other.newArrivals, newArrivals)) &&
            (identical(other.lastChance, lastChance) ||
                const DeepCollectionEquality()
                    .equals(other.lastChance, lastChance)) &&
            (identical(other.goDownloadable, goDownloadable) ||
                const DeepCollectionEquality()
                    .equals(other.goDownloadable, goDownloadable)) &&
            (identical(other.genres, genres) ||
                const DeepCollectionEquality().equals(other.genres, genres)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(newArrivals) ^
      const DeepCollectionEquality().hash(lastChance) ^
      const DeepCollectionEquality().hash(goDownloadable) ^
      const DeepCollectionEquality().hash(genres) ^
      runtimeType.hashCode;
}

extension $GridFilterOptionsExtension on GridFilterOptions {
  GridFilterOptions copyWith(
      {bool? newArrivals,
      bool? lastChance,
      bool? goDownloadable,
      List<GridFilterOption>? genres}) {
    return GridFilterOptions(
        newArrivals: newArrivals ?? this.newArrivals,
        lastChance: lastChance ?? this.lastChance,
        goDownloadable: goDownloadable ?? this.goDownloadable,
        genres: genres ?? this.genres);
  }

  GridFilterOptions copyWithWrapped(
      {Wrapped<bool?>? newArrivals,
      Wrapped<bool?>? lastChance,
      Wrapped<bool?>? goDownloadable,
      Wrapped<List<GridFilterOption>?>? genres}) {
    return GridFilterOptions(
        newArrivals:
            (newArrivals != null ? newArrivals.value : this.newArrivals),
        lastChance: (lastChance != null ? lastChance.value : this.lastChance),
        goDownloadable: (goDownloadable != null
            ? goDownloadable.value
            : this.goDownloadable),
        genres: (genres != null ? genres.value : this.genres));
  }
}

@JsonSerializable(explicitToJson: true)
class GridOptions {
  GridOptions({
    this.id,
    this.titlesCount,
    this.seriesCount,
    this.isAdult,
    this.filterOptions,
    this.sortOptions,
  });

  factory GridOptions.fromJson(Map<String, dynamic> json) =>
      _$GridOptionsFromJson(json);

  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String? id;
  @JsonKey(name: 'titlesCount', includeIfNull: false)
  final int? titlesCount;
  @JsonKey(name: 'seriesCount', includeIfNull: false)
  final int? seriesCount;
  @JsonKey(name: 'isAdult', includeIfNull: false)
  final bool? isAdult;
  @JsonKey(name: 'filterOptions', includeIfNull: false)
  final GridFilterOptions? filterOptions;
  @JsonKey(name: 'sortOptions', includeIfNull: false)
  final GridSortOptions? sortOptions;
  static const fromJsonFactory = _$GridOptionsFromJson;
  static const toJsonFactory = _$GridOptionsToJson;
  Map<String, dynamic> toJson() => _$GridOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is GridOptions &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.titlesCount, titlesCount) ||
                const DeepCollectionEquality()
                    .equals(other.titlesCount, titlesCount)) &&
            (identical(other.seriesCount, seriesCount) ||
                const DeepCollectionEquality()
                    .equals(other.seriesCount, seriesCount)) &&
            (identical(other.isAdult, isAdult) ||
                const DeepCollectionEquality()
                    .equals(other.isAdult, isAdult)) &&
            (identical(other.filterOptions, filterOptions) ||
                const DeepCollectionEquality()
                    .equals(other.filterOptions, filterOptions)) &&
            (identical(other.sortOptions, sortOptions) ||
                const DeepCollectionEquality()
                    .equals(other.sortOptions, sortOptions)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(titlesCount) ^
      const DeepCollectionEquality().hash(seriesCount) ^
      const DeepCollectionEquality().hash(isAdult) ^
      const DeepCollectionEquality().hash(filterOptions) ^
      const DeepCollectionEquality().hash(sortOptions) ^
      runtimeType.hashCode;
}

extension $GridOptionsExtension on GridOptions {
  GridOptions copyWith(
      {String? id,
      int? titlesCount,
      int? seriesCount,
      bool? isAdult,
      GridFilterOptions? filterOptions,
      GridSortOptions? sortOptions}) {
    return GridOptions(
        id: id ?? this.id,
        titlesCount: titlesCount ?? this.titlesCount,
        seriesCount: seriesCount ?? this.seriesCount,
        isAdult: isAdult ?? this.isAdult,
        filterOptions: filterOptions ?? this.filterOptions,
        sortOptions: sortOptions ?? this.sortOptions);
  }

  GridOptions copyWithWrapped(
      {Wrapped<String?>? id,
      Wrapped<int?>? titlesCount,
      Wrapped<int?>? seriesCount,
      Wrapped<bool?>? isAdult,
      Wrapped<GridFilterOptions?>? filterOptions,
      Wrapped<GridSortOptions?>? sortOptions}) {
    return GridOptions(
        id: (id != null ? id.value : this.id),
        titlesCount:
            (titlesCount != null ? titlesCount.value : this.titlesCount),
        seriesCount:
            (seriesCount != null ? seriesCount.value : this.seriesCount),
        isAdult: (isAdult != null ? isAdult.value : this.isAdult),
        filterOptions:
            (filterOptions != null ? filterOptions.value : this.filterOptions),
        sortOptions:
            (sortOptions != null ? sortOptions.value : this.sortOptions));
  }
}

@JsonSerializable(explicitToJson: true)
class GridSortOptions {
  GridSortOptions({
    this.broadcastDate,
  });

  factory GridSortOptions.fromJson(Map<String, dynamic> json) =>
      _$GridSortOptionsFromJson(json);

  @JsonKey(name: 'broadcastDate', includeIfNull: false)
  final bool? broadcastDate;
  static const fromJsonFactory = _$GridSortOptionsFromJson;
  static const toJsonFactory = _$GridSortOptionsToJson;
  Map<String, dynamic> toJson() => _$GridSortOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is GridSortOptions &&
            (identical(other.broadcastDate, broadcastDate) ||
                const DeepCollectionEquality()
                    .equals(other.broadcastDate, broadcastDate)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(broadcastDate) ^ runtimeType.hashCode;
}

extension $GridSortOptionsExtension on GridSortOptions {
  GridSortOptions copyWith({bool? broadcastDate}) {
    return GridSortOptions(broadcastDate: broadcastDate ?? this.broadcastDate);
  }

  GridSortOptions copyWithWrapped({Wrapped<bool?>? broadcastDate}) {
    return GridSortOptions(
        broadcastDate:
            (broadcastDate != null ? broadcastDate.value : this.broadcastDate));
  }
}

@JsonSerializable(explicitToJson: true)
class GridScreen {
  GridScreen({
    this.id,
    this.title,
    this.screenLayout,
    this.isAdult,
    this.background,
    this.brandLogoImage,
    this.logoThumbnail,
    this.brandingProviderId,
    this.indexStart,
    this.itemCount,
    this.totalCount,
    this.items,
  });

  factory GridScreen.fromJson(Map<String, dynamic> json) =>
      _$GridScreenFromJson(json);

  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String? id;
  @JsonKey(name: 'title', includeIfNull: false, defaultValue: '')
  final String? title;
  @JsonKey(name: 'screenLayout', includeIfNull: false, defaultValue: '')
  final String? screenLayout;
  @JsonKey(name: 'isAdult', includeIfNull: false)
  final bool? isAdult;
  @JsonKey(name: 'background', includeIfNull: false, defaultValue: '')
  final String? background;
  @JsonKey(name: 'brandLogoImage', includeIfNull: false, defaultValue: '')
  final String? brandLogoImage;
  @JsonKey(name: 'logoThumbnail', includeIfNull: false, defaultValue: '')
  final String? logoThumbnail;
  @JsonKey(name: 'brandingProviderId', includeIfNull: false, defaultValue: '')
  final String? brandingProviderId;
  @JsonKey(name: 'indexStart', includeIfNull: false)
  final int? indexStart;
  @JsonKey(name: 'itemCount', includeIfNull: false)
  final int? itemCount;
  @JsonKey(name: 'totalCount', includeIfNull: false)
  final int? totalCount;
  @JsonKey(name: 'items', includeIfNull: false, defaultValue: <Item>[])
  final List<Item>? items;
  static const fromJsonFactory = _$GridScreenFromJson;
  static const toJsonFactory = _$GridScreenToJson;
  Map<String, dynamic> toJson() => _$GridScreenToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is GridScreen &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.screenLayout, screenLayout) ||
                const DeepCollectionEquality()
                    .equals(other.screenLayout, screenLayout)) &&
            (identical(other.isAdult, isAdult) ||
                const DeepCollectionEquality()
                    .equals(other.isAdult, isAdult)) &&
            (identical(other.background, background) ||
                const DeepCollectionEquality()
                    .equals(other.background, background)) &&
            (identical(other.brandLogoImage, brandLogoImage) ||
                const DeepCollectionEquality()
                    .equals(other.brandLogoImage, brandLogoImage)) &&
            (identical(other.logoThumbnail, logoThumbnail) ||
                const DeepCollectionEquality()
                    .equals(other.logoThumbnail, logoThumbnail)) &&
            (identical(other.brandingProviderId, brandingProviderId) ||
                const DeepCollectionEquality()
                    .equals(other.brandingProviderId, brandingProviderId)) &&
            (identical(other.indexStart, indexStart) ||
                const DeepCollectionEquality()
                    .equals(other.indexStart, indexStart)) &&
            (identical(other.itemCount, itemCount) ||
                const DeepCollectionEquality()
                    .equals(other.itemCount, itemCount)) &&
            (identical(other.totalCount, totalCount) ||
                const DeepCollectionEquality()
                    .equals(other.totalCount, totalCount)) &&
            (identical(other.items, items) ||
                const DeepCollectionEquality().equals(other.items, items)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(screenLayout) ^
      const DeepCollectionEquality().hash(isAdult) ^
      const DeepCollectionEquality().hash(background) ^
      const DeepCollectionEquality().hash(brandLogoImage) ^
      const DeepCollectionEquality().hash(logoThumbnail) ^
      const DeepCollectionEquality().hash(brandingProviderId) ^
      const DeepCollectionEquality().hash(indexStart) ^
      const DeepCollectionEquality().hash(itemCount) ^
      const DeepCollectionEquality().hash(totalCount) ^
      const DeepCollectionEquality().hash(items) ^
      runtimeType.hashCode;
}

extension $GridScreenExtension on GridScreen {
  GridScreen copyWith(
      {String? id,
      String? title,
      String? screenLayout,
      bool? isAdult,
      String? background,
      String? brandLogoImage,
      String? logoThumbnail,
      String? brandingProviderId,
      int? indexStart,
      int? itemCount,
      int? totalCount,
      List<Item>? items}) {
    return GridScreen(
        id: id ?? this.id,
        title: title ?? this.title,
        screenLayout: screenLayout ?? this.screenLayout,
        isAdult: isAdult ?? this.isAdult,
        background: background ?? this.background,
        brandLogoImage: brandLogoImage ?? this.brandLogoImage,
        logoThumbnail: logoThumbnail ?? this.logoThumbnail,
        brandingProviderId: brandingProviderId ?? this.brandingProviderId,
        indexStart: indexStart ?? this.indexStart,
        itemCount: itemCount ?? this.itemCount,
        totalCount: totalCount ?? this.totalCount,
        items: items ?? this.items);
  }

  GridScreen copyWithWrapped(
      {Wrapped<String?>? id,
      Wrapped<String?>? title,
      Wrapped<String?>? screenLayout,
      Wrapped<bool?>? isAdult,
      Wrapped<String?>? background,
      Wrapped<String?>? brandLogoImage,
      Wrapped<String?>? logoThumbnail,
      Wrapped<String?>? brandingProviderId,
      Wrapped<int?>? indexStart,
      Wrapped<int?>? itemCount,
      Wrapped<int?>? totalCount,
      Wrapped<List<Item>?>? items}) {
    return GridScreen(
        id: (id != null ? id.value : this.id),
        title: (title != null ? title.value : this.title),
        screenLayout:
            (screenLayout != null ? screenLayout.value : this.screenLayout),
        isAdult: (isAdult != null ? isAdult.value : this.isAdult),
        background: (background != null ? background.value : this.background),
        brandLogoImage: (brandLogoImage != null
            ? brandLogoImage.value
            : this.brandLogoImage),
        logoThumbnail:
            (logoThumbnail != null ? logoThumbnail.value : this.logoThumbnail),
        brandingProviderId: (brandingProviderId != null
            ? brandingProviderId.value
            : this.brandingProviderId),
        indexStart: (indexStart != null ? indexStart.value : this.indexStart),
        itemCount: (itemCount != null ? itemCount.value : this.itemCount),
        totalCount: (totalCount != null ? totalCount.value : this.totalCount),
        items: (items != null ? items.value : this.items));
  }
}

@JsonSerializable(explicitToJson: true)
class NextEpisode {
  NextEpisode({
    this.nextEpisode,
  });

  factory NextEpisode.fromJson(Map<String, dynamic> json) =>
      _$NextEpisodeFromJson(json);

  @JsonKey(name: 'nextEpisode', includeIfNull: false, defaultValue: '')
  final String? nextEpisode;
  static const fromJsonFactory = _$NextEpisodeFromJson;
  static const toJsonFactory = _$NextEpisodeToJson;
  Map<String, dynamic> toJson() => _$NextEpisodeToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is NextEpisode &&
            (identical(other.nextEpisode, nextEpisode) ||
                const DeepCollectionEquality()
                    .equals(other.nextEpisode, nextEpisode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(nextEpisode) ^ runtimeType.hashCode;
}

extension $NextEpisodeExtension on NextEpisode {
  NextEpisode copyWith({String? nextEpisode}) {
    return NextEpisode(nextEpisode: nextEpisode ?? this.nextEpisode);
  }

  NextEpisode copyWithWrapped({Wrapped<String?>? nextEpisode}) {
    return NextEpisode(
        nextEpisode:
            (nextEpisode != null ? nextEpisode.value : this.nextEpisode));
  }
}

@JsonSerializable(explicitToJson: true)
class TileItem {
  TileItem({
    this.id,
    this.title,
    this.image,
    this.screenLayout,
    this.contentType,
    this.isAdult,
    this.gridLink,
  });

  factory TileItem.fromJson(Map<String, dynamic> json) =>
      _$TileItemFromJson(json);

  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String? id;
  @JsonKey(name: 'title', includeIfNull: false, defaultValue: '')
  final String? title;
  @JsonKey(name: 'image', includeIfNull: false, defaultValue: '')
  final String? image;
  @JsonKey(name: 'screenLayout', includeIfNull: false, defaultValue: '')
  final String? screenLayout;
  @JsonKey(name: 'contentType', includeIfNull: false, defaultValue: '')
  final String? contentType;
  @JsonKey(name: 'isAdult', includeIfNull: false)
  final bool? isAdult;
  @JsonKey(name: 'gridLink', includeIfNull: false)
  final GridLink? gridLink;
  static const fromJsonFactory = _$TileItemFromJson;
  static const toJsonFactory = _$TileItemToJson;
  Map<String, dynamic> toJson() => _$TileItemToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TileItem &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.image, image) ||
                const DeepCollectionEquality().equals(other.image, image)) &&
            (identical(other.screenLayout, screenLayout) ||
                const DeepCollectionEquality()
                    .equals(other.screenLayout, screenLayout)) &&
            (identical(other.contentType, contentType) ||
                const DeepCollectionEquality()
                    .equals(other.contentType, contentType)) &&
            (identical(other.isAdult, isAdult) ||
                const DeepCollectionEquality()
                    .equals(other.isAdult, isAdult)) &&
            (identical(other.gridLink, gridLink) ||
                const DeepCollectionEquality()
                    .equals(other.gridLink, gridLink)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(image) ^
      const DeepCollectionEquality().hash(screenLayout) ^
      const DeepCollectionEquality().hash(contentType) ^
      const DeepCollectionEquality().hash(isAdult) ^
      const DeepCollectionEquality().hash(gridLink) ^
      runtimeType.hashCode;
}

extension $TileItemExtension on TileItem {
  TileItem copyWith(
      {String? id,
      String? title,
      String? image,
      String? screenLayout,
      String? contentType,
      bool? isAdult,
      GridLink? gridLink}) {
    return TileItem(
        id: id ?? this.id,
        title: title ?? this.title,
        image: image ?? this.image,
        screenLayout: screenLayout ?? this.screenLayout,
        contentType: contentType ?? this.contentType,
        isAdult: isAdult ?? this.isAdult,
        gridLink: gridLink ?? this.gridLink);
  }

  TileItem copyWithWrapped(
      {Wrapped<String?>? id,
      Wrapped<String?>? title,
      Wrapped<String?>? image,
      Wrapped<String?>? screenLayout,
      Wrapped<String?>? contentType,
      Wrapped<bool?>? isAdult,
      Wrapped<GridLink?>? gridLink}) {
    return TileItem(
        id: (id != null ? id.value : this.id),
        title: (title != null ? title.value : this.title),
        image: (image != null ? image.value : this.image),
        screenLayout:
            (screenLayout != null ? screenLayout.value : this.screenLayout),
        contentType:
            (contentType != null ? contentType.value : this.contentType),
        isAdult: (isAdult != null ? isAdult.value : this.isAdult),
        gridLink: (gridLink != null ? gridLink.value : this.gridLink));
  }
}

@JsonSerializable(explicitToJson: true)
class TileScreen {
  TileScreen({
    this.id,
    this.title,
    this.screenLayout,
    this.isAdult,
    this.background,
    this.logoThumbnail,
    this.brandingProviderId,
    this.items,
  });

  factory TileScreen.fromJson(Map<String, dynamic> json) =>
      _$TileScreenFromJson(json);

  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String? id;
  @JsonKey(name: 'title', includeIfNull: false, defaultValue: '')
  final String? title;
  @JsonKey(name: 'screenLayout', includeIfNull: false, defaultValue: '')
  final String? screenLayout;
  @JsonKey(name: 'isAdult', includeIfNull: false)
  final bool? isAdult;
  @JsonKey(name: 'background', includeIfNull: false, defaultValue: '')
  final String? background;
  @JsonKey(name: 'logoThumbnail', includeIfNull: false, defaultValue: '')
  final String? logoThumbnail;
  @JsonKey(name: 'brandingProviderId', includeIfNull: false, defaultValue: '')
  final String? brandingProviderId;
  @JsonKey(name: 'items', includeIfNull: false, defaultValue: <TileItem>[])
  final List<TileItem>? items;
  static const fromJsonFactory = _$TileScreenFromJson;
  static const toJsonFactory = _$TileScreenToJson;
  Map<String, dynamic> toJson() => _$TileScreenToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TileScreen &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.screenLayout, screenLayout) ||
                const DeepCollectionEquality()
                    .equals(other.screenLayout, screenLayout)) &&
            (identical(other.isAdult, isAdult) ||
                const DeepCollectionEquality()
                    .equals(other.isAdult, isAdult)) &&
            (identical(other.background, background) ||
                const DeepCollectionEquality()
                    .equals(other.background, background)) &&
            (identical(other.logoThumbnail, logoThumbnail) ||
                const DeepCollectionEquality()
                    .equals(other.logoThumbnail, logoThumbnail)) &&
            (identical(other.brandingProviderId, brandingProviderId) ||
                const DeepCollectionEquality()
                    .equals(other.brandingProviderId, brandingProviderId)) &&
            (identical(other.items, items) ||
                const DeepCollectionEquality().equals(other.items, items)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(screenLayout) ^
      const DeepCollectionEquality().hash(isAdult) ^
      const DeepCollectionEquality().hash(background) ^
      const DeepCollectionEquality().hash(logoThumbnail) ^
      const DeepCollectionEquality().hash(brandingProviderId) ^
      const DeepCollectionEquality().hash(items) ^
      runtimeType.hashCode;
}

extension $TileScreenExtension on TileScreen {
  TileScreen copyWith(
      {String? id,
      String? title,
      String? screenLayout,
      bool? isAdult,
      String? background,
      String? logoThumbnail,
      String? brandingProviderId,
      List<TileItem>? items}) {
    return TileScreen(
        id: id ?? this.id,
        title: title ?? this.title,
        screenLayout: screenLayout ?? this.screenLayout,
        isAdult: isAdult ?? this.isAdult,
        background: background ?? this.background,
        logoThumbnail: logoThumbnail ?? this.logoThumbnail,
        brandingProviderId: brandingProviderId ?? this.brandingProviderId,
        items: items ?? this.items);
  }

  TileScreen copyWithWrapped(
      {Wrapped<String?>? id,
      Wrapped<String?>? title,
      Wrapped<String?>? screenLayout,
      Wrapped<bool?>? isAdult,
      Wrapped<String?>? background,
      Wrapped<String?>? logoThumbnail,
      Wrapped<String?>? brandingProviderId,
      Wrapped<List<TileItem>?>? items}) {
    return TileScreen(
        id: (id != null ? id.value : this.id),
        title: (title != null ? title.value : this.title),
        screenLayout:
            (screenLayout != null ? screenLayout.value : this.screenLayout),
        isAdult: (isAdult != null ? isAdult.value : this.isAdult),
        background: (background != null ? background.value : this.background),
        logoThumbnail:
            (logoThumbnail != null ? logoThumbnail.value : this.logoThumbnail),
        brandingProviderId: (brandingProviderId != null
            ? brandingProviderId.value
            : this.brandingProviderId),
        items: (items != null ? items.value : this.items));
  }
}

@JsonSerializable(explicitToJson: true)
class Messages {
  Messages({
    this.messages,
  });

  factory Messages.fromJson(Map<String, dynamic> json) =>
      _$MessagesFromJson(json);

  @JsonKey(name: 'messages', includeIfNull: false, defaultValue: <String>[])
  final List<String>? messages;
  static const fromJsonFactory = _$MessagesFromJson;
  static const toJsonFactory = _$MessagesToJson;
  Map<String, dynamic> toJson() => _$MessagesToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Messages &&
            (identical(other.messages, messages) ||
                const DeepCollectionEquality()
                    .equals(other.messages, messages)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(messages) ^ runtimeType.hashCode;
}

extension $MessagesExtension on Messages {
  Messages copyWith({List<String>? messages}) {
    return Messages(messages: messages ?? this.messages);
  }

  Messages copyWithWrapped({Wrapped<List<String>?>? messages}) {
    return Messages(
        messages: (messages != null ? messages.value : this.messages));
  }
}

@JsonSerializable(explicitToJson: true)
class PersonDetail {
  PersonDetail({
    this.id,
    this.name,
    this.dateOfBirth,
    this.placeOfBirth,
    this.synopsis,
    this.image,
  });

  factory PersonDetail.fromJson(Map<String, dynamic> json) =>
      _$PersonDetailFromJson(json);

  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String? id;
  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String? name;
  @JsonKey(name: 'dateOfBirth', includeIfNull: false, defaultValue: '')
  final String? dateOfBirth;
  @JsonKey(name: 'placeOfBirth', includeIfNull: false, defaultValue: '')
  final String? placeOfBirth;
  @JsonKey(name: 'synopsis', includeIfNull: false, defaultValue: '')
  final String? synopsis;
  @JsonKey(name: 'image', includeIfNull: false, defaultValue: '')
  final String? image;
  static const fromJsonFactory = _$PersonDetailFromJson;
  static const toJsonFactory = _$PersonDetailToJson;
  Map<String, dynamic> toJson() => _$PersonDetailToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PersonDetail &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.dateOfBirth, dateOfBirth) ||
                const DeepCollectionEquality()
                    .equals(other.dateOfBirth, dateOfBirth)) &&
            (identical(other.placeOfBirth, placeOfBirth) ||
                const DeepCollectionEquality()
                    .equals(other.placeOfBirth, placeOfBirth)) &&
            (identical(other.synopsis, synopsis) ||
                const DeepCollectionEquality()
                    .equals(other.synopsis, synopsis)) &&
            (identical(other.image, image) ||
                const DeepCollectionEquality().equals(other.image, image)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(dateOfBirth) ^
      const DeepCollectionEquality().hash(placeOfBirth) ^
      const DeepCollectionEquality().hash(synopsis) ^
      const DeepCollectionEquality().hash(image) ^
      runtimeType.hashCode;
}

extension $PersonDetailExtension on PersonDetail {
  PersonDetail copyWith(
      {String? id,
      String? name,
      String? dateOfBirth,
      String? placeOfBirth,
      String? synopsis,
      String? image}) {
    return PersonDetail(
        id: id ?? this.id,
        name: name ?? this.name,
        dateOfBirth: dateOfBirth ?? this.dateOfBirth,
        placeOfBirth: placeOfBirth ?? this.placeOfBirth,
        synopsis: synopsis ?? this.synopsis,
        image: image ?? this.image);
  }

  PersonDetail copyWithWrapped(
      {Wrapped<String?>? id,
      Wrapped<String?>? name,
      Wrapped<String?>? dateOfBirth,
      Wrapped<String?>? placeOfBirth,
      Wrapped<String?>? synopsis,
      Wrapped<String?>? image}) {
    return PersonDetail(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        dateOfBirth:
            (dateOfBirth != null ? dateOfBirth.value : this.dateOfBirth),
        placeOfBirth:
            (placeOfBirth != null ? placeOfBirth.value : this.placeOfBirth),
        synopsis: (synopsis != null ? synopsis.value : this.synopsis),
        image: (image != null ? image.value : this.image));
  }
}

@JsonSerializable(explicitToJson: true)
class AZJump {
  AZJump({
    this.undefinedParameter,
    this.a,
    this.b,
    this.c,
    this.d,
    this.e,
    this.f,
    this.g,
    this.h,
    this.i,
    this.j,
    this.k,
    this.l,
    this.m,
    this.n,
    this.o,
    this.p,
    this.q,
    this.r,
    this.s,
    this.t,
    this.u,
    this.v,
    this.w,
    this.x,
    this.y,
    this.z,
  });

  factory AZJump.fromJson(Map<String, dynamic> json) => _$AZJumpFromJson(json);

  @JsonKey(name: '#', includeIfNull: false)
  final int? undefinedParameter;
  @JsonKey(name: 'A', includeIfNull: false)
  final int? a;
  @JsonKey(name: 'B', includeIfNull: false)
  final int? b;
  @JsonKey(name: 'C', includeIfNull: false)
  final int? c;
  @JsonKey(name: 'D', includeIfNull: false)
  final int? d;
  @JsonKey(name: 'E', includeIfNull: false)
  final int? e;
  @JsonKey(name: 'F', includeIfNull: false)
  final int? f;
  @JsonKey(name: 'G', includeIfNull: false)
  final int? g;
  @JsonKey(name: 'H', includeIfNull: false)
  final int? h;
  @JsonKey(name: 'I', includeIfNull: false)
  final int? i;
  @JsonKey(name: 'J', includeIfNull: false)
  final int? j;
  @JsonKey(name: 'K', includeIfNull: false)
  final int? k;
  @JsonKey(name: 'L', includeIfNull: false)
  final int? l;
  @JsonKey(name: 'M', includeIfNull: false)
  final int? m;
  @JsonKey(name: 'N', includeIfNull: false)
  final int? n;
  @JsonKey(name: 'O', includeIfNull: false)
  final int? o;
  @JsonKey(name: 'P', includeIfNull: false)
  final int? p;
  @JsonKey(name: 'Q', includeIfNull: false)
  final int? q;
  @JsonKey(name: 'R', includeIfNull: false)
  final int? r;
  @JsonKey(name: 'S', includeIfNull: false)
  final int? s;
  @JsonKey(name: 'T', includeIfNull: false)
  final int? t;
  @JsonKey(name: 'U', includeIfNull: false)
  final int? u;
  @JsonKey(name: 'V', includeIfNull: false)
  final int? v;
  @JsonKey(name: 'W', includeIfNull: false)
  final int? w;
  @JsonKey(name: 'X', includeIfNull: false)
  final int? x;
  @JsonKey(name: 'Y', includeIfNull: false)
  final int? y;
  @JsonKey(name: 'Z', includeIfNull: false)
  final int? z;
  static const fromJsonFactory = _$AZJumpFromJson;
  static const toJsonFactory = _$AZJumpToJson;
  Map<String, dynamic> toJson() => _$AZJumpToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AZJump &&
            (identical(other.undefinedParameter, undefinedParameter) ||
                const DeepCollectionEquality()
                    .equals(other.undefinedParameter, undefinedParameter)) &&
            (identical(other.a, a) ||
                const DeepCollectionEquality().equals(other.a, a)) &&
            (identical(other.b, b) ||
                const DeepCollectionEquality().equals(other.b, b)) &&
            (identical(other.c, c) ||
                const DeepCollectionEquality().equals(other.c, c)) &&
            (identical(other.d, d) ||
                const DeepCollectionEquality().equals(other.d, d)) &&
            (identical(other.e, e) ||
                const DeepCollectionEquality().equals(other.e, e)) &&
            (identical(other.f, f) ||
                const DeepCollectionEquality().equals(other.f, f)) &&
            (identical(other.g, g) ||
                const DeepCollectionEquality().equals(other.g, g)) &&
            (identical(other.h, h) ||
                const DeepCollectionEquality().equals(other.h, h)) &&
            (identical(other.i, i) ||
                const DeepCollectionEquality().equals(other.i, i)) &&
            (identical(other.j, j) ||
                const DeepCollectionEquality().equals(other.j, j)) &&
            (identical(other.k, k) ||
                const DeepCollectionEquality().equals(other.k, k)) &&
            (identical(other.l, l) ||
                const DeepCollectionEquality().equals(other.l, l)) &&
            (identical(other.m, m) ||
                const DeepCollectionEquality().equals(other.m, m)) &&
            (identical(other.n, n) ||
                const DeepCollectionEquality().equals(other.n, n)) &&
            (identical(other.o, o) ||
                const DeepCollectionEquality().equals(other.o, o)) &&
            (identical(other.p, p) ||
                const DeepCollectionEquality().equals(other.p, p)) &&
            (identical(other.q, q) ||
                const DeepCollectionEquality().equals(other.q, q)) &&
            (identical(other.r, r) ||
                const DeepCollectionEquality().equals(other.r, r)) &&
            (identical(other.s, s) ||
                const DeepCollectionEquality().equals(other.s, s)) &&
            (identical(other.t, t) ||
                const DeepCollectionEquality().equals(other.t, t)) &&
            (identical(other.u, u) ||
                const DeepCollectionEquality().equals(other.u, u)) &&
            (identical(other.v, v) ||
                const DeepCollectionEquality().equals(other.v, v)) &&
            (identical(other.w, w) ||
                const DeepCollectionEquality().equals(other.w, w)) &&
            (identical(other.x, x) ||
                const DeepCollectionEquality().equals(other.x, x)) &&
            (identical(other.y, y) ||
                const DeepCollectionEquality().equals(other.y, y)) &&
            (identical(other.z, z) ||
                const DeepCollectionEquality().equals(other.z, z)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(undefinedParameter) ^
      const DeepCollectionEquality().hash(a) ^
      const DeepCollectionEquality().hash(b) ^
      const DeepCollectionEquality().hash(c) ^
      const DeepCollectionEquality().hash(d) ^
      const DeepCollectionEquality().hash(e) ^
      const DeepCollectionEquality().hash(f) ^
      const DeepCollectionEquality().hash(g) ^
      const DeepCollectionEquality().hash(h) ^
      const DeepCollectionEquality().hash(i) ^
      const DeepCollectionEquality().hash(j) ^
      const DeepCollectionEquality().hash(k) ^
      const DeepCollectionEquality().hash(l) ^
      const DeepCollectionEquality().hash(m) ^
      const DeepCollectionEquality().hash(n) ^
      const DeepCollectionEquality().hash(o) ^
      const DeepCollectionEquality().hash(p) ^
      const DeepCollectionEquality().hash(q) ^
      const DeepCollectionEquality().hash(r) ^
      const DeepCollectionEquality().hash(s) ^
      const DeepCollectionEquality().hash(t) ^
      const DeepCollectionEquality().hash(u) ^
      const DeepCollectionEquality().hash(v) ^
      const DeepCollectionEquality().hash(w) ^
      const DeepCollectionEquality().hash(x) ^
      const DeepCollectionEquality().hash(y) ^
      const DeepCollectionEquality().hash(z) ^
      runtimeType.hashCode;
}

extension $AZJumpExtension on AZJump {
  AZJump copyWith(
      {int? undefinedParameter,
      int? a,
      int? b,
      int? c,
      int? d,
      int? e,
      int? f,
      int? g,
      int? h,
      int? i,
      int? j,
      int? k,
      int? l,
      int? m,
      int? n,
      int? o,
      int? p,
      int? q,
      int? r,
      int? s,
      int? t,
      int? u,
      int? v,
      int? w,
      int? x,
      int? y,
      int? z}) {
    return AZJump(
        undefinedParameter: undefinedParameter ?? this.undefinedParameter,
        a: a ?? this.a,
        b: b ?? this.b,
        c: c ?? this.c,
        d: d ?? this.d,
        e: e ?? this.e,
        f: f ?? this.f,
        g: g ?? this.g,
        h: h ?? this.h,
        i: i ?? this.i,
        j: j ?? this.j,
        k: k ?? this.k,
        l: l ?? this.l,
        m: m ?? this.m,
        n: n ?? this.n,
        o: o ?? this.o,
        p: p ?? this.p,
        q: q ?? this.q,
        r: r ?? this.r,
        s: s ?? this.s,
        t: t ?? this.t,
        u: u ?? this.u,
        v: v ?? this.v,
        w: w ?? this.w,
        x: x ?? this.x,
        y: y ?? this.y,
        z: z ?? this.z);
  }

  AZJump copyWithWrapped(
      {Wrapped<int?>? undefinedParameter,
      Wrapped<int?>? a,
      Wrapped<int?>? b,
      Wrapped<int?>? c,
      Wrapped<int?>? d,
      Wrapped<int?>? e,
      Wrapped<int?>? f,
      Wrapped<int?>? g,
      Wrapped<int?>? h,
      Wrapped<int?>? i,
      Wrapped<int?>? j,
      Wrapped<int?>? k,
      Wrapped<int?>? l,
      Wrapped<int?>? m,
      Wrapped<int?>? n,
      Wrapped<int?>? o,
      Wrapped<int?>? p,
      Wrapped<int?>? q,
      Wrapped<int?>? r,
      Wrapped<int?>? s,
      Wrapped<int?>? t,
      Wrapped<int?>? u,
      Wrapped<int?>? v,
      Wrapped<int?>? w,
      Wrapped<int?>? x,
      Wrapped<int?>? y,
      Wrapped<int?>? z}) {
    return AZJump(
        undefinedParameter: (undefinedParameter != null
            ? undefinedParameter.value
            : this.undefinedParameter),
        a: (a != null ? a.value : this.a),
        b: (b != null ? b.value : this.b),
        c: (c != null ? c.value : this.c),
        d: (d != null ? d.value : this.d),
        e: (e != null ? e.value : this.e),
        f: (f != null ? f.value : this.f),
        g: (g != null ? g.value : this.g),
        h: (h != null ? h.value : this.h),
        i: (i != null ? i.value : this.i),
        j: (j != null ? j.value : this.j),
        k: (k != null ? k.value : this.k),
        l: (l != null ? l.value : this.l),
        m: (m != null ? m.value : this.m),
        n: (n != null ? n.value : this.n),
        o: (o != null ? o.value : this.o),
        p: (p != null ? p.value : this.p),
        q: (q != null ? q.value : this.q),
        r: (r != null ? r.value : this.r),
        s: (s != null ? s.value : this.s),
        t: (t != null ? t.value : this.t),
        u: (u != null ? u.value : this.u),
        v: (v != null ? v.value : this.v),
        w: (w != null ? w.value : this.w),
        x: (x != null ? x.value : this.x),
        y: (y != null ? y.value : this.y),
        z: (z != null ? z.value : this.z));
  }
}

@JsonSerializable(explicitToJson: true)
class EditorialFeed {
  EditorialFeed({
    this.id,
    this.language,
    this.indexStart,
    this.sortType,
    this.sortDirection,
    this.itemCount,
    this.totalCount,
    this.items,
    this.azjump,
    this.filters,
  });

  factory EditorialFeed.fromJson(Map<String, dynamic> json) =>
      _$EditorialFeedFromJson(json);

  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String? id;
  @JsonKey(name: 'language', includeIfNull: false, defaultValue: '')
  final String? language;
  @JsonKey(name: 'indexStart', includeIfNull: false)
  final int? indexStart;
  @JsonKey(name: 'sortType', includeIfNull: false, defaultValue: '')
  final String? sortType;
  @JsonKey(name: 'sortDirection', includeIfNull: false, defaultValue: '')
  final String? sortDirection;
  @JsonKey(name: 'itemCount', includeIfNull: false)
  final int? itemCount;
  @JsonKey(name: 'totalCount', includeIfNull: false)
  final int? totalCount;
  @JsonKey(name: 'items', includeIfNull: false, defaultValue: <FeedItem>[])
  final List<FeedItem>? items;
  @JsonKey(name: 'azjump', includeIfNull: false)
  final AZJump? azjump;
  @JsonKey(name: 'filters', includeIfNull: false, defaultValue: <String>[])
  final List<String>? filters;
  static const fromJsonFactory = _$EditorialFeedFromJson;
  static const toJsonFactory = _$EditorialFeedToJson;
  Map<String, dynamic> toJson() => _$EditorialFeedToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EditorialFeed &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.indexStart, indexStart) ||
                const DeepCollectionEquality()
                    .equals(other.indexStart, indexStart)) &&
            (identical(other.sortType, sortType) ||
                const DeepCollectionEquality()
                    .equals(other.sortType, sortType)) &&
            (identical(other.sortDirection, sortDirection) ||
                const DeepCollectionEquality()
                    .equals(other.sortDirection, sortDirection)) &&
            (identical(other.itemCount, itemCount) ||
                const DeepCollectionEquality()
                    .equals(other.itemCount, itemCount)) &&
            (identical(other.totalCount, totalCount) ||
                const DeepCollectionEquality()
                    .equals(other.totalCount, totalCount)) &&
            (identical(other.items, items) ||
                const DeepCollectionEquality().equals(other.items, items)) &&
            (identical(other.azjump, azjump) ||
                const DeepCollectionEquality().equals(other.azjump, azjump)) &&
            (identical(other.filters, filters) ||
                const DeepCollectionEquality().equals(other.filters, filters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(indexStart) ^
      const DeepCollectionEquality().hash(sortType) ^
      const DeepCollectionEquality().hash(sortDirection) ^
      const DeepCollectionEquality().hash(itemCount) ^
      const DeepCollectionEquality().hash(totalCount) ^
      const DeepCollectionEquality().hash(items) ^
      const DeepCollectionEquality().hash(azjump) ^
      const DeepCollectionEquality().hash(filters) ^
      runtimeType.hashCode;
}

extension $EditorialFeedExtension on EditorialFeed {
  EditorialFeed copyWith(
      {String? id,
      String? language,
      int? indexStart,
      String? sortType,
      String? sortDirection,
      int? itemCount,
      int? totalCount,
      List<FeedItem>? items,
      AZJump? azjump,
      List<String>? filters}) {
    return EditorialFeed(
        id: id ?? this.id,
        language: language ?? this.language,
        indexStart: indexStart ?? this.indexStart,
        sortType: sortType ?? this.sortType,
        sortDirection: sortDirection ?? this.sortDirection,
        itemCount: itemCount ?? this.itemCount,
        totalCount: totalCount ?? this.totalCount,
        items: items ?? this.items,
        azjump: azjump ?? this.azjump,
        filters: filters ?? this.filters);
  }

  EditorialFeed copyWithWrapped(
      {Wrapped<String?>? id,
      Wrapped<String?>? language,
      Wrapped<int?>? indexStart,
      Wrapped<String?>? sortType,
      Wrapped<String?>? sortDirection,
      Wrapped<int?>? itemCount,
      Wrapped<int?>? totalCount,
      Wrapped<List<FeedItem>?>? items,
      Wrapped<AZJump?>? azjump,
      Wrapped<List<String>?>? filters}) {
    return EditorialFeed(
        id: (id != null ? id.value : this.id),
        language: (language != null ? language.value : this.language),
        indexStart: (indexStart != null ? indexStart.value : this.indexStart),
        sortType: (sortType != null ? sortType.value : this.sortType),
        sortDirection:
            (sortDirection != null ? sortDirection.value : this.sortDirection),
        itemCount: (itemCount != null ? itemCount.value : this.itemCount),
        totalCount: (totalCount != null ? totalCount.value : this.totalCount),
        items: (items != null ? items.value : this.items),
        azjump: (azjump != null ? azjump.value : this.azjump),
        filters: (filters != null ? filters.value : this.filters));
  }
}

@JsonSerializable(explicitToJson: true)
class FeedItem {
  FeedItem({
    this.id,
  });

  factory FeedItem.fromJson(Map<String, dynamic> json) =>
      _$FeedItemFromJson(json);

  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String? id;
  static const fromJsonFactory = _$FeedItemFromJson;
  static const toJsonFactory = _$FeedItemToJson;
  Map<String, dynamic> toJson() => _$FeedItemToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is FeedItem &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^ runtimeType.hashCode;
}

extension $FeedItemExtension on FeedItem {
  FeedItem copyWith({String? id}) {
    return FeedItem(id: id ?? this.id);
  }

  FeedItem copyWithWrapped({Wrapped<String?>? id}) {
    return FeedItem(id: (id != null ? id.value : this.id));
  }
}

@JsonSerializable(explicitToJson: true)
class Genre {
  Genre({
    this.name,
    this.crid,
    this.titlesCount,
    this.seriesCount,
    this.isAdult,
    this.image,
  });

  factory Genre.fromJson(Map<String, dynamic> json) => _$GenreFromJson(json);

  @JsonKey(name: 'name', includeIfNull: false, defaultValue: '')
  final String? name;
  @JsonKey(name: 'crid', includeIfNull: false, defaultValue: '')
  final String? crid;
  @JsonKey(name: 'titlesCount', includeIfNull: false)
  final int? titlesCount;
  @JsonKey(name: 'seriesCount', includeIfNull: false)
  final int? seriesCount;
  @JsonKey(name: 'isAdult', includeIfNull: false)
  final bool? isAdult;
  @JsonKey(name: 'image', includeIfNull: false, defaultValue: '')
  final String? image;
  static const fromJsonFactory = _$GenreFromJson;
  static const toJsonFactory = _$GenreToJson;
  Map<String, dynamic> toJson() => _$GenreToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Genre &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.crid, crid) ||
                const DeepCollectionEquality().equals(other.crid, crid)) &&
            (identical(other.titlesCount, titlesCount) ||
                const DeepCollectionEquality()
                    .equals(other.titlesCount, titlesCount)) &&
            (identical(other.seriesCount, seriesCount) ||
                const DeepCollectionEquality()
                    .equals(other.seriesCount, seriesCount)) &&
            (identical(other.isAdult, isAdult) ||
                const DeepCollectionEquality()
                    .equals(other.isAdult, isAdult)) &&
            (identical(other.image, image) ||
                const DeepCollectionEquality().equals(other.image, image)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(crid) ^
      const DeepCollectionEquality().hash(titlesCount) ^
      const DeepCollectionEquality().hash(seriesCount) ^
      const DeepCollectionEquality().hash(isAdult) ^
      const DeepCollectionEquality().hash(image) ^
      runtimeType.hashCode;
}

extension $GenreExtension on Genre {
  Genre copyWith(
      {String? name,
      String? crid,
      int? titlesCount,
      int? seriesCount,
      bool? isAdult,
      String? image}) {
    return Genre(
        name: name ?? this.name,
        crid: crid ?? this.crid,
        titlesCount: titlesCount ?? this.titlesCount,
        seriesCount: seriesCount ?? this.seriesCount,
        isAdult: isAdult ?? this.isAdult,
        image: image ?? this.image);
  }

  Genre copyWithWrapped(
      {Wrapped<String?>? name,
      Wrapped<String?>? crid,
      Wrapped<int?>? titlesCount,
      Wrapped<int?>? seriesCount,
      Wrapped<bool?>? isAdult,
      Wrapped<String?>? image}) {
    return Genre(
        name: (name != null ? name.value : this.name),
        crid: (crid != null ? crid.value : this.crid),
        titlesCount:
            (titlesCount != null ? titlesCount.value : this.titlesCount),
        seriesCount:
            (seriesCount != null ? seriesCount.value : this.seriesCount),
        isAdult: (isAdult != null ? isAdult.value : this.isAdult),
        image: (image != null ? image.value : this.image));
  }
}

@JsonSerializable(explicitToJson: true)
class GenreListResponse {
  GenreListResponse({
    this.id,
    this.genres,
  });

  factory GenreListResponse.fromJson(Map<String, dynamic> json) =>
      _$GenreListResponseFromJson(json);

  @JsonKey(name: 'id', includeIfNull: false, defaultValue: '')
  final String? id;
  @JsonKey(name: 'genres', includeIfNull: false, defaultValue: <Genre>[])
  final List<Genre>? genres;
  static const fromJsonFactory = _$GenreListResponseFromJson;
  static const toJsonFactory = _$GenreListResponseToJson;
  Map<String, dynamic> toJson() => _$GenreListResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is GenreListResponse &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.genres, genres) ||
                const DeepCollectionEquality().equals(other.genres, genres)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(genres) ^
      runtimeType.hashCode;
}

extension $GenreListResponseExtension on GenreListResponse {
  GenreListResponse copyWith({String? id, List<Genre>? genres}) {
    return GenreListResponse(id: id ?? this.id, genres: genres ?? this.genres);
  }

  GenreListResponse copyWithWrapped(
      {Wrapped<String?>? id, Wrapped<List<Genre>?>? genres}) {
    return GenreListResponse(
        id: (id != null ? id.value : this.id),
        genres: (genres != null ? genres.value : this.genres));
  }
}

String? programTypeToJson(enums.ProgramType? programType) {
  return programType?.value;
}

enums.ProgramType programTypeFromJson(
  Object? programType, [
  enums.ProgramType? defaultValue,
]) {
  return enums.ProgramType.values
          .firstWhereOrNull((e) => e.value == programType) ??
      defaultValue ??
      enums.ProgramType.swaggerGeneratedUnknown;
}

List<String> programTypeListToJson(List<enums.ProgramType>? programType) {
  if (programType == null) {
    return [];
  }

  return programType.map((e) => e.value!).toList();
}

List<enums.ProgramType> programTypeListFromJson(
  List? programType, [
  List<enums.ProgramType>? defaultValue,
]) {
  if (programType == null) {
    return defaultValue ?? [];
  }

  return programType.map((e) => programTypeFromJson(e.toString())).toList();
}

List<enums.ProgramType>? programTypeNullableListFromJson(
  List? programType, [
  List<enums.ProgramType>? defaultValue,
]) {
  if (programType == null) {
    return defaultValue;
  }

  return programType.map((e) => programTypeFromJson(e.toString())).toList();
}

String? showTypeToJson(enums.ShowType? showType) {
  return showType?.value;
}

enums.ShowType showTypeFromJson(
  Object? showType, [
  enums.ShowType? defaultValue,
]) {
  return enums.ShowType.values.firstWhereOrNull((e) => e.value == showType) ??
      defaultValue ??
      enums.ShowType.swaggerGeneratedUnknown;
}

List<String> showTypeListToJson(List<enums.ShowType>? showType) {
  if (showType == null) {
    return [];
  }

  return showType.map((e) => e.value!).toList();
}

List<enums.ShowType> showTypeListFromJson(
  List? showType, [
  List<enums.ShowType>? defaultValue,
]) {
  if (showType == null) {
    return defaultValue ?? [];
  }

  return showType.map((e) => showTypeFromJson(e.toString())).toList();
}

List<enums.ShowType>? showTypeNullableListFromJson(
  List? showType, [
  List<enums.ShowType>? defaultValue,
]) {
  if (showType == null) {
    return defaultValue;
  }

  return showType.map((e) => showTypeFromJson(e.toString())).toList();
}

String? titleTypeToJson(enums.TitleType? titleType) {
  return titleType?.value;
}

enums.TitleType titleTypeFromJson(
  Object? titleType, [
  enums.TitleType? defaultValue,
]) {
  return enums.TitleType.values.firstWhereOrNull((e) => e.value == titleType) ??
      defaultValue ??
      enums.TitleType.swaggerGeneratedUnknown;
}

List<String> titleTypeListToJson(List<enums.TitleType>? titleType) {
  if (titleType == null) {
    return [];
  }

  return titleType.map((e) => e.value!).toList();
}

List<enums.TitleType> titleTypeListFromJson(
  List? titleType, [
  List<enums.TitleType>? defaultValue,
]) {
  if (titleType == null) {
    return defaultValue ?? [];
  }

  return titleType.map((e) => titleTypeFromJson(e.toString())).toList();
}

List<enums.TitleType>? titleTypeNullableListFromJson(
  List? titleType, [
  List<enums.TitleType>? defaultValue,
]) {
  if (titleType == null) {
    return defaultValue;
  }

  return titleType.map((e) => titleTypeFromJson(e.toString())).toList();
}

String? purchasedProgramTypeToJson(
    enums.PurchasedProgramType? purchasedProgramType) {
  return purchasedProgramType?.value;
}

enums.PurchasedProgramType purchasedProgramTypeFromJson(
  Object? purchasedProgramType, [
  enums.PurchasedProgramType? defaultValue,
]) {
  return enums.PurchasedProgramType.values
          .firstWhereOrNull((e) => e.value == purchasedProgramType) ??
      defaultValue ??
      enums.PurchasedProgramType.swaggerGeneratedUnknown;
}

List<String> purchasedProgramTypeListToJson(
    List<enums.PurchasedProgramType>? purchasedProgramType) {
  if (purchasedProgramType == null) {
    return [];
  }

  return purchasedProgramType.map((e) => e.value!).toList();
}

List<enums.PurchasedProgramType> purchasedProgramTypeListFromJson(
  List? purchasedProgramType, [
  List<enums.PurchasedProgramType>? defaultValue,
]) {
  if (purchasedProgramType == null) {
    return defaultValue ?? [];
  }

  return purchasedProgramType
      .map((e) => purchasedProgramTypeFromJson(e.toString()))
      .toList();
}

List<enums.PurchasedProgramType>? purchasedProgramTypeNullableListFromJson(
  List? purchasedProgramType, [
  List<enums.PurchasedProgramType>? defaultValue,
]) {
  if (purchasedProgramType == null) {
    return defaultValue;
  }

  return purchasedProgramType
      .map((e) => purchasedProgramTypeFromJson(e.toString()))
      .toList();
}

String? itemTypeToJson(enums.ItemType? itemType) {
  return itemType?.value;
}

enums.ItemType itemTypeFromJson(
  Object? itemType, [
  enums.ItemType? defaultValue,
]) {
  return enums.ItemType.values.firstWhereOrNull((e) => e.value == itemType) ??
      defaultValue ??
      enums.ItemType.swaggerGeneratedUnknown;
}

List<String> itemTypeListToJson(List<enums.ItemType>? itemType) {
  if (itemType == null) {
    return [];
  }

  return itemType.map((e) => e.value!).toList();
}

List<enums.ItemType> itemTypeListFromJson(
  List? itemType, [
  List<enums.ItemType>? defaultValue,
]) {
  if (itemType == null) {
    return defaultValue ?? [];
  }

  return itemType.map((e) => itemTypeFromJson(e.toString())).toList();
}

List<enums.ItemType>? itemTypeNullableListFromJson(
  List? itemType, [
  List<enums.ItemType>? defaultValue,
]) {
  if (itemType == null) {
    return defaultValue;
  }

  return itemType.map((e) => itemTypeFromJson(e.toString())).toList();
}

String? itemAssetTypeToJson(enums.ItemAssetType? itemAssetType) {
  return itemAssetType?.value;
}

enums.ItemAssetType itemAssetTypeFromJson(
  Object? itemAssetType, [
  enums.ItemAssetType? defaultValue,
]) {
  return enums.ItemAssetType.values
          .firstWhereOrNull((e) => e.value == itemAssetType) ??
      defaultValue ??
      enums.ItemAssetType.swaggerGeneratedUnknown;
}

List<String> itemAssetTypeListToJson(List<enums.ItemAssetType>? itemAssetType) {
  if (itemAssetType == null) {
    return [];
  }

  return itemAssetType.map((e) => e.value!).toList();
}

List<enums.ItemAssetType> itemAssetTypeListFromJson(
  List? itemAssetType, [
  List<enums.ItemAssetType>? defaultValue,
]) {
  if (itemAssetType == null) {
    return defaultValue ?? [];
  }

  return itemAssetType.map((e) => itemAssetTypeFromJson(e.toString())).toList();
}

List<enums.ItemAssetType>? itemAssetTypeNullableListFromJson(
  List? itemAssetType, [
  List<enums.ItemAssetType>? defaultValue,
]) {
  if (itemAssetType == null) {
    return defaultValue;
  }

  return itemAssetType.map((e) => itemAssetTypeFromJson(e.toString())).toList();
}

String? itemMinResolutionToJson(enums.ItemMinResolution? itemMinResolution) {
  return itemMinResolution?.value;
}

enums.ItemMinResolution itemMinResolutionFromJson(
  Object? itemMinResolution, [
  enums.ItemMinResolution? defaultValue,
]) {
  return enums.ItemMinResolution.values
          .firstWhereOrNull((e) => e.value == itemMinResolution) ??
      defaultValue ??
      enums.ItemMinResolution.swaggerGeneratedUnknown;
}

List<String> itemMinResolutionListToJson(
    List<enums.ItemMinResolution>? itemMinResolution) {
  if (itemMinResolution == null) {
    return [];
  }

  return itemMinResolution.map((e) => e.value!).toList();
}

List<enums.ItemMinResolution> itemMinResolutionListFromJson(
  List? itemMinResolution, [
  List<enums.ItemMinResolution>? defaultValue,
]) {
  if (itemMinResolution == null) {
    return defaultValue ?? [];
  }

  return itemMinResolution
      .map((e) => itemMinResolutionFromJson(e.toString()))
      .toList();
}

List<enums.ItemMinResolution>? itemMinResolutionNullableListFromJson(
  List? itemMinResolution, [
  List<enums.ItemMinResolution>? defaultValue,
]) {
  if (itemMinResolution == null) {
    return defaultValue;
  }

  return itemMinResolution
      .map((e) => itemMinResolutionFromJson(e.toString()))
      .toList();
}

String? detailScreenTypeToJson(enums.DetailScreenType? detailScreenType) {
  return detailScreenType?.value;
}

enums.DetailScreenType detailScreenTypeFromJson(
  Object? detailScreenType, [
  enums.DetailScreenType? defaultValue,
]) {
  return enums.DetailScreenType.values
          .firstWhereOrNull((e) => e.value == detailScreenType) ??
      defaultValue ??
      enums.DetailScreenType.swaggerGeneratedUnknown;
}

List<String> detailScreenTypeListToJson(
    List<enums.DetailScreenType>? detailScreenType) {
  if (detailScreenType == null) {
    return [];
  }

  return detailScreenType.map((e) => e.value!).toList();
}

List<enums.DetailScreenType> detailScreenTypeListFromJson(
  List? detailScreenType, [
  List<enums.DetailScreenType>? defaultValue,
]) {
  if (detailScreenType == null) {
    return defaultValue ?? [];
  }

  return detailScreenType
      .map((e) => detailScreenTypeFromJson(e.toString()))
      .toList();
}

List<enums.DetailScreenType>? detailScreenTypeNullableListFromJson(
  List? detailScreenType, [
  List<enums.DetailScreenType>? defaultValue,
]) {
  if (detailScreenType == null) {
    return defaultValue;
  }

  return detailScreenType
      .map((e) => detailScreenTypeFromJson(e.toString()))
      .toList();
}

String? detailScreenAssetTypeToJson(
    enums.DetailScreenAssetType? detailScreenAssetType) {
  return detailScreenAssetType?.value;
}

enums.DetailScreenAssetType detailScreenAssetTypeFromJson(
  Object? detailScreenAssetType, [
  enums.DetailScreenAssetType? defaultValue,
]) {
  return enums.DetailScreenAssetType.values
          .firstWhereOrNull((e) => e.value == detailScreenAssetType) ??
      defaultValue ??
      enums.DetailScreenAssetType.swaggerGeneratedUnknown;
}

List<String> detailScreenAssetTypeListToJson(
    List<enums.DetailScreenAssetType>? detailScreenAssetType) {
  if (detailScreenAssetType == null) {
    return [];
  }

  return detailScreenAssetType.map((e) => e.value!).toList();
}

List<enums.DetailScreenAssetType> detailScreenAssetTypeListFromJson(
  List? detailScreenAssetType, [
  List<enums.DetailScreenAssetType>? defaultValue,
]) {
  if (detailScreenAssetType == null) {
    return defaultValue ?? [];
  }

  return detailScreenAssetType
      .map((e) => detailScreenAssetTypeFromJson(e.toString()))
      .toList();
}

List<enums.DetailScreenAssetType>? detailScreenAssetTypeNullableListFromJson(
  List? detailScreenAssetType, [
  List<enums.DetailScreenAssetType>? defaultValue,
]) {
  if (detailScreenAssetType == null) {
    return defaultValue;
  }

  return detailScreenAssetType
      .map((e) => detailScreenAssetTypeFromJson(e.toString()))
      .toList();
}

String? detailScreenMinResolutionToJson(
    enums.DetailScreenMinResolution? detailScreenMinResolution) {
  return detailScreenMinResolution?.value;
}

enums.DetailScreenMinResolution detailScreenMinResolutionFromJson(
  Object? detailScreenMinResolution, [
  enums.DetailScreenMinResolution? defaultValue,
]) {
  return enums.DetailScreenMinResolution.values
          .firstWhereOrNull((e) => e.value == detailScreenMinResolution) ??
      defaultValue ??
      enums.DetailScreenMinResolution.swaggerGeneratedUnknown;
}

List<String> detailScreenMinResolutionListToJson(
    List<enums.DetailScreenMinResolution>? detailScreenMinResolution) {
  if (detailScreenMinResolution == null) {
    return [];
  }

  return detailScreenMinResolution.map((e) => e.value!).toList();
}

List<enums.DetailScreenMinResolution> detailScreenMinResolutionListFromJson(
  List? detailScreenMinResolution, [
  List<enums.DetailScreenMinResolution>? defaultValue,
]) {
  if (detailScreenMinResolution == null) {
    return defaultValue ?? [];
  }

  return detailScreenMinResolution
      .map((e) => detailScreenMinResolutionFromJson(e.toString()))
      .toList();
}

List<enums.DetailScreenMinResolution>?
    detailScreenMinResolutionNullableListFromJson(
  List? detailScreenMinResolution, [
  List<enums.DetailScreenMinResolution>? defaultValue,
]) {
  if (detailScreenMinResolution == null) {
    return defaultValue;
  }

  return detailScreenMinResolution
      .map((e) => detailScreenMinResolutionFromJson(e.toString()))
      .toList();
}

String? sourceExtSourceTypeToJson(
    enums.SourceExtSourceType? sourceExtSourceType) {
  return sourceExtSourceType?.value;
}

enums.SourceExtSourceType sourceExtSourceTypeFromJson(
  Object? sourceExtSourceType, [
  enums.SourceExtSourceType? defaultValue,
]) {
  return enums.SourceExtSourceType.values
          .firstWhereOrNull((e) => e.value == sourceExtSourceType) ??
      defaultValue ??
      enums.SourceExtSourceType.swaggerGeneratedUnknown;
}

List<String> sourceExtSourceTypeListToJson(
    List<enums.SourceExtSourceType>? sourceExtSourceType) {
  if (sourceExtSourceType == null) {
    return [];
  }

  return sourceExtSourceType.map((e) => e.value!).toList();
}

List<enums.SourceExtSourceType> sourceExtSourceTypeListFromJson(
  List? sourceExtSourceType, [
  List<enums.SourceExtSourceType>? defaultValue,
]) {
  if (sourceExtSourceType == null) {
    return defaultValue ?? [];
  }

  return sourceExtSourceType
      .map((e) => sourceExtSourceTypeFromJson(e.toString()))
      .toList();
}

List<enums.SourceExtSourceType>? sourceExtSourceTypeNullableListFromJson(
  List? sourceExtSourceType, [
  List<enums.SourceExtSourceType>? defaultValue,
]) {
  if (sourceExtSourceType == null) {
    return defaultValue;
  }

  return sourceExtSourceType
      .map((e) => sourceExtSourceTypeFromJson(e.toString()))
      .toList();
}

String? sourceOttSourceTypeToJson(
    enums.SourceOttSourceType? sourceOttSourceType) {
  return sourceOttSourceType?.value;
}

enums.SourceOttSourceType sourceOttSourceTypeFromJson(
  Object? sourceOttSourceType, [
  enums.SourceOttSourceType? defaultValue,
]) {
  return enums.SourceOttSourceType.values
          .firstWhereOrNull((e) => e.value == sourceOttSourceType) ??
      defaultValue ??
      enums.SourceOttSourceType.swaggerGeneratedUnknown;
}

List<String> sourceOttSourceTypeListToJson(
    List<enums.SourceOttSourceType>? sourceOttSourceType) {
  if (sourceOttSourceType == null) {
    return [];
  }

  return sourceOttSourceType.map((e) => e.value!).toList();
}

List<enums.SourceOttSourceType> sourceOttSourceTypeListFromJson(
  List? sourceOttSourceType, [
  List<enums.SourceOttSourceType>? defaultValue,
]) {
  if (sourceOttSourceType == null) {
    return defaultValue ?? [];
  }

  return sourceOttSourceType
      .map((e) => sourceOttSourceTypeFromJson(e.toString()))
      .toList();
}

List<enums.SourceOttSourceType>? sourceOttSourceTypeNullableListFromJson(
  List? sourceOttSourceType, [
  List<enums.SourceOttSourceType>? defaultValue,
]) {
  if (sourceOttSourceType == null) {
    return defaultValue;
  }

  return sourceOttSourceType
      .map((e) => sourceOttSourceTypeFromJson(e.toString()))
      .toList();
}

String? feedComposerV1MoreLikeWatchedFromFeedFeedCridGetEncodingToJson(
    enums.FeedComposerV1MoreLikeWatchedFromFeedFeedCridGetEncoding?
        feedComposerV1MoreLikeWatchedFromFeedFeedCridGetEncoding) {
  return feedComposerV1MoreLikeWatchedFromFeedFeedCridGetEncoding?.value;
}

enums.FeedComposerV1MoreLikeWatchedFromFeedFeedCridGetEncoding
    feedComposerV1MoreLikeWatchedFromFeedFeedCridGetEncodingFromJson(
  Object? feedComposerV1MoreLikeWatchedFromFeedFeedCridGetEncoding, [
  enums.FeedComposerV1MoreLikeWatchedFromFeedFeedCridGetEncoding? defaultValue,
]) {
  return enums.FeedComposerV1MoreLikeWatchedFromFeedFeedCridGetEncoding.values
          .firstWhereOrNull((e) =>
              e.value ==
              feedComposerV1MoreLikeWatchedFromFeedFeedCridGetEncoding) ??
      defaultValue ??
      enums.FeedComposerV1MoreLikeWatchedFromFeedFeedCridGetEncoding
          .swaggerGeneratedUnknown;
}

List<String> feedComposerV1MoreLikeWatchedFromFeedFeedCridGetEncodingListToJson(
    List<enums.FeedComposerV1MoreLikeWatchedFromFeedFeedCridGetEncoding>?
        feedComposerV1MoreLikeWatchedFromFeedFeedCridGetEncoding) {
  if (feedComposerV1MoreLikeWatchedFromFeedFeedCridGetEncoding == null) {
    return [];
  }

  return feedComposerV1MoreLikeWatchedFromFeedFeedCridGetEncoding
      .map((e) => e.value!)
      .toList();
}

List<enums.FeedComposerV1MoreLikeWatchedFromFeedFeedCridGetEncoding>
    feedComposerV1MoreLikeWatchedFromFeedFeedCridGetEncodingListFromJson(
  List? feedComposerV1MoreLikeWatchedFromFeedFeedCridGetEncoding, [
  List<enums.FeedComposerV1MoreLikeWatchedFromFeedFeedCridGetEncoding>?
      defaultValue,
]) {
  if (feedComposerV1MoreLikeWatchedFromFeedFeedCridGetEncoding == null) {
    return defaultValue ?? [];
  }

  return feedComposerV1MoreLikeWatchedFromFeedFeedCridGetEncoding
      .map((e) =>
          feedComposerV1MoreLikeWatchedFromFeedFeedCridGetEncodingFromJson(
              e.toString()))
      .toList();
}

List<enums.FeedComposerV1MoreLikeWatchedFromFeedFeedCridGetEncoding>?
    feedComposerV1MoreLikeWatchedFromFeedFeedCridGetEncodingNullableListFromJson(
  List? feedComposerV1MoreLikeWatchedFromFeedFeedCridGetEncoding, [
  List<enums.FeedComposerV1MoreLikeWatchedFromFeedFeedCridGetEncoding>?
      defaultValue,
]) {
  if (feedComposerV1MoreLikeWatchedFromFeedFeedCridGetEncoding == null) {
    return defaultValue;
  }

  return feedComposerV1MoreLikeWatchedFromFeedFeedCridGetEncoding
      .map((e) =>
          feedComposerV1MoreLikeWatchedFromFeedFeedCridGetEncodingFromJson(
              e.toString()))
      .toList();
}

String? feedComposerV1MoreLikeWatchedFromFeedFeedCridGetMaxResToJson(
    enums.FeedComposerV1MoreLikeWatchedFromFeedFeedCridGetMaxRes?
        feedComposerV1MoreLikeWatchedFromFeedFeedCridGetMaxRes) {
  return feedComposerV1MoreLikeWatchedFromFeedFeedCridGetMaxRes?.value;
}

enums.FeedComposerV1MoreLikeWatchedFromFeedFeedCridGetMaxRes
    feedComposerV1MoreLikeWatchedFromFeedFeedCridGetMaxResFromJson(
  Object? feedComposerV1MoreLikeWatchedFromFeedFeedCridGetMaxRes, [
  enums.FeedComposerV1MoreLikeWatchedFromFeedFeedCridGetMaxRes? defaultValue,
]) {
  return enums.FeedComposerV1MoreLikeWatchedFromFeedFeedCridGetMaxRes.values
          .firstWhereOrNull((e) =>
              e.value ==
              feedComposerV1MoreLikeWatchedFromFeedFeedCridGetMaxRes) ??
      defaultValue ??
      enums.FeedComposerV1MoreLikeWatchedFromFeedFeedCridGetMaxRes
          .swaggerGeneratedUnknown;
}

List<String> feedComposerV1MoreLikeWatchedFromFeedFeedCridGetMaxResListToJson(
    List<enums.FeedComposerV1MoreLikeWatchedFromFeedFeedCridGetMaxRes>?
        feedComposerV1MoreLikeWatchedFromFeedFeedCridGetMaxRes) {
  if (feedComposerV1MoreLikeWatchedFromFeedFeedCridGetMaxRes == null) {
    return [];
  }

  return feedComposerV1MoreLikeWatchedFromFeedFeedCridGetMaxRes
      .map((e) => e.value!)
      .toList();
}

List<enums.FeedComposerV1MoreLikeWatchedFromFeedFeedCridGetMaxRes>
    feedComposerV1MoreLikeWatchedFromFeedFeedCridGetMaxResListFromJson(
  List? feedComposerV1MoreLikeWatchedFromFeedFeedCridGetMaxRes, [
  List<enums.FeedComposerV1MoreLikeWatchedFromFeedFeedCridGetMaxRes>?
      defaultValue,
]) {
  if (feedComposerV1MoreLikeWatchedFromFeedFeedCridGetMaxRes == null) {
    return defaultValue ?? [];
  }

  return feedComposerV1MoreLikeWatchedFromFeedFeedCridGetMaxRes
      .map((e) =>
          feedComposerV1MoreLikeWatchedFromFeedFeedCridGetMaxResFromJson(
              e.toString()))
      .toList();
}

List<enums.FeedComposerV1MoreLikeWatchedFromFeedFeedCridGetMaxRes>?
    feedComposerV1MoreLikeWatchedFromFeedFeedCridGetMaxResNullableListFromJson(
  List? feedComposerV1MoreLikeWatchedFromFeedFeedCridGetMaxRes, [
  List<enums.FeedComposerV1MoreLikeWatchedFromFeedFeedCridGetMaxRes>?
      defaultValue,
]) {
  if (feedComposerV1MoreLikeWatchedFromFeedFeedCridGetMaxRes == null) {
    return defaultValue;
  }

  return feedComposerV1MoreLikeWatchedFromFeedFeedCridGetMaxRes
      .map((e) =>
          feedComposerV1MoreLikeWatchedFromFeedFeedCridGetMaxResFromJson(
              e.toString()))
      .toList();
}

String? feedComposerV1PausedItemsGetEncodingToJson(
    enums.FeedComposerV1PausedItemsGetEncoding?
        feedComposerV1PausedItemsGetEncoding) {
  return feedComposerV1PausedItemsGetEncoding?.value;
}

enums.FeedComposerV1PausedItemsGetEncoding
    feedComposerV1PausedItemsGetEncodingFromJson(
  Object? feedComposerV1PausedItemsGetEncoding, [
  enums.FeedComposerV1PausedItemsGetEncoding? defaultValue,
]) {
  return enums.FeedComposerV1PausedItemsGetEncoding.values.firstWhereOrNull(
          (e) => e.value == feedComposerV1PausedItemsGetEncoding) ??
      defaultValue ??
      enums.FeedComposerV1PausedItemsGetEncoding.swaggerGeneratedUnknown;
}

List<String> feedComposerV1PausedItemsGetEncodingListToJson(
    List<enums.FeedComposerV1PausedItemsGetEncoding>?
        feedComposerV1PausedItemsGetEncoding) {
  if (feedComposerV1PausedItemsGetEncoding == null) {
    return [];
  }

  return feedComposerV1PausedItemsGetEncoding.map((e) => e.value!).toList();
}

List<enums.FeedComposerV1PausedItemsGetEncoding>
    feedComposerV1PausedItemsGetEncodingListFromJson(
  List? feedComposerV1PausedItemsGetEncoding, [
  List<enums.FeedComposerV1PausedItemsGetEncoding>? defaultValue,
]) {
  if (feedComposerV1PausedItemsGetEncoding == null) {
    return defaultValue ?? [];
  }

  return feedComposerV1PausedItemsGetEncoding
      .map((e) => feedComposerV1PausedItemsGetEncodingFromJson(e.toString()))
      .toList();
}

List<enums.FeedComposerV1PausedItemsGetEncoding>?
    feedComposerV1PausedItemsGetEncodingNullableListFromJson(
  List? feedComposerV1PausedItemsGetEncoding, [
  List<enums.FeedComposerV1PausedItemsGetEncoding>? defaultValue,
]) {
  if (feedComposerV1PausedItemsGetEncoding == null) {
    return defaultValue;
  }

  return feedComposerV1PausedItemsGetEncoding
      .map((e) => feedComposerV1PausedItemsGetEncodingFromJson(e.toString()))
      .toList();
}

String? feedComposerV1PausedItemsGetMaxResToJson(
    enums.FeedComposerV1PausedItemsGetMaxRes?
        feedComposerV1PausedItemsGetMaxRes) {
  return feedComposerV1PausedItemsGetMaxRes?.value;
}

enums.FeedComposerV1PausedItemsGetMaxRes
    feedComposerV1PausedItemsGetMaxResFromJson(
  Object? feedComposerV1PausedItemsGetMaxRes, [
  enums.FeedComposerV1PausedItemsGetMaxRes? defaultValue,
]) {
  return enums.FeedComposerV1PausedItemsGetMaxRes.values.firstWhereOrNull(
          (e) => e.value == feedComposerV1PausedItemsGetMaxRes) ??
      defaultValue ??
      enums.FeedComposerV1PausedItemsGetMaxRes.swaggerGeneratedUnknown;
}

List<String> feedComposerV1PausedItemsGetMaxResListToJson(
    List<enums.FeedComposerV1PausedItemsGetMaxRes>?
        feedComposerV1PausedItemsGetMaxRes) {
  if (feedComposerV1PausedItemsGetMaxRes == null) {
    return [];
  }

  return feedComposerV1PausedItemsGetMaxRes.map((e) => e.value!).toList();
}

List<enums.FeedComposerV1PausedItemsGetMaxRes>
    feedComposerV1PausedItemsGetMaxResListFromJson(
  List? feedComposerV1PausedItemsGetMaxRes, [
  List<enums.FeedComposerV1PausedItemsGetMaxRes>? defaultValue,
]) {
  if (feedComposerV1PausedItemsGetMaxRes == null) {
    return defaultValue ?? [];
  }

  return feedComposerV1PausedItemsGetMaxRes
      .map((e) => feedComposerV1PausedItemsGetMaxResFromJson(e.toString()))
      .toList();
}

List<enums.FeedComposerV1PausedItemsGetMaxRes>?
    feedComposerV1PausedItemsGetMaxResNullableListFromJson(
  List? feedComposerV1PausedItemsGetMaxRes, [
  List<enums.FeedComposerV1PausedItemsGetMaxRes>? defaultValue,
]) {
  if (feedComposerV1PausedItemsGetMaxRes == null) {
    return defaultValue;
  }

  return feedComposerV1PausedItemsGetMaxRes
      .map((e) => feedComposerV1PausedItemsGetMaxResFromJson(e.toString()))
      .toList();
}

String? feedComposerV1PurchasedItemsGetEncodingToJson(
    enums.FeedComposerV1PurchasedItemsGetEncoding?
        feedComposerV1PurchasedItemsGetEncoding) {
  return feedComposerV1PurchasedItemsGetEncoding?.value;
}

enums.FeedComposerV1PurchasedItemsGetEncoding
    feedComposerV1PurchasedItemsGetEncodingFromJson(
  Object? feedComposerV1PurchasedItemsGetEncoding, [
  enums.FeedComposerV1PurchasedItemsGetEncoding? defaultValue,
]) {
  return enums.FeedComposerV1PurchasedItemsGetEncoding.values.firstWhereOrNull(
          (e) => e.value == feedComposerV1PurchasedItemsGetEncoding) ??
      defaultValue ??
      enums.FeedComposerV1PurchasedItemsGetEncoding.swaggerGeneratedUnknown;
}

List<String> feedComposerV1PurchasedItemsGetEncodingListToJson(
    List<enums.FeedComposerV1PurchasedItemsGetEncoding>?
        feedComposerV1PurchasedItemsGetEncoding) {
  if (feedComposerV1PurchasedItemsGetEncoding == null) {
    return [];
  }

  return feedComposerV1PurchasedItemsGetEncoding.map((e) => e.value!).toList();
}

List<enums.FeedComposerV1PurchasedItemsGetEncoding>
    feedComposerV1PurchasedItemsGetEncodingListFromJson(
  List? feedComposerV1PurchasedItemsGetEncoding, [
  List<enums.FeedComposerV1PurchasedItemsGetEncoding>? defaultValue,
]) {
  if (feedComposerV1PurchasedItemsGetEncoding == null) {
    return defaultValue ?? [];
  }

  return feedComposerV1PurchasedItemsGetEncoding
      .map((e) => feedComposerV1PurchasedItemsGetEncodingFromJson(e.toString()))
      .toList();
}

List<enums.FeedComposerV1PurchasedItemsGetEncoding>?
    feedComposerV1PurchasedItemsGetEncodingNullableListFromJson(
  List? feedComposerV1PurchasedItemsGetEncoding, [
  List<enums.FeedComposerV1PurchasedItemsGetEncoding>? defaultValue,
]) {
  if (feedComposerV1PurchasedItemsGetEncoding == null) {
    return defaultValue;
  }

  return feedComposerV1PurchasedItemsGetEncoding
      .map((e) => feedComposerV1PurchasedItemsGetEncodingFromJson(e.toString()))
      .toList();
}

String? feedComposerV1PurchasedItemsGetMaxResToJson(
    enums.FeedComposerV1PurchasedItemsGetMaxRes?
        feedComposerV1PurchasedItemsGetMaxRes) {
  return feedComposerV1PurchasedItemsGetMaxRes?.value;
}

enums.FeedComposerV1PurchasedItemsGetMaxRes
    feedComposerV1PurchasedItemsGetMaxResFromJson(
  Object? feedComposerV1PurchasedItemsGetMaxRes, [
  enums.FeedComposerV1PurchasedItemsGetMaxRes? defaultValue,
]) {
  return enums.FeedComposerV1PurchasedItemsGetMaxRes.values.firstWhereOrNull(
          (e) => e.value == feedComposerV1PurchasedItemsGetMaxRes) ??
      defaultValue ??
      enums.FeedComposerV1PurchasedItemsGetMaxRes.swaggerGeneratedUnknown;
}

List<String> feedComposerV1PurchasedItemsGetMaxResListToJson(
    List<enums.FeedComposerV1PurchasedItemsGetMaxRes>?
        feedComposerV1PurchasedItemsGetMaxRes) {
  if (feedComposerV1PurchasedItemsGetMaxRes == null) {
    return [];
  }

  return feedComposerV1PurchasedItemsGetMaxRes.map((e) => e.value!).toList();
}

List<enums.FeedComposerV1PurchasedItemsGetMaxRes>
    feedComposerV1PurchasedItemsGetMaxResListFromJson(
  List? feedComposerV1PurchasedItemsGetMaxRes, [
  List<enums.FeedComposerV1PurchasedItemsGetMaxRes>? defaultValue,
]) {
  if (feedComposerV1PurchasedItemsGetMaxRes == null) {
    return defaultValue ?? [];
  }

  return feedComposerV1PurchasedItemsGetMaxRes
      .map((e) => feedComposerV1PurchasedItemsGetMaxResFromJson(e.toString()))
      .toList();
}

List<enums.FeedComposerV1PurchasedItemsGetMaxRes>?
    feedComposerV1PurchasedItemsGetMaxResNullableListFromJson(
  List? feedComposerV1PurchasedItemsGetMaxRes, [
  List<enums.FeedComposerV1PurchasedItemsGetMaxRes>? defaultValue,
]) {
  if (feedComposerV1PurchasedItemsGetMaxRes == null) {
    return defaultValue;
  }

  return feedComposerV1PurchasedItemsGetMaxRes
      .map((e) => feedComposerV1PurchasedItemsGetMaxResFromJson(e.toString()))
      .toList();
}

String? feedComposerV1SuggestedFromContentAreaAreaCridGetEncodingToJson(
    enums.FeedComposerV1SuggestedFromContentAreaAreaCridGetEncoding?
        feedComposerV1SuggestedFromContentAreaAreaCridGetEncoding) {
  return feedComposerV1SuggestedFromContentAreaAreaCridGetEncoding?.value;
}

enums.FeedComposerV1SuggestedFromContentAreaAreaCridGetEncoding
    feedComposerV1SuggestedFromContentAreaAreaCridGetEncodingFromJson(
  Object? feedComposerV1SuggestedFromContentAreaAreaCridGetEncoding, [
  enums.FeedComposerV1SuggestedFromContentAreaAreaCridGetEncoding? defaultValue,
]) {
  return enums.FeedComposerV1SuggestedFromContentAreaAreaCridGetEncoding.values
          .firstWhereOrNull((e) =>
              e.value ==
              feedComposerV1SuggestedFromContentAreaAreaCridGetEncoding) ??
      defaultValue ??
      enums.FeedComposerV1SuggestedFromContentAreaAreaCridGetEncoding
          .swaggerGeneratedUnknown;
}

List<String>
    feedComposerV1SuggestedFromContentAreaAreaCridGetEncodingListToJson(
        List<enums.FeedComposerV1SuggestedFromContentAreaAreaCridGetEncoding>?
            feedComposerV1SuggestedFromContentAreaAreaCridGetEncoding) {
  if (feedComposerV1SuggestedFromContentAreaAreaCridGetEncoding == null) {
    return [];
  }

  return feedComposerV1SuggestedFromContentAreaAreaCridGetEncoding
      .map((e) => e.value!)
      .toList();
}

List<enums.FeedComposerV1SuggestedFromContentAreaAreaCridGetEncoding>
    feedComposerV1SuggestedFromContentAreaAreaCridGetEncodingListFromJson(
  List? feedComposerV1SuggestedFromContentAreaAreaCridGetEncoding, [
  List<enums.FeedComposerV1SuggestedFromContentAreaAreaCridGetEncoding>?
      defaultValue,
]) {
  if (feedComposerV1SuggestedFromContentAreaAreaCridGetEncoding == null) {
    return defaultValue ?? [];
  }

  return feedComposerV1SuggestedFromContentAreaAreaCridGetEncoding
      .map((e) =>
          feedComposerV1SuggestedFromContentAreaAreaCridGetEncodingFromJson(
              e.toString()))
      .toList();
}

List<enums.FeedComposerV1SuggestedFromContentAreaAreaCridGetEncoding>?
    feedComposerV1SuggestedFromContentAreaAreaCridGetEncodingNullableListFromJson(
  List? feedComposerV1SuggestedFromContentAreaAreaCridGetEncoding, [
  List<enums.FeedComposerV1SuggestedFromContentAreaAreaCridGetEncoding>?
      defaultValue,
]) {
  if (feedComposerV1SuggestedFromContentAreaAreaCridGetEncoding == null) {
    return defaultValue;
  }

  return feedComposerV1SuggestedFromContentAreaAreaCridGetEncoding
      .map((e) =>
          feedComposerV1SuggestedFromContentAreaAreaCridGetEncodingFromJson(
              e.toString()))
      .toList();
}

String? feedComposerV1SuggestedFromContentAreaAreaCridGetMaxResToJson(
    enums.FeedComposerV1SuggestedFromContentAreaAreaCridGetMaxRes?
        feedComposerV1SuggestedFromContentAreaAreaCridGetMaxRes) {
  return feedComposerV1SuggestedFromContentAreaAreaCridGetMaxRes?.value;
}

enums.FeedComposerV1SuggestedFromContentAreaAreaCridGetMaxRes
    feedComposerV1SuggestedFromContentAreaAreaCridGetMaxResFromJson(
  Object? feedComposerV1SuggestedFromContentAreaAreaCridGetMaxRes, [
  enums.FeedComposerV1SuggestedFromContentAreaAreaCridGetMaxRes? defaultValue,
]) {
  return enums.FeedComposerV1SuggestedFromContentAreaAreaCridGetMaxRes.values
          .firstWhereOrNull((e) =>
              e.value ==
              feedComposerV1SuggestedFromContentAreaAreaCridGetMaxRes) ??
      defaultValue ??
      enums.FeedComposerV1SuggestedFromContentAreaAreaCridGetMaxRes
          .swaggerGeneratedUnknown;
}

List<String> feedComposerV1SuggestedFromContentAreaAreaCridGetMaxResListToJson(
    List<enums.FeedComposerV1SuggestedFromContentAreaAreaCridGetMaxRes>?
        feedComposerV1SuggestedFromContentAreaAreaCridGetMaxRes) {
  if (feedComposerV1SuggestedFromContentAreaAreaCridGetMaxRes == null) {
    return [];
  }

  return feedComposerV1SuggestedFromContentAreaAreaCridGetMaxRes
      .map((e) => e.value!)
      .toList();
}

List<enums.FeedComposerV1SuggestedFromContentAreaAreaCridGetMaxRes>
    feedComposerV1SuggestedFromContentAreaAreaCridGetMaxResListFromJson(
  List? feedComposerV1SuggestedFromContentAreaAreaCridGetMaxRes, [
  List<enums.FeedComposerV1SuggestedFromContentAreaAreaCridGetMaxRes>?
      defaultValue,
]) {
  if (feedComposerV1SuggestedFromContentAreaAreaCridGetMaxRes == null) {
    return defaultValue ?? [];
  }

  return feedComposerV1SuggestedFromContentAreaAreaCridGetMaxRes
      .map((e) =>
          feedComposerV1SuggestedFromContentAreaAreaCridGetMaxResFromJson(
              e.toString()))
      .toList();
}

List<enums.FeedComposerV1SuggestedFromContentAreaAreaCridGetMaxRes>?
    feedComposerV1SuggestedFromContentAreaAreaCridGetMaxResNullableListFromJson(
  List? feedComposerV1SuggestedFromContentAreaAreaCridGetMaxRes, [
  List<enums.FeedComposerV1SuggestedFromContentAreaAreaCridGetMaxRes>?
      defaultValue,
]) {
  if (feedComposerV1SuggestedFromContentAreaAreaCridGetMaxRes == null) {
    return defaultValue;
  }

  return feedComposerV1SuggestedFromContentAreaAreaCridGetMaxRes
      .map((e) =>
          feedComposerV1SuggestedFromContentAreaAreaCridGetMaxResFromJson(
              e.toString()))
      .toList();
}

String? feedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetEncodingToJson(
    enums.FeedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetEncoding?
        feedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetEncoding) {
  return feedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetEncoding
      ?.value;
}

enums.FeedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetEncoding
    feedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetEncodingFromJson(
  Object?
      feedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetEncoding, [
  enums.FeedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetEncoding?
      defaultValue,
]) {
  return enums
          .FeedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetEncoding
          .values
          .firstWhereOrNull((e) =>
              e.value ==
              feedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetEncoding) ??
      defaultValue ??
      enums
          .FeedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetEncoding
          .swaggerGeneratedUnknown;
}

List<String>
    feedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetEncodingListToJson(
        List<enums.FeedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetEncoding>?
            feedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetEncoding) {
  if (feedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetEncoding ==
      null) {
    return [];
  }

  return feedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetEncoding
      .map((e) => e.value!)
      .toList();
}

List<enums.FeedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetEncoding>
    feedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetEncodingListFromJson(
  List?
      feedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetEncoding, [
  List<enums.FeedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetEncoding>?
      defaultValue,
]) {
  if (feedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetEncoding ==
      null) {
    return defaultValue ?? [];
  }

  return feedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetEncoding
      .map((e) =>
          feedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetEncodingFromJson(
              e.toString()))
      .toList();
}

List<enums.FeedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetEncoding>?
    feedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetEncodingNullableListFromJson(
  List?
      feedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetEncoding, [
  List<enums.FeedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetEncoding>?
      defaultValue,
]) {
  if (feedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetEncoding ==
      null) {
    return defaultValue;
  }

  return feedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetEncoding
      .map((e) =>
          feedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetEncodingFromJson(
              e.toString()))
      .toList();
}

String? feedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetMaxResToJson(
    enums.FeedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetMaxRes?
        feedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetMaxRes) {
  return feedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetMaxRes
      ?.value;
}

enums.FeedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetMaxRes
    feedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetMaxResFromJson(
  Object?
      feedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetMaxRes, [
  enums.FeedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetMaxRes?
      defaultValue,
]) {
  return enums
          .FeedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetMaxRes
          .values
          .firstWhereOrNull((e) =>
              e.value ==
              feedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetMaxRes) ??
      defaultValue ??
      enums
          .FeedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetMaxRes
          .swaggerGeneratedUnknown;
}

List<String>
    feedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetMaxResListToJson(
        List<enums.FeedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetMaxRes>?
            feedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetMaxRes) {
  if (feedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetMaxRes ==
      null) {
    return [];
  }

  return feedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetMaxRes
      .map((e) => e.value!)
      .toList();
}

List<enums.FeedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetMaxRes>
    feedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetMaxResListFromJson(
  List? feedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetMaxRes, [
  List<enums.FeedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetMaxRes>?
      defaultValue,
]) {
  if (feedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetMaxRes ==
      null) {
    return defaultValue ?? [];
  }

  return feedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetMaxRes
      .map((e) =>
          feedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetMaxResFromJson(
              e.toString()))
      .toList();
}

List<enums.FeedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetMaxRes>?
    feedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetMaxResNullableListFromJson(
  List? feedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetMaxRes, [
  List<enums.FeedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetMaxRes>?
      defaultValue,
]) {
  if (feedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetMaxRes ==
      null) {
    return defaultValue;
  }

  return feedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetMaxRes
      .map((e) =>
          feedComposerV1SuggestedFromContentAreaByWatchedGenreAreaCridGetMaxResFromJson(
              e.toString()))
      .toList();
}

String? feedComposerV1TopListTopListIdGetEncodingToJson(
    enums.FeedComposerV1TopListTopListIdGetEncoding?
        feedComposerV1TopListTopListIdGetEncoding) {
  return feedComposerV1TopListTopListIdGetEncoding?.value;
}

enums.FeedComposerV1TopListTopListIdGetEncoding
    feedComposerV1TopListTopListIdGetEncodingFromJson(
  Object? feedComposerV1TopListTopListIdGetEncoding, [
  enums.FeedComposerV1TopListTopListIdGetEncoding? defaultValue,
]) {
  return enums.FeedComposerV1TopListTopListIdGetEncoding.values
          .firstWhereOrNull(
              (e) => e.value == feedComposerV1TopListTopListIdGetEncoding) ??
      defaultValue ??
      enums.FeedComposerV1TopListTopListIdGetEncoding.swaggerGeneratedUnknown;
}

List<String> feedComposerV1TopListTopListIdGetEncodingListToJson(
    List<enums.FeedComposerV1TopListTopListIdGetEncoding>?
        feedComposerV1TopListTopListIdGetEncoding) {
  if (feedComposerV1TopListTopListIdGetEncoding == null) {
    return [];
  }

  return feedComposerV1TopListTopListIdGetEncoding
      .map((e) => e.value!)
      .toList();
}

List<enums.FeedComposerV1TopListTopListIdGetEncoding>
    feedComposerV1TopListTopListIdGetEncodingListFromJson(
  List? feedComposerV1TopListTopListIdGetEncoding, [
  List<enums.FeedComposerV1TopListTopListIdGetEncoding>? defaultValue,
]) {
  if (feedComposerV1TopListTopListIdGetEncoding == null) {
    return defaultValue ?? [];
  }

  return feedComposerV1TopListTopListIdGetEncoding
      .map((e) =>
          feedComposerV1TopListTopListIdGetEncodingFromJson(e.toString()))
      .toList();
}

List<enums.FeedComposerV1TopListTopListIdGetEncoding>?
    feedComposerV1TopListTopListIdGetEncodingNullableListFromJson(
  List? feedComposerV1TopListTopListIdGetEncoding, [
  List<enums.FeedComposerV1TopListTopListIdGetEncoding>? defaultValue,
]) {
  if (feedComposerV1TopListTopListIdGetEncoding == null) {
    return defaultValue;
  }

  return feedComposerV1TopListTopListIdGetEncoding
      .map((e) =>
          feedComposerV1TopListTopListIdGetEncodingFromJson(e.toString()))
      .toList();
}

String? feedComposerV1TopListTopListIdGetMaxResToJson(
    enums.FeedComposerV1TopListTopListIdGetMaxRes?
        feedComposerV1TopListTopListIdGetMaxRes) {
  return feedComposerV1TopListTopListIdGetMaxRes?.value;
}

enums.FeedComposerV1TopListTopListIdGetMaxRes
    feedComposerV1TopListTopListIdGetMaxResFromJson(
  Object? feedComposerV1TopListTopListIdGetMaxRes, [
  enums.FeedComposerV1TopListTopListIdGetMaxRes? defaultValue,
]) {
  return enums.FeedComposerV1TopListTopListIdGetMaxRes.values.firstWhereOrNull(
          (e) => e.value == feedComposerV1TopListTopListIdGetMaxRes) ??
      defaultValue ??
      enums.FeedComposerV1TopListTopListIdGetMaxRes.swaggerGeneratedUnknown;
}

List<String> feedComposerV1TopListTopListIdGetMaxResListToJson(
    List<enums.FeedComposerV1TopListTopListIdGetMaxRes>?
        feedComposerV1TopListTopListIdGetMaxRes) {
  if (feedComposerV1TopListTopListIdGetMaxRes == null) {
    return [];
  }

  return feedComposerV1TopListTopListIdGetMaxRes.map((e) => e.value!).toList();
}

List<enums.FeedComposerV1TopListTopListIdGetMaxRes>
    feedComposerV1TopListTopListIdGetMaxResListFromJson(
  List? feedComposerV1TopListTopListIdGetMaxRes, [
  List<enums.FeedComposerV1TopListTopListIdGetMaxRes>? defaultValue,
]) {
  if (feedComposerV1TopListTopListIdGetMaxRes == null) {
    return defaultValue ?? [];
  }

  return feedComposerV1TopListTopListIdGetMaxRes
      .map((e) => feedComposerV1TopListTopListIdGetMaxResFromJson(e.toString()))
      .toList();
}

List<enums.FeedComposerV1TopListTopListIdGetMaxRes>?
    feedComposerV1TopListTopListIdGetMaxResNullableListFromJson(
  List? feedComposerV1TopListTopListIdGetMaxRes, [
  List<enums.FeedComposerV1TopListTopListIdGetMaxRes>? defaultValue,
]) {
  if (feedComposerV1TopListTopListIdGetMaxRes == null) {
    return defaultValue;
  }

  return feedComposerV1TopListTopListIdGetMaxRes
      .map((e) => feedComposerV1TopListTopListIdGetMaxResFromJson(e.toString()))
      .toList();
}

String? feedComposerV1UserRecommendedGetEncodingToJson(
    enums.FeedComposerV1UserRecommendedGetEncoding?
        feedComposerV1UserRecommendedGetEncoding) {
  return feedComposerV1UserRecommendedGetEncoding?.value;
}

enums.FeedComposerV1UserRecommendedGetEncoding
    feedComposerV1UserRecommendedGetEncodingFromJson(
  Object? feedComposerV1UserRecommendedGetEncoding, [
  enums.FeedComposerV1UserRecommendedGetEncoding? defaultValue,
]) {
  return enums.FeedComposerV1UserRecommendedGetEncoding.values.firstWhereOrNull(
          (e) => e.value == feedComposerV1UserRecommendedGetEncoding) ??
      defaultValue ??
      enums.FeedComposerV1UserRecommendedGetEncoding.swaggerGeneratedUnknown;
}

List<String> feedComposerV1UserRecommendedGetEncodingListToJson(
    List<enums.FeedComposerV1UserRecommendedGetEncoding>?
        feedComposerV1UserRecommendedGetEncoding) {
  if (feedComposerV1UserRecommendedGetEncoding == null) {
    return [];
  }

  return feedComposerV1UserRecommendedGetEncoding.map((e) => e.value!).toList();
}

List<enums.FeedComposerV1UserRecommendedGetEncoding>
    feedComposerV1UserRecommendedGetEncodingListFromJson(
  List? feedComposerV1UserRecommendedGetEncoding, [
  List<enums.FeedComposerV1UserRecommendedGetEncoding>? defaultValue,
]) {
  if (feedComposerV1UserRecommendedGetEncoding == null) {
    return defaultValue ?? [];
  }

  return feedComposerV1UserRecommendedGetEncoding
      .map(
          (e) => feedComposerV1UserRecommendedGetEncodingFromJson(e.toString()))
      .toList();
}

List<enums.FeedComposerV1UserRecommendedGetEncoding>?
    feedComposerV1UserRecommendedGetEncodingNullableListFromJson(
  List? feedComposerV1UserRecommendedGetEncoding, [
  List<enums.FeedComposerV1UserRecommendedGetEncoding>? defaultValue,
]) {
  if (feedComposerV1UserRecommendedGetEncoding == null) {
    return defaultValue;
  }

  return feedComposerV1UserRecommendedGetEncoding
      .map(
          (e) => feedComposerV1UserRecommendedGetEncodingFromJson(e.toString()))
      .toList();
}

String? feedComposerV1UserRecommendedGetMaxResToJson(
    enums.FeedComposerV1UserRecommendedGetMaxRes?
        feedComposerV1UserRecommendedGetMaxRes) {
  return feedComposerV1UserRecommendedGetMaxRes?.value;
}

enums.FeedComposerV1UserRecommendedGetMaxRes
    feedComposerV1UserRecommendedGetMaxResFromJson(
  Object? feedComposerV1UserRecommendedGetMaxRes, [
  enums.FeedComposerV1UserRecommendedGetMaxRes? defaultValue,
]) {
  return enums.FeedComposerV1UserRecommendedGetMaxRes.values.firstWhereOrNull(
          (e) => e.value == feedComposerV1UserRecommendedGetMaxRes) ??
      defaultValue ??
      enums.FeedComposerV1UserRecommendedGetMaxRes.swaggerGeneratedUnknown;
}

List<String> feedComposerV1UserRecommendedGetMaxResListToJson(
    List<enums.FeedComposerV1UserRecommendedGetMaxRes>?
        feedComposerV1UserRecommendedGetMaxRes) {
  if (feedComposerV1UserRecommendedGetMaxRes == null) {
    return [];
  }

  return feedComposerV1UserRecommendedGetMaxRes.map((e) => e.value!).toList();
}

List<enums.FeedComposerV1UserRecommendedGetMaxRes>
    feedComposerV1UserRecommendedGetMaxResListFromJson(
  List? feedComposerV1UserRecommendedGetMaxRes, [
  List<enums.FeedComposerV1UserRecommendedGetMaxRes>? defaultValue,
]) {
  if (feedComposerV1UserRecommendedGetMaxRes == null) {
    return defaultValue ?? [];
  }

  return feedComposerV1UserRecommendedGetMaxRes
      .map((e) => feedComposerV1UserRecommendedGetMaxResFromJson(e.toString()))
      .toList();
}

List<enums.FeedComposerV1UserRecommendedGetMaxRes>?
    feedComposerV1UserRecommendedGetMaxResNullableListFromJson(
  List? feedComposerV1UserRecommendedGetMaxRes, [
  List<enums.FeedComposerV1UserRecommendedGetMaxRes>? defaultValue,
]) {
  if (feedComposerV1UserRecommendedGetMaxRes == null) {
    return defaultValue;
  }

  return feedComposerV1UserRecommendedGetMaxRes
      .map((e) => feedComposerV1UserRecommendedGetMaxResFromJson(e.toString()))
      .toList();
}

String? feedComposerV1UserRecommendedByWatchedGenreGetEncodingToJson(
    enums.FeedComposerV1UserRecommendedByWatchedGenreGetEncoding?
        feedComposerV1UserRecommendedByWatchedGenreGetEncoding) {
  return feedComposerV1UserRecommendedByWatchedGenreGetEncoding?.value;
}

enums.FeedComposerV1UserRecommendedByWatchedGenreGetEncoding
    feedComposerV1UserRecommendedByWatchedGenreGetEncodingFromJson(
  Object? feedComposerV1UserRecommendedByWatchedGenreGetEncoding, [
  enums.FeedComposerV1UserRecommendedByWatchedGenreGetEncoding? defaultValue,
]) {
  return enums.FeedComposerV1UserRecommendedByWatchedGenreGetEncoding.values
          .firstWhereOrNull((e) =>
              e.value ==
              feedComposerV1UserRecommendedByWatchedGenreGetEncoding) ??
      defaultValue ??
      enums.FeedComposerV1UserRecommendedByWatchedGenreGetEncoding
          .swaggerGeneratedUnknown;
}

List<String> feedComposerV1UserRecommendedByWatchedGenreGetEncodingListToJson(
    List<enums.FeedComposerV1UserRecommendedByWatchedGenreGetEncoding>?
        feedComposerV1UserRecommendedByWatchedGenreGetEncoding) {
  if (feedComposerV1UserRecommendedByWatchedGenreGetEncoding == null) {
    return [];
  }

  return feedComposerV1UserRecommendedByWatchedGenreGetEncoding
      .map((e) => e.value!)
      .toList();
}

List<enums.FeedComposerV1UserRecommendedByWatchedGenreGetEncoding>
    feedComposerV1UserRecommendedByWatchedGenreGetEncodingListFromJson(
  List? feedComposerV1UserRecommendedByWatchedGenreGetEncoding, [
  List<enums.FeedComposerV1UserRecommendedByWatchedGenreGetEncoding>?
      defaultValue,
]) {
  if (feedComposerV1UserRecommendedByWatchedGenreGetEncoding == null) {
    return defaultValue ?? [];
  }

  return feedComposerV1UserRecommendedByWatchedGenreGetEncoding
      .map((e) =>
          feedComposerV1UserRecommendedByWatchedGenreGetEncodingFromJson(
              e.toString()))
      .toList();
}

List<enums.FeedComposerV1UserRecommendedByWatchedGenreGetEncoding>?
    feedComposerV1UserRecommendedByWatchedGenreGetEncodingNullableListFromJson(
  List? feedComposerV1UserRecommendedByWatchedGenreGetEncoding, [
  List<enums.FeedComposerV1UserRecommendedByWatchedGenreGetEncoding>?
      defaultValue,
]) {
  if (feedComposerV1UserRecommendedByWatchedGenreGetEncoding == null) {
    return defaultValue;
  }

  return feedComposerV1UserRecommendedByWatchedGenreGetEncoding
      .map((e) =>
          feedComposerV1UserRecommendedByWatchedGenreGetEncodingFromJson(
              e.toString()))
      .toList();
}

String? feedComposerV1UserRecommendedByWatchedGenreGetMaxResToJson(
    enums.FeedComposerV1UserRecommendedByWatchedGenreGetMaxRes?
        feedComposerV1UserRecommendedByWatchedGenreGetMaxRes) {
  return feedComposerV1UserRecommendedByWatchedGenreGetMaxRes?.value;
}

enums.FeedComposerV1UserRecommendedByWatchedGenreGetMaxRes
    feedComposerV1UserRecommendedByWatchedGenreGetMaxResFromJson(
  Object? feedComposerV1UserRecommendedByWatchedGenreGetMaxRes, [
  enums.FeedComposerV1UserRecommendedByWatchedGenreGetMaxRes? defaultValue,
]) {
  return enums.FeedComposerV1UserRecommendedByWatchedGenreGetMaxRes.values
          .firstWhereOrNull((e) =>
              e.value ==
              feedComposerV1UserRecommendedByWatchedGenreGetMaxRes) ??
      defaultValue ??
      enums.FeedComposerV1UserRecommendedByWatchedGenreGetMaxRes
          .swaggerGeneratedUnknown;
}

List<String> feedComposerV1UserRecommendedByWatchedGenreGetMaxResListToJson(
    List<enums.FeedComposerV1UserRecommendedByWatchedGenreGetMaxRes>?
        feedComposerV1UserRecommendedByWatchedGenreGetMaxRes) {
  if (feedComposerV1UserRecommendedByWatchedGenreGetMaxRes == null) {
    return [];
  }

  return feedComposerV1UserRecommendedByWatchedGenreGetMaxRes
      .map((e) => e.value!)
      .toList();
}

List<enums.FeedComposerV1UserRecommendedByWatchedGenreGetMaxRes>
    feedComposerV1UserRecommendedByWatchedGenreGetMaxResListFromJson(
  List? feedComposerV1UserRecommendedByWatchedGenreGetMaxRes, [
  List<enums.FeedComposerV1UserRecommendedByWatchedGenreGetMaxRes>?
      defaultValue,
]) {
  if (feedComposerV1UserRecommendedByWatchedGenreGetMaxRes == null) {
    return defaultValue ?? [];
  }

  return feedComposerV1UserRecommendedByWatchedGenreGetMaxRes
      .map((e) => feedComposerV1UserRecommendedByWatchedGenreGetMaxResFromJson(
          e.toString()))
      .toList();
}

List<enums.FeedComposerV1UserRecommendedByWatchedGenreGetMaxRes>?
    feedComposerV1UserRecommendedByWatchedGenreGetMaxResNullableListFromJson(
  List? feedComposerV1UserRecommendedByWatchedGenreGetMaxRes, [
  List<enums.FeedComposerV1UserRecommendedByWatchedGenreGetMaxRes>?
      defaultValue,
]) {
  if (feedComposerV1UserRecommendedByWatchedGenreGetMaxRes == null) {
    return defaultValue;
  }

  return feedComposerV1UserRecommendedByWatchedGenreGetMaxRes
      .map((e) => feedComposerV1UserRecommendedByWatchedGenreGetMaxResFromJson(
          e.toString()))
      .toList();
}

String? feedComposerV1WatchlistGetEncodingToJson(
    enums.FeedComposerV1WatchlistGetEncoding?
        feedComposerV1WatchlistGetEncoding) {
  return feedComposerV1WatchlistGetEncoding?.value;
}

enums.FeedComposerV1WatchlistGetEncoding
    feedComposerV1WatchlistGetEncodingFromJson(
  Object? feedComposerV1WatchlistGetEncoding, [
  enums.FeedComposerV1WatchlistGetEncoding? defaultValue,
]) {
  return enums.FeedComposerV1WatchlistGetEncoding.values.firstWhereOrNull(
          (e) => e.value == feedComposerV1WatchlistGetEncoding) ??
      defaultValue ??
      enums.FeedComposerV1WatchlistGetEncoding.swaggerGeneratedUnknown;
}

List<String> feedComposerV1WatchlistGetEncodingListToJson(
    List<enums.FeedComposerV1WatchlistGetEncoding>?
        feedComposerV1WatchlistGetEncoding) {
  if (feedComposerV1WatchlistGetEncoding == null) {
    return [];
  }

  return feedComposerV1WatchlistGetEncoding.map((e) => e.value!).toList();
}

List<enums.FeedComposerV1WatchlistGetEncoding>
    feedComposerV1WatchlistGetEncodingListFromJson(
  List? feedComposerV1WatchlistGetEncoding, [
  List<enums.FeedComposerV1WatchlistGetEncoding>? defaultValue,
]) {
  if (feedComposerV1WatchlistGetEncoding == null) {
    return defaultValue ?? [];
  }

  return feedComposerV1WatchlistGetEncoding
      .map((e) => feedComposerV1WatchlistGetEncodingFromJson(e.toString()))
      .toList();
}

List<enums.FeedComposerV1WatchlistGetEncoding>?
    feedComposerV1WatchlistGetEncodingNullableListFromJson(
  List? feedComposerV1WatchlistGetEncoding, [
  List<enums.FeedComposerV1WatchlistGetEncoding>? defaultValue,
]) {
  if (feedComposerV1WatchlistGetEncoding == null) {
    return defaultValue;
  }

  return feedComposerV1WatchlistGetEncoding
      .map((e) => feedComposerV1WatchlistGetEncodingFromJson(e.toString()))
      .toList();
}

String? feedComposerV1WatchlistGetMaxResToJson(
    enums.FeedComposerV1WatchlistGetMaxRes? feedComposerV1WatchlistGetMaxRes) {
  return feedComposerV1WatchlistGetMaxRes?.value;
}

enums.FeedComposerV1WatchlistGetMaxRes feedComposerV1WatchlistGetMaxResFromJson(
  Object? feedComposerV1WatchlistGetMaxRes, [
  enums.FeedComposerV1WatchlistGetMaxRes? defaultValue,
]) {
  return enums.FeedComposerV1WatchlistGetMaxRes.values.firstWhereOrNull(
          (e) => e.value == feedComposerV1WatchlistGetMaxRes) ??
      defaultValue ??
      enums.FeedComposerV1WatchlistGetMaxRes.swaggerGeneratedUnknown;
}

List<String> feedComposerV1WatchlistGetMaxResListToJson(
    List<enums.FeedComposerV1WatchlistGetMaxRes>?
        feedComposerV1WatchlistGetMaxRes) {
  if (feedComposerV1WatchlistGetMaxRes == null) {
    return [];
  }

  return feedComposerV1WatchlistGetMaxRes.map((e) => e.value!).toList();
}

List<enums.FeedComposerV1WatchlistGetMaxRes>
    feedComposerV1WatchlistGetMaxResListFromJson(
  List? feedComposerV1WatchlistGetMaxRes, [
  List<enums.FeedComposerV1WatchlistGetMaxRes>? defaultValue,
]) {
  if (feedComposerV1WatchlistGetMaxRes == null) {
    return defaultValue ?? [];
  }

  return feedComposerV1WatchlistGetMaxRes
      .map((e) => feedComposerV1WatchlistGetMaxResFromJson(e.toString()))
      .toList();
}

List<enums.FeedComposerV1WatchlistGetMaxRes>?
    feedComposerV1WatchlistGetMaxResNullableListFromJson(
  List? feedComposerV1WatchlistGetMaxRes, [
  List<enums.FeedComposerV1WatchlistGetMaxRes>? defaultValue,
]) {
  if (feedComposerV1WatchlistGetMaxRes == null) {
    return defaultValue;
  }

  return feedComposerV1WatchlistGetMaxRes
      .map((e) => feedComposerV1WatchlistGetMaxResFromJson(e.toString()))
      .toList();
}

String? feedComposerV1ContinueWatchingGetEncodingToJson(
    enums.FeedComposerV1ContinueWatchingGetEncoding?
        feedComposerV1ContinueWatchingGetEncoding) {
  return feedComposerV1ContinueWatchingGetEncoding?.value;
}

enums.FeedComposerV1ContinueWatchingGetEncoding
    feedComposerV1ContinueWatchingGetEncodingFromJson(
  Object? feedComposerV1ContinueWatchingGetEncoding, [
  enums.FeedComposerV1ContinueWatchingGetEncoding? defaultValue,
]) {
  return enums.FeedComposerV1ContinueWatchingGetEncoding.values
          .firstWhereOrNull(
              (e) => e.value == feedComposerV1ContinueWatchingGetEncoding) ??
      defaultValue ??
      enums.FeedComposerV1ContinueWatchingGetEncoding.swaggerGeneratedUnknown;
}

List<String> feedComposerV1ContinueWatchingGetEncodingListToJson(
    List<enums.FeedComposerV1ContinueWatchingGetEncoding>?
        feedComposerV1ContinueWatchingGetEncoding) {
  if (feedComposerV1ContinueWatchingGetEncoding == null) {
    return [];
  }

  return feedComposerV1ContinueWatchingGetEncoding
      .map((e) => e.value!)
      .toList();
}

List<enums.FeedComposerV1ContinueWatchingGetEncoding>
    feedComposerV1ContinueWatchingGetEncodingListFromJson(
  List? feedComposerV1ContinueWatchingGetEncoding, [
  List<enums.FeedComposerV1ContinueWatchingGetEncoding>? defaultValue,
]) {
  if (feedComposerV1ContinueWatchingGetEncoding == null) {
    return defaultValue ?? [];
  }

  return feedComposerV1ContinueWatchingGetEncoding
      .map((e) =>
          feedComposerV1ContinueWatchingGetEncodingFromJson(e.toString()))
      .toList();
}

List<enums.FeedComposerV1ContinueWatchingGetEncoding>?
    feedComposerV1ContinueWatchingGetEncodingNullableListFromJson(
  List? feedComposerV1ContinueWatchingGetEncoding, [
  List<enums.FeedComposerV1ContinueWatchingGetEncoding>? defaultValue,
]) {
  if (feedComposerV1ContinueWatchingGetEncoding == null) {
    return defaultValue;
  }

  return feedComposerV1ContinueWatchingGetEncoding
      .map((e) =>
          feedComposerV1ContinueWatchingGetEncodingFromJson(e.toString()))
      .toList();
}

String? feedComposerV1ContinueWatchingGetMaxResToJson(
    enums.FeedComposerV1ContinueWatchingGetMaxRes?
        feedComposerV1ContinueWatchingGetMaxRes) {
  return feedComposerV1ContinueWatchingGetMaxRes?.value;
}

enums.FeedComposerV1ContinueWatchingGetMaxRes
    feedComposerV1ContinueWatchingGetMaxResFromJson(
  Object? feedComposerV1ContinueWatchingGetMaxRes, [
  enums.FeedComposerV1ContinueWatchingGetMaxRes? defaultValue,
]) {
  return enums.FeedComposerV1ContinueWatchingGetMaxRes.values.firstWhereOrNull(
          (e) => e.value == feedComposerV1ContinueWatchingGetMaxRes) ??
      defaultValue ??
      enums.FeedComposerV1ContinueWatchingGetMaxRes.swaggerGeneratedUnknown;
}

List<String> feedComposerV1ContinueWatchingGetMaxResListToJson(
    List<enums.FeedComposerV1ContinueWatchingGetMaxRes>?
        feedComposerV1ContinueWatchingGetMaxRes) {
  if (feedComposerV1ContinueWatchingGetMaxRes == null) {
    return [];
  }

  return feedComposerV1ContinueWatchingGetMaxRes.map((e) => e.value!).toList();
}

List<enums.FeedComposerV1ContinueWatchingGetMaxRes>
    feedComposerV1ContinueWatchingGetMaxResListFromJson(
  List? feedComposerV1ContinueWatchingGetMaxRes, [
  List<enums.FeedComposerV1ContinueWatchingGetMaxRes>? defaultValue,
]) {
  if (feedComposerV1ContinueWatchingGetMaxRes == null) {
    return defaultValue ?? [];
  }

  return feedComposerV1ContinueWatchingGetMaxRes
      .map((e) => feedComposerV1ContinueWatchingGetMaxResFromJson(e.toString()))
      .toList();
}

List<enums.FeedComposerV1ContinueWatchingGetMaxRes>?
    feedComposerV1ContinueWatchingGetMaxResNullableListFromJson(
  List? feedComposerV1ContinueWatchingGetMaxRes, [
  List<enums.FeedComposerV1ContinueWatchingGetMaxRes>? defaultValue,
]) {
  if (feedComposerV1ContinueWatchingGetMaxRes == null) {
    return defaultValue;
  }

  return feedComposerV1ContinueWatchingGetMaxRes
      .map((e) => feedComposerV1ContinueWatchingGetMaxResFromJson(e.toString()))
      .toList();
}

String? feedComposerV1EditorialFeedFeedCridGetEncodingToJson(
    enums.FeedComposerV1EditorialFeedFeedCridGetEncoding?
        feedComposerV1EditorialFeedFeedCridGetEncoding) {
  return feedComposerV1EditorialFeedFeedCridGetEncoding?.value;
}

enums.FeedComposerV1EditorialFeedFeedCridGetEncoding
    feedComposerV1EditorialFeedFeedCridGetEncodingFromJson(
  Object? feedComposerV1EditorialFeedFeedCridGetEncoding, [
  enums.FeedComposerV1EditorialFeedFeedCridGetEncoding? defaultValue,
]) {
  return enums.FeedComposerV1EditorialFeedFeedCridGetEncoding.values
          .firstWhereOrNull((e) =>
              e.value == feedComposerV1EditorialFeedFeedCridGetEncoding) ??
      defaultValue ??
      enums.FeedComposerV1EditorialFeedFeedCridGetEncoding
          .swaggerGeneratedUnknown;
}

List<String> feedComposerV1EditorialFeedFeedCridGetEncodingListToJson(
    List<enums.FeedComposerV1EditorialFeedFeedCridGetEncoding>?
        feedComposerV1EditorialFeedFeedCridGetEncoding) {
  if (feedComposerV1EditorialFeedFeedCridGetEncoding == null) {
    return [];
  }

  return feedComposerV1EditorialFeedFeedCridGetEncoding
      .map((e) => e.value!)
      .toList();
}

List<enums.FeedComposerV1EditorialFeedFeedCridGetEncoding>
    feedComposerV1EditorialFeedFeedCridGetEncodingListFromJson(
  List? feedComposerV1EditorialFeedFeedCridGetEncoding, [
  List<enums.FeedComposerV1EditorialFeedFeedCridGetEncoding>? defaultValue,
]) {
  if (feedComposerV1EditorialFeedFeedCridGetEncoding == null) {
    return defaultValue ?? [];
  }

  return feedComposerV1EditorialFeedFeedCridGetEncoding
      .map((e) =>
          feedComposerV1EditorialFeedFeedCridGetEncodingFromJson(e.toString()))
      .toList();
}

List<enums.FeedComposerV1EditorialFeedFeedCridGetEncoding>?
    feedComposerV1EditorialFeedFeedCridGetEncodingNullableListFromJson(
  List? feedComposerV1EditorialFeedFeedCridGetEncoding, [
  List<enums.FeedComposerV1EditorialFeedFeedCridGetEncoding>? defaultValue,
]) {
  if (feedComposerV1EditorialFeedFeedCridGetEncoding == null) {
    return defaultValue;
  }

  return feedComposerV1EditorialFeedFeedCridGetEncoding
      .map((e) =>
          feedComposerV1EditorialFeedFeedCridGetEncodingFromJson(e.toString()))
      .toList();
}

String? feedComposerV1EditorialFeedFeedCridGetMaxResToJson(
    enums.FeedComposerV1EditorialFeedFeedCridGetMaxRes?
        feedComposerV1EditorialFeedFeedCridGetMaxRes) {
  return feedComposerV1EditorialFeedFeedCridGetMaxRes?.value;
}

enums.FeedComposerV1EditorialFeedFeedCridGetMaxRes
    feedComposerV1EditorialFeedFeedCridGetMaxResFromJson(
  Object? feedComposerV1EditorialFeedFeedCridGetMaxRes, [
  enums.FeedComposerV1EditorialFeedFeedCridGetMaxRes? defaultValue,
]) {
  return enums.FeedComposerV1EditorialFeedFeedCridGetMaxRes.values
          .firstWhereOrNull(
              (e) => e.value == feedComposerV1EditorialFeedFeedCridGetMaxRes) ??
      defaultValue ??
      enums
          .FeedComposerV1EditorialFeedFeedCridGetMaxRes.swaggerGeneratedUnknown;
}

List<String> feedComposerV1EditorialFeedFeedCridGetMaxResListToJson(
    List<enums.FeedComposerV1EditorialFeedFeedCridGetMaxRes>?
        feedComposerV1EditorialFeedFeedCridGetMaxRes) {
  if (feedComposerV1EditorialFeedFeedCridGetMaxRes == null) {
    return [];
  }

  return feedComposerV1EditorialFeedFeedCridGetMaxRes
      .map((e) => e.value!)
      .toList();
}

List<enums.FeedComposerV1EditorialFeedFeedCridGetMaxRes>
    feedComposerV1EditorialFeedFeedCridGetMaxResListFromJson(
  List? feedComposerV1EditorialFeedFeedCridGetMaxRes, [
  List<enums.FeedComposerV1EditorialFeedFeedCridGetMaxRes>? defaultValue,
]) {
  if (feedComposerV1EditorialFeedFeedCridGetMaxRes == null) {
    return defaultValue ?? [];
  }

  return feedComposerV1EditorialFeedFeedCridGetMaxRes
      .map((e) =>
          feedComposerV1EditorialFeedFeedCridGetMaxResFromJson(e.toString()))
      .toList();
}

List<enums.FeedComposerV1EditorialFeedFeedCridGetMaxRes>?
    feedComposerV1EditorialFeedFeedCridGetMaxResNullableListFromJson(
  List? feedComposerV1EditorialFeedFeedCridGetMaxRes, [
  List<enums.FeedComposerV1EditorialFeedFeedCridGetMaxRes>? defaultValue,
]) {
  if (feedComposerV1EditorialFeedFeedCridGetMaxRes == null) {
    return defaultValue;
  }

  return feedComposerV1EditorialFeedFeedCridGetMaxRes
      .map((e) =>
          feedComposerV1EditorialFeedFeedCridGetMaxResFromJson(e.toString()))
      .toList();
}

String? feedComposerV1EditorialFeedFeedCridGetSortingToJson(
    enums.FeedComposerV1EditorialFeedFeedCridGetSorting?
        feedComposerV1EditorialFeedFeedCridGetSorting) {
  return feedComposerV1EditorialFeedFeedCridGetSorting?.value;
}

enums.FeedComposerV1EditorialFeedFeedCridGetSorting
    feedComposerV1EditorialFeedFeedCridGetSortingFromJson(
  Object? feedComposerV1EditorialFeedFeedCridGetSorting, [
  enums.FeedComposerV1EditorialFeedFeedCridGetSorting? defaultValue,
]) {
  return enums.FeedComposerV1EditorialFeedFeedCridGetSorting.values
          .firstWhereOrNull((e) =>
              e.value == feedComposerV1EditorialFeedFeedCridGetSorting) ??
      defaultValue ??
      enums.FeedComposerV1EditorialFeedFeedCridGetSorting
          .swaggerGeneratedUnknown;
}

List<String> feedComposerV1EditorialFeedFeedCridGetSortingListToJson(
    List<enums.FeedComposerV1EditorialFeedFeedCridGetSorting>?
        feedComposerV1EditorialFeedFeedCridGetSorting) {
  if (feedComposerV1EditorialFeedFeedCridGetSorting == null) {
    return [];
  }

  return feedComposerV1EditorialFeedFeedCridGetSorting
      .map((e) => e.value!)
      .toList();
}

List<enums.FeedComposerV1EditorialFeedFeedCridGetSorting>
    feedComposerV1EditorialFeedFeedCridGetSortingListFromJson(
  List? feedComposerV1EditorialFeedFeedCridGetSorting, [
  List<enums.FeedComposerV1EditorialFeedFeedCridGetSorting>? defaultValue,
]) {
  if (feedComposerV1EditorialFeedFeedCridGetSorting == null) {
    return defaultValue ?? [];
  }

  return feedComposerV1EditorialFeedFeedCridGetSorting
      .map((e) =>
          feedComposerV1EditorialFeedFeedCridGetSortingFromJson(e.toString()))
      .toList();
}

List<enums.FeedComposerV1EditorialFeedFeedCridGetSorting>?
    feedComposerV1EditorialFeedFeedCridGetSortingNullableListFromJson(
  List? feedComposerV1EditorialFeedFeedCridGetSorting, [
  List<enums.FeedComposerV1EditorialFeedFeedCridGetSorting>? defaultValue,
]) {
  if (feedComposerV1EditorialFeedFeedCridGetSorting == null) {
    return defaultValue;
  }

  return feedComposerV1EditorialFeedFeedCridGetSorting
      .map((e) =>
          feedComposerV1EditorialFeedFeedCridGetSortingFromJson(e.toString()))
      .toList();
}

String? feedComposerV1MoreLikeWatchedGetEncodingToJson(
    enums.FeedComposerV1MoreLikeWatchedGetEncoding?
        feedComposerV1MoreLikeWatchedGetEncoding) {
  return feedComposerV1MoreLikeWatchedGetEncoding?.value;
}

enums.FeedComposerV1MoreLikeWatchedGetEncoding
    feedComposerV1MoreLikeWatchedGetEncodingFromJson(
  Object? feedComposerV1MoreLikeWatchedGetEncoding, [
  enums.FeedComposerV1MoreLikeWatchedGetEncoding? defaultValue,
]) {
  return enums.FeedComposerV1MoreLikeWatchedGetEncoding.values.firstWhereOrNull(
          (e) => e.value == feedComposerV1MoreLikeWatchedGetEncoding) ??
      defaultValue ??
      enums.FeedComposerV1MoreLikeWatchedGetEncoding.swaggerGeneratedUnknown;
}

List<String> feedComposerV1MoreLikeWatchedGetEncodingListToJson(
    List<enums.FeedComposerV1MoreLikeWatchedGetEncoding>?
        feedComposerV1MoreLikeWatchedGetEncoding) {
  if (feedComposerV1MoreLikeWatchedGetEncoding == null) {
    return [];
  }

  return feedComposerV1MoreLikeWatchedGetEncoding.map((e) => e.value!).toList();
}

List<enums.FeedComposerV1MoreLikeWatchedGetEncoding>
    feedComposerV1MoreLikeWatchedGetEncodingListFromJson(
  List? feedComposerV1MoreLikeWatchedGetEncoding, [
  List<enums.FeedComposerV1MoreLikeWatchedGetEncoding>? defaultValue,
]) {
  if (feedComposerV1MoreLikeWatchedGetEncoding == null) {
    return defaultValue ?? [];
  }

  return feedComposerV1MoreLikeWatchedGetEncoding
      .map(
          (e) => feedComposerV1MoreLikeWatchedGetEncodingFromJson(e.toString()))
      .toList();
}

List<enums.FeedComposerV1MoreLikeWatchedGetEncoding>?
    feedComposerV1MoreLikeWatchedGetEncodingNullableListFromJson(
  List? feedComposerV1MoreLikeWatchedGetEncoding, [
  List<enums.FeedComposerV1MoreLikeWatchedGetEncoding>? defaultValue,
]) {
  if (feedComposerV1MoreLikeWatchedGetEncoding == null) {
    return defaultValue;
  }

  return feedComposerV1MoreLikeWatchedGetEncoding
      .map(
          (e) => feedComposerV1MoreLikeWatchedGetEncodingFromJson(e.toString()))
      .toList();
}

String? feedComposerV1MoreLikeWatchedGetMaxResToJson(
    enums.FeedComposerV1MoreLikeWatchedGetMaxRes?
        feedComposerV1MoreLikeWatchedGetMaxRes) {
  return feedComposerV1MoreLikeWatchedGetMaxRes?.value;
}

enums.FeedComposerV1MoreLikeWatchedGetMaxRes
    feedComposerV1MoreLikeWatchedGetMaxResFromJson(
  Object? feedComposerV1MoreLikeWatchedGetMaxRes, [
  enums.FeedComposerV1MoreLikeWatchedGetMaxRes? defaultValue,
]) {
  return enums.FeedComposerV1MoreLikeWatchedGetMaxRes.values.firstWhereOrNull(
          (e) => e.value == feedComposerV1MoreLikeWatchedGetMaxRes) ??
      defaultValue ??
      enums.FeedComposerV1MoreLikeWatchedGetMaxRes.swaggerGeneratedUnknown;
}

List<String> feedComposerV1MoreLikeWatchedGetMaxResListToJson(
    List<enums.FeedComposerV1MoreLikeWatchedGetMaxRes>?
        feedComposerV1MoreLikeWatchedGetMaxRes) {
  if (feedComposerV1MoreLikeWatchedGetMaxRes == null) {
    return [];
  }

  return feedComposerV1MoreLikeWatchedGetMaxRes.map((e) => e.value!).toList();
}

List<enums.FeedComposerV1MoreLikeWatchedGetMaxRes>
    feedComposerV1MoreLikeWatchedGetMaxResListFromJson(
  List? feedComposerV1MoreLikeWatchedGetMaxRes, [
  List<enums.FeedComposerV1MoreLikeWatchedGetMaxRes>? defaultValue,
]) {
  if (feedComposerV1MoreLikeWatchedGetMaxRes == null) {
    return defaultValue ?? [];
  }

  return feedComposerV1MoreLikeWatchedGetMaxRes
      .map((e) => feedComposerV1MoreLikeWatchedGetMaxResFromJson(e.toString()))
      .toList();
}

List<enums.FeedComposerV1MoreLikeWatchedGetMaxRes>?
    feedComposerV1MoreLikeWatchedGetMaxResNullableListFromJson(
  List? feedComposerV1MoreLikeWatchedGetMaxRes, [
  List<enums.FeedComposerV1MoreLikeWatchedGetMaxRes>? defaultValue,
]) {
  if (feedComposerV1MoreLikeWatchedGetMaxRes == null) {
    return defaultValue;
  }

  return feedComposerV1MoreLikeWatchedGetMaxRes
      .map((e) => feedComposerV1MoreLikeWatchedGetMaxResFromJson(e.toString()))
      .toList();
}

String? feedComposerV1MoreLikeWatchedGenreGetEncodingToJson(
    enums.FeedComposerV1MoreLikeWatchedGenreGetEncoding?
        feedComposerV1MoreLikeWatchedGenreGetEncoding) {
  return feedComposerV1MoreLikeWatchedGenreGetEncoding?.value;
}

enums.FeedComposerV1MoreLikeWatchedGenreGetEncoding
    feedComposerV1MoreLikeWatchedGenreGetEncodingFromJson(
  Object? feedComposerV1MoreLikeWatchedGenreGetEncoding, [
  enums.FeedComposerV1MoreLikeWatchedGenreGetEncoding? defaultValue,
]) {
  return enums.FeedComposerV1MoreLikeWatchedGenreGetEncoding.values
          .firstWhereOrNull((e) =>
              e.value == feedComposerV1MoreLikeWatchedGenreGetEncoding) ??
      defaultValue ??
      enums.FeedComposerV1MoreLikeWatchedGenreGetEncoding
          .swaggerGeneratedUnknown;
}

List<String> feedComposerV1MoreLikeWatchedGenreGetEncodingListToJson(
    List<enums.FeedComposerV1MoreLikeWatchedGenreGetEncoding>?
        feedComposerV1MoreLikeWatchedGenreGetEncoding) {
  if (feedComposerV1MoreLikeWatchedGenreGetEncoding == null) {
    return [];
  }

  return feedComposerV1MoreLikeWatchedGenreGetEncoding
      .map((e) => e.value!)
      .toList();
}

List<enums.FeedComposerV1MoreLikeWatchedGenreGetEncoding>
    feedComposerV1MoreLikeWatchedGenreGetEncodingListFromJson(
  List? feedComposerV1MoreLikeWatchedGenreGetEncoding, [
  List<enums.FeedComposerV1MoreLikeWatchedGenreGetEncoding>? defaultValue,
]) {
  if (feedComposerV1MoreLikeWatchedGenreGetEncoding == null) {
    return defaultValue ?? [];
  }

  return feedComposerV1MoreLikeWatchedGenreGetEncoding
      .map((e) =>
          feedComposerV1MoreLikeWatchedGenreGetEncodingFromJson(e.toString()))
      .toList();
}

List<enums.FeedComposerV1MoreLikeWatchedGenreGetEncoding>?
    feedComposerV1MoreLikeWatchedGenreGetEncodingNullableListFromJson(
  List? feedComposerV1MoreLikeWatchedGenreGetEncoding, [
  List<enums.FeedComposerV1MoreLikeWatchedGenreGetEncoding>? defaultValue,
]) {
  if (feedComposerV1MoreLikeWatchedGenreGetEncoding == null) {
    return defaultValue;
  }

  return feedComposerV1MoreLikeWatchedGenreGetEncoding
      .map((e) =>
          feedComposerV1MoreLikeWatchedGenreGetEncodingFromJson(e.toString()))
      .toList();
}

String? feedComposerV1MoreLikeWatchedGenreGetMaxResToJson(
    enums.FeedComposerV1MoreLikeWatchedGenreGetMaxRes?
        feedComposerV1MoreLikeWatchedGenreGetMaxRes) {
  return feedComposerV1MoreLikeWatchedGenreGetMaxRes?.value;
}

enums.FeedComposerV1MoreLikeWatchedGenreGetMaxRes
    feedComposerV1MoreLikeWatchedGenreGetMaxResFromJson(
  Object? feedComposerV1MoreLikeWatchedGenreGetMaxRes, [
  enums.FeedComposerV1MoreLikeWatchedGenreGetMaxRes? defaultValue,
]) {
  return enums.FeedComposerV1MoreLikeWatchedGenreGetMaxRes.values
          .firstWhereOrNull(
              (e) => e.value == feedComposerV1MoreLikeWatchedGenreGetMaxRes) ??
      defaultValue ??
      enums.FeedComposerV1MoreLikeWatchedGenreGetMaxRes.swaggerGeneratedUnknown;
}

List<String> feedComposerV1MoreLikeWatchedGenreGetMaxResListToJson(
    List<enums.FeedComposerV1MoreLikeWatchedGenreGetMaxRes>?
        feedComposerV1MoreLikeWatchedGenreGetMaxRes) {
  if (feedComposerV1MoreLikeWatchedGenreGetMaxRes == null) {
    return [];
  }

  return feedComposerV1MoreLikeWatchedGenreGetMaxRes
      .map((e) => e.value!)
      .toList();
}

List<enums.FeedComposerV1MoreLikeWatchedGenreGetMaxRes>
    feedComposerV1MoreLikeWatchedGenreGetMaxResListFromJson(
  List? feedComposerV1MoreLikeWatchedGenreGetMaxRes, [
  List<enums.FeedComposerV1MoreLikeWatchedGenreGetMaxRes>? defaultValue,
]) {
  if (feedComposerV1MoreLikeWatchedGenreGetMaxRes == null) {
    return defaultValue ?? [];
  }

  return feedComposerV1MoreLikeWatchedGenreGetMaxRes
      .map((e) =>
          feedComposerV1MoreLikeWatchedGenreGetMaxResFromJson(e.toString()))
      .toList();
}

List<enums.FeedComposerV1MoreLikeWatchedGenreGetMaxRes>?
    feedComposerV1MoreLikeWatchedGenreGetMaxResNullableListFromJson(
  List? feedComposerV1MoreLikeWatchedGenreGetMaxRes, [
  List<enums.FeedComposerV1MoreLikeWatchedGenreGetMaxRes>? defaultValue,
]) {
  if (feedComposerV1MoreLikeWatchedGenreGetMaxRes == null) {
    return defaultValue;
  }

  return feedComposerV1MoreLikeWatchedGenreGetMaxRes
      .map((e) =>
          feedComposerV1MoreLikeWatchedGenreGetMaxResFromJson(e.toString()))
      .toList();
}

String? feedComposerV1CollaborativeRecommendationsGetIsSharedProfileToJson(
    enums.FeedComposerV1CollaborativeRecommendationsGetIsSharedProfile?
        feedComposerV1CollaborativeRecommendationsGetIsSharedProfile) {
  return feedComposerV1CollaborativeRecommendationsGetIsSharedProfile?.value;
}

enums.FeedComposerV1CollaborativeRecommendationsGetIsSharedProfile
    feedComposerV1CollaborativeRecommendationsGetIsSharedProfileFromJson(
  Object? feedComposerV1CollaborativeRecommendationsGetIsSharedProfile, [
  enums.FeedComposerV1CollaborativeRecommendationsGetIsSharedProfile?
      defaultValue,
]) {
  return enums
          .FeedComposerV1CollaborativeRecommendationsGetIsSharedProfile.values
          .firstWhereOrNull((e) =>
              e.value ==
              feedComposerV1CollaborativeRecommendationsGetIsSharedProfile) ??
      defaultValue ??
      enums.FeedComposerV1CollaborativeRecommendationsGetIsSharedProfile
          .swaggerGeneratedUnknown;
}

List<String>
    feedComposerV1CollaborativeRecommendationsGetIsSharedProfileListToJson(
        List<enums.FeedComposerV1CollaborativeRecommendationsGetIsSharedProfile>?
            feedComposerV1CollaborativeRecommendationsGetIsSharedProfile) {
  if (feedComposerV1CollaborativeRecommendationsGetIsSharedProfile == null) {
    return [];
  }

  return feedComposerV1CollaborativeRecommendationsGetIsSharedProfile
      .map((e) => e.value!)
      .toList();
}

List<enums.FeedComposerV1CollaborativeRecommendationsGetIsSharedProfile>
    feedComposerV1CollaborativeRecommendationsGetIsSharedProfileListFromJson(
  List? feedComposerV1CollaborativeRecommendationsGetIsSharedProfile, [
  List<enums.FeedComposerV1CollaborativeRecommendationsGetIsSharedProfile>?
      defaultValue,
]) {
  if (feedComposerV1CollaborativeRecommendationsGetIsSharedProfile == null) {
    return defaultValue ?? [];
  }

  return feedComposerV1CollaborativeRecommendationsGetIsSharedProfile
      .map((e) =>
          feedComposerV1CollaborativeRecommendationsGetIsSharedProfileFromJson(
              e.toString()))
      .toList();
}

List<enums.FeedComposerV1CollaborativeRecommendationsGetIsSharedProfile>?
    feedComposerV1CollaborativeRecommendationsGetIsSharedProfileNullableListFromJson(
  List? feedComposerV1CollaborativeRecommendationsGetIsSharedProfile, [
  List<enums.FeedComposerV1CollaborativeRecommendationsGetIsSharedProfile>?
      defaultValue,
]) {
  if (feedComposerV1CollaborativeRecommendationsGetIsSharedProfile == null) {
    return defaultValue;
  }

  return feedComposerV1CollaborativeRecommendationsGetIsSharedProfile
      .map((e) =>
          feedComposerV1CollaborativeRecommendationsGetIsSharedProfileFromJson(
              e.toString()))
      .toList();
}

String? feedComposerV1CollaborativeRecommendationsGetEncodingToJson(
    enums.FeedComposerV1CollaborativeRecommendationsGetEncoding?
        feedComposerV1CollaborativeRecommendationsGetEncoding) {
  return feedComposerV1CollaborativeRecommendationsGetEncoding?.value;
}

enums.FeedComposerV1CollaborativeRecommendationsGetEncoding
    feedComposerV1CollaborativeRecommendationsGetEncodingFromJson(
  Object? feedComposerV1CollaborativeRecommendationsGetEncoding, [
  enums.FeedComposerV1CollaborativeRecommendationsGetEncoding? defaultValue,
]) {
  return enums.FeedComposerV1CollaborativeRecommendationsGetEncoding.values
          .firstWhereOrNull((e) =>
              e.value ==
              feedComposerV1CollaborativeRecommendationsGetEncoding) ??
      defaultValue ??
      enums.FeedComposerV1CollaborativeRecommendationsGetEncoding
          .swaggerGeneratedUnknown;
}

List<String> feedComposerV1CollaborativeRecommendationsGetEncodingListToJson(
    List<enums.FeedComposerV1CollaborativeRecommendationsGetEncoding>?
        feedComposerV1CollaborativeRecommendationsGetEncoding) {
  if (feedComposerV1CollaborativeRecommendationsGetEncoding == null) {
    return [];
  }

  return feedComposerV1CollaborativeRecommendationsGetEncoding
      .map((e) => e.value!)
      .toList();
}

List<enums.FeedComposerV1CollaborativeRecommendationsGetEncoding>
    feedComposerV1CollaborativeRecommendationsGetEncodingListFromJson(
  List? feedComposerV1CollaborativeRecommendationsGetEncoding, [
  List<enums.FeedComposerV1CollaborativeRecommendationsGetEncoding>?
      defaultValue,
]) {
  if (feedComposerV1CollaborativeRecommendationsGetEncoding == null) {
    return defaultValue ?? [];
  }

  return feedComposerV1CollaborativeRecommendationsGetEncoding
      .map((e) => feedComposerV1CollaborativeRecommendationsGetEncodingFromJson(
          e.toString()))
      .toList();
}

List<enums.FeedComposerV1CollaborativeRecommendationsGetEncoding>?
    feedComposerV1CollaborativeRecommendationsGetEncodingNullableListFromJson(
  List? feedComposerV1CollaborativeRecommendationsGetEncoding, [
  List<enums.FeedComposerV1CollaborativeRecommendationsGetEncoding>?
      defaultValue,
]) {
  if (feedComposerV1CollaborativeRecommendationsGetEncoding == null) {
    return defaultValue;
  }

  return feedComposerV1CollaborativeRecommendationsGetEncoding
      .map((e) => feedComposerV1CollaborativeRecommendationsGetEncodingFromJson(
          e.toString()))
      .toList();
}

String? feedComposerV1CollaborativeRecommendationsGetMaxResToJson(
    enums.FeedComposerV1CollaborativeRecommendationsGetMaxRes?
        feedComposerV1CollaborativeRecommendationsGetMaxRes) {
  return feedComposerV1CollaborativeRecommendationsGetMaxRes?.value;
}

enums.FeedComposerV1CollaborativeRecommendationsGetMaxRes
    feedComposerV1CollaborativeRecommendationsGetMaxResFromJson(
  Object? feedComposerV1CollaborativeRecommendationsGetMaxRes, [
  enums.FeedComposerV1CollaborativeRecommendationsGetMaxRes? defaultValue,
]) {
  return enums.FeedComposerV1CollaborativeRecommendationsGetMaxRes.values
          .firstWhereOrNull((e) =>
              e.value == feedComposerV1CollaborativeRecommendationsGetMaxRes) ??
      defaultValue ??
      enums.FeedComposerV1CollaborativeRecommendationsGetMaxRes
          .swaggerGeneratedUnknown;
}

List<String> feedComposerV1CollaborativeRecommendationsGetMaxResListToJson(
    List<enums.FeedComposerV1CollaborativeRecommendationsGetMaxRes>?
        feedComposerV1CollaborativeRecommendationsGetMaxRes) {
  if (feedComposerV1CollaborativeRecommendationsGetMaxRes == null) {
    return [];
  }

  return feedComposerV1CollaborativeRecommendationsGetMaxRes
      .map((e) => e.value!)
      .toList();
}

List<enums.FeedComposerV1CollaborativeRecommendationsGetMaxRes>
    feedComposerV1CollaborativeRecommendationsGetMaxResListFromJson(
  List? feedComposerV1CollaborativeRecommendationsGetMaxRes, [
  List<enums.FeedComposerV1CollaborativeRecommendationsGetMaxRes>? defaultValue,
]) {
  if (feedComposerV1CollaborativeRecommendationsGetMaxRes == null) {
    return defaultValue ?? [];
  }

  return feedComposerV1CollaborativeRecommendationsGetMaxRes
      .map((e) => feedComposerV1CollaborativeRecommendationsGetMaxResFromJson(
          e.toString()))
      .toList();
}

List<enums.FeedComposerV1CollaborativeRecommendationsGetMaxRes>?
    feedComposerV1CollaborativeRecommendationsGetMaxResNullableListFromJson(
  List? feedComposerV1CollaborativeRecommendationsGetMaxRes, [
  List<enums.FeedComposerV1CollaborativeRecommendationsGetMaxRes>? defaultValue,
]) {
  if (feedComposerV1CollaborativeRecommendationsGetMaxRes == null) {
    return defaultValue;
  }

  return feedComposerV1CollaborativeRecommendationsGetMaxRes
      .map((e) => feedComposerV1CollaborativeRecommendationsGetMaxResFromJson(
          e.toString()))
      .toList();
}

String? v2VodstructureRootIdGetEncodingToJson(
    enums.V2VodstructureRootIdGetEncoding? v2VodstructureRootIdGetEncoding) {
  return v2VodstructureRootIdGetEncoding?.value;
}

enums.V2VodstructureRootIdGetEncoding v2VodstructureRootIdGetEncodingFromJson(
  Object? v2VodstructureRootIdGetEncoding, [
  enums.V2VodstructureRootIdGetEncoding? defaultValue,
]) {
  return enums.V2VodstructureRootIdGetEncoding.values.firstWhereOrNull(
          (e) => e.value == v2VodstructureRootIdGetEncoding) ??
      defaultValue ??
      enums.V2VodstructureRootIdGetEncoding.swaggerGeneratedUnknown;
}

List<String> v2VodstructureRootIdGetEncodingListToJson(
    List<enums.V2VodstructureRootIdGetEncoding>?
        v2VodstructureRootIdGetEncoding) {
  if (v2VodstructureRootIdGetEncoding == null) {
    return [];
  }

  return v2VodstructureRootIdGetEncoding.map((e) => e.value!).toList();
}

List<enums.V2VodstructureRootIdGetEncoding>
    v2VodstructureRootIdGetEncodingListFromJson(
  List? v2VodstructureRootIdGetEncoding, [
  List<enums.V2VodstructureRootIdGetEncoding>? defaultValue,
]) {
  if (v2VodstructureRootIdGetEncoding == null) {
    return defaultValue ?? [];
  }

  return v2VodstructureRootIdGetEncoding
      .map((e) => v2VodstructureRootIdGetEncodingFromJson(e.toString()))
      .toList();
}

List<enums.V2VodstructureRootIdGetEncoding>?
    v2VodstructureRootIdGetEncodingNullableListFromJson(
  List? v2VodstructureRootIdGetEncoding, [
  List<enums.V2VodstructureRootIdGetEncoding>? defaultValue,
]) {
  if (v2VodstructureRootIdGetEncoding == null) {
    return defaultValue;
  }

  return v2VodstructureRootIdGetEncoding
      .map((e) => v2VodstructureRootIdGetEncodingFromJson(e.toString()))
      .toList();
}

String? v2VodstructureRootIdGetMaxResToJson(
    enums.V2VodstructureRootIdGetMaxRes? v2VodstructureRootIdGetMaxRes) {
  return v2VodstructureRootIdGetMaxRes?.value;
}

enums.V2VodstructureRootIdGetMaxRes v2VodstructureRootIdGetMaxResFromJson(
  Object? v2VodstructureRootIdGetMaxRes, [
  enums.V2VodstructureRootIdGetMaxRes? defaultValue,
]) {
  return enums.V2VodstructureRootIdGetMaxRes.values
          .firstWhereOrNull((e) => e.value == v2VodstructureRootIdGetMaxRes) ??
      defaultValue ??
      enums.V2VodstructureRootIdGetMaxRes.swaggerGeneratedUnknown;
}

List<String> v2VodstructureRootIdGetMaxResListToJson(
    List<enums.V2VodstructureRootIdGetMaxRes>? v2VodstructureRootIdGetMaxRes) {
  if (v2VodstructureRootIdGetMaxRes == null) {
    return [];
  }

  return v2VodstructureRootIdGetMaxRes.map((e) => e.value!).toList();
}

List<enums.V2VodstructureRootIdGetMaxRes>
    v2VodstructureRootIdGetMaxResListFromJson(
  List? v2VodstructureRootIdGetMaxRes, [
  List<enums.V2VodstructureRootIdGetMaxRes>? defaultValue,
]) {
  if (v2VodstructureRootIdGetMaxRes == null) {
    return defaultValue ?? [];
  }

  return v2VodstructureRootIdGetMaxRes
      .map((e) => v2VodstructureRootIdGetMaxResFromJson(e.toString()))
      .toList();
}

List<enums.V2VodstructureRootIdGetMaxRes>?
    v2VodstructureRootIdGetMaxResNullableListFromJson(
  List? v2VodstructureRootIdGetMaxRes, [
  List<enums.V2VodstructureRootIdGetMaxRes>? defaultValue,
]) {
  if (v2VodstructureRootIdGetMaxRes == null) {
    return defaultValue;
  }

  return v2VodstructureRootIdGetMaxRes
      .map((e) => v2VodstructureRootIdGetMaxResFromJson(e.toString()))
      .toList();
}

String? v2ContextualvodRootIdGetEncodingToJson(
    enums.V2ContextualvodRootIdGetEncoding? v2ContextualvodRootIdGetEncoding) {
  return v2ContextualvodRootIdGetEncoding?.value;
}

enums.V2ContextualvodRootIdGetEncoding v2ContextualvodRootIdGetEncodingFromJson(
  Object? v2ContextualvodRootIdGetEncoding, [
  enums.V2ContextualvodRootIdGetEncoding? defaultValue,
]) {
  return enums.V2ContextualvodRootIdGetEncoding.values.firstWhereOrNull(
          (e) => e.value == v2ContextualvodRootIdGetEncoding) ??
      defaultValue ??
      enums.V2ContextualvodRootIdGetEncoding.swaggerGeneratedUnknown;
}

List<String> v2ContextualvodRootIdGetEncodingListToJson(
    List<enums.V2ContextualvodRootIdGetEncoding>?
        v2ContextualvodRootIdGetEncoding) {
  if (v2ContextualvodRootIdGetEncoding == null) {
    return [];
  }

  return v2ContextualvodRootIdGetEncoding.map((e) => e.value!).toList();
}

List<enums.V2ContextualvodRootIdGetEncoding>
    v2ContextualvodRootIdGetEncodingListFromJson(
  List? v2ContextualvodRootIdGetEncoding, [
  List<enums.V2ContextualvodRootIdGetEncoding>? defaultValue,
]) {
  if (v2ContextualvodRootIdGetEncoding == null) {
    return defaultValue ?? [];
  }

  return v2ContextualvodRootIdGetEncoding
      .map((e) => v2ContextualvodRootIdGetEncodingFromJson(e.toString()))
      .toList();
}

List<enums.V2ContextualvodRootIdGetEncoding>?
    v2ContextualvodRootIdGetEncodingNullableListFromJson(
  List? v2ContextualvodRootIdGetEncoding, [
  List<enums.V2ContextualvodRootIdGetEncoding>? defaultValue,
]) {
  if (v2ContextualvodRootIdGetEncoding == null) {
    return defaultValue;
  }

  return v2ContextualvodRootIdGetEncoding
      .map((e) => v2ContextualvodRootIdGetEncodingFromJson(e.toString()))
      .toList();
}

String? v2ContextualvodRootIdGetMaxResToJson(
    enums.V2ContextualvodRootIdGetMaxRes? v2ContextualvodRootIdGetMaxRes) {
  return v2ContextualvodRootIdGetMaxRes?.value;
}

enums.V2ContextualvodRootIdGetMaxRes v2ContextualvodRootIdGetMaxResFromJson(
  Object? v2ContextualvodRootIdGetMaxRes, [
  enums.V2ContextualvodRootIdGetMaxRes? defaultValue,
]) {
  return enums.V2ContextualvodRootIdGetMaxRes.values
          .firstWhereOrNull((e) => e.value == v2ContextualvodRootIdGetMaxRes) ??
      defaultValue ??
      enums.V2ContextualvodRootIdGetMaxRes.swaggerGeneratedUnknown;
}

List<String> v2ContextualvodRootIdGetMaxResListToJson(
    List<enums.V2ContextualvodRootIdGetMaxRes>?
        v2ContextualvodRootIdGetMaxRes) {
  if (v2ContextualvodRootIdGetMaxRes == null) {
    return [];
  }

  return v2ContextualvodRootIdGetMaxRes.map((e) => e.value!).toList();
}

List<enums.V2ContextualvodRootIdGetMaxRes>
    v2ContextualvodRootIdGetMaxResListFromJson(
  List? v2ContextualvodRootIdGetMaxRes, [
  List<enums.V2ContextualvodRootIdGetMaxRes>? defaultValue,
]) {
  if (v2ContextualvodRootIdGetMaxRes == null) {
    return defaultValue ?? [];
  }

  return v2ContextualvodRootIdGetMaxRes
      .map((e) => v2ContextualvodRootIdGetMaxResFromJson(e.toString()))
      .toList();
}

List<enums.V2ContextualvodRootIdGetMaxRes>?
    v2ContextualvodRootIdGetMaxResNullableListFromJson(
  List? v2ContextualvodRootIdGetMaxRes, [
  List<enums.V2ContextualvodRootIdGetMaxRes>? defaultValue,
]) {
  if (v2ContextualvodRootIdGetMaxRes == null) {
    return defaultValue;
  }

  return v2ContextualvodRootIdGetMaxRes
      .map((e) => v2ContextualvodRootIdGetMaxResFromJson(e.toString()))
      .toList();
}

String? v2RentalsGetEncodingToJson(
    enums.V2RentalsGetEncoding? v2RentalsGetEncoding) {
  return v2RentalsGetEncoding?.value;
}

enums.V2RentalsGetEncoding v2RentalsGetEncodingFromJson(
  Object? v2RentalsGetEncoding, [
  enums.V2RentalsGetEncoding? defaultValue,
]) {
  return enums.V2RentalsGetEncoding.values
          .firstWhereOrNull((e) => e.value == v2RentalsGetEncoding) ??
      defaultValue ??
      enums.V2RentalsGetEncoding.swaggerGeneratedUnknown;
}

List<String> v2RentalsGetEncodingListToJson(
    List<enums.V2RentalsGetEncoding>? v2RentalsGetEncoding) {
  if (v2RentalsGetEncoding == null) {
    return [];
  }

  return v2RentalsGetEncoding.map((e) => e.value!).toList();
}

List<enums.V2RentalsGetEncoding> v2RentalsGetEncodingListFromJson(
  List? v2RentalsGetEncoding, [
  List<enums.V2RentalsGetEncoding>? defaultValue,
]) {
  if (v2RentalsGetEncoding == null) {
    return defaultValue ?? [];
  }

  return v2RentalsGetEncoding
      .map((e) => v2RentalsGetEncodingFromJson(e.toString()))
      .toList();
}

List<enums.V2RentalsGetEncoding>? v2RentalsGetEncodingNullableListFromJson(
  List? v2RentalsGetEncoding, [
  List<enums.V2RentalsGetEncoding>? defaultValue,
]) {
  if (v2RentalsGetEncoding == null) {
    return defaultValue;
  }

  return v2RentalsGetEncoding
      .map((e) => v2RentalsGetEncodingFromJson(e.toString()))
      .toList();
}

String? v2RentalsGetMaxResToJson(enums.V2RentalsGetMaxRes? v2RentalsGetMaxRes) {
  return v2RentalsGetMaxRes?.value;
}

enums.V2RentalsGetMaxRes v2RentalsGetMaxResFromJson(
  Object? v2RentalsGetMaxRes, [
  enums.V2RentalsGetMaxRes? defaultValue,
]) {
  return enums.V2RentalsGetMaxRes.values
          .firstWhereOrNull((e) => e.value == v2RentalsGetMaxRes) ??
      defaultValue ??
      enums.V2RentalsGetMaxRes.swaggerGeneratedUnknown;
}

List<String> v2RentalsGetMaxResListToJson(
    List<enums.V2RentalsGetMaxRes>? v2RentalsGetMaxRes) {
  if (v2RentalsGetMaxRes == null) {
    return [];
  }

  return v2RentalsGetMaxRes.map((e) => e.value!).toList();
}

List<enums.V2RentalsGetMaxRes> v2RentalsGetMaxResListFromJson(
  List? v2RentalsGetMaxRes, [
  List<enums.V2RentalsGetMaxRes>? defaultValue,
]) {
  if (v2RentalsGetMaxRes == null) {
    return defaultValue ?? [];
  }

  return v2RentalsGetMaxRes
      .map((e) => v2RentalsGetMaxResFromJson(e.toString()))
      .toList();
}

List<enums.V2RentalsGetMaxRes>? v2RentalsGetMaxResNullableListFromJson(
  List? v2RentalsGetMaxRes, [
  List<enums.V2RentalsGetMaxRes>? defaultValue,
]) {
  if (v2RentalsGetMaxRes == null) {
    return defaultValue;
  }

  return v2RentalsGetMaxRes
      .map((e) => v2RentalsGetMaxResFromJson(e.toString()))
      .toList();
}

String? v2DetailscreenCridGetEncodingToJson(
    enums.V2DetailscreenCridGetEncoding? v2DetailscreenCridGetEncoding) {
  return v2DetailscreenCridGetEncoding?.value;
}

enums.V2DetailscreenCridGetEncoding v2DetailscreenCridGetEncodingFromJson(
  Object? v2DetailscreenCridGetEncoding, [
  enums.V2DetailscreenCridGetEncoding? defaultValue,
]) {
  return enums.V2DetailscreenCridGetEncoding.values
          .firstWhereOrNull((e) => e.value == v2DetailscreenCridGetEncoding) ??
      defaultValue ??
      enums.V2DetailscreenCridGetEncoding.swaggerGeneratedUnknown;
}

List<String> v2DetailscreenCridGetEncodingListToJson(
    List<enums.V2DetailscreenCridGetEncoding>? v2DetailscreenCridGetEncoding) {
  if (v2DetailscreenCridGetEncoding == null) {
    return [];
  }

  return v2DetailscreenCridGetEncoding.map((e) => e.value!).toList();
}

List<enums.V2DetailscreenCridGetEncoding>
    v2DetailscreenCridGetEncodingListFromJson(
  List? v2DetailscreenCridGetEncoding, [
  List<enums.V2DetailscreenCridGetEncoding>? defaultValue,
]) {
  if (v2DetailscreenCridGetEncoding == null) {
    return defaultValue ?? [];
  }

  return v2DetailscreenCridGetEncoding
      .map((e) => v2DetailscreenCridGetEncodingFromJson(e.toString()))
      .toList();
}

List<enums.V2DetailscreenCridGetEncoding>?
    v2DetailscreenCridGetEncodingNullableListFromJson(
  List? v2DetailscreenCridGetEncoding, [
  List<enums.V2DetailscreenCridGetEncoding>? defaultValue,
]) {
  if (v2DetailscreenCridGetEncoding == null) {
    return defaultValue;
  }

  return v2DetailscreenCridGetEncoding
      .map((e) => v2DetailscreenCridGetEncodingFromJson(e.toString()))
      .toList();
}

String? v2DetailscreenCridGetMaxResToJson(
    enums.V2DetailscreenCridGetMaxRes? v2DetailscreenCridGetMaxRes) {
  return v2DetailscreenCridGetMaxRes?.value;
}

enums.V2DetailscreenCridGetMaxRes v2DetailscreenCridGetMaxResFromJson(
  Object? v2DetailscreenCridGetMaxRes, [
  enums.V2DetailscreenCridGetMaxRes? defaultValue,
]) {
  return enums.V2DetailscreenCridGetMaxRes.values
          .firstWhereOrNull((e) => e.value == v2DetailscreenCridGetMaxRes) ??
      defaultValue ??
      enums.V2DetailscreenCridGetMaxRes.swaggerGeneratedUnknown;
}

List<String> v2DetailscreenCridGetMaxResListToJson(
    List<enums.V2DetailscreenCridGetMaxRes>? v2DetailscreenCridGetMaxRes) {
  if (v2DetailscreenCridGetMaxRes == null) {
    return [];
  }

  return v2DetailscreenCridGetMaxRes.map((e) => e.value!).toList();
}

List<enums.V2DetailscreenCridGetMaxRes> v2DetailscreenCridGetMaxResListFromJson(
  List? v2DetailscreenCridGetMaxRes, [
  List<enums.V2DetailscreenCridGetMaxRes>? defaultValue,
]) {
  if (v2DetailscreenCridGetMaxRes == null) {
    return defaultValue ?? [];
  }

  return v2DetailscreenCridGetMaxRes
      .map((e) => v2DetailscreenCridGetMaxResFromJson(e.toString()))
      .toList();
}

List<enums.V2DetailscreenCridGetMaxRes>?
    v2DetailscreenCridGetMaxResNullableListFromJson(
  List? v2DetailscreenCridGetMaxRes, [
  List<enums.V2DetailscreenCridGetMaxRes>? defaultValue,
]) {
  if (v2DetailscreenCridGetMaxRes == null) {
    return defaultValue;
  }

  return v2DetailscreenCridGetMaxRes
      .map((e) => v2DetailscreenCridGetMaxResFromJson(e.toString()))
      .toList();
}

String? v2TrailerDetailsTrailerCridGetEncodingToJson(
    enums.V2TrailerDetailsTrailerCridGetEncoding?
        v2TrailerDetailsTrailerCridGetEncoding) {
  return v2TrailerDetailsTrailerCridGetEncoding?.value;
}

enums.V2TrailerDetailsTrailerCridGetEncoding
    v2TrailerDetailsTrailerCridGetEncodingFromJson(
  Object? v2TrailerDetailsTrailerCridGetEncoding, [
  enums.V2TrailerDetailsTrailerCridGetEncoding? defaultValue,
]) {
  return enums.V2TrailerDetailsTrailerCridGetEncoding.values.firstWhereOrNull(
          (e) => e.value == v2TrailerDetailsTrailerCridGetEncoding) ??
      defaultValue ??
      enums.V2TrailerDetailsTrailerCridGetEncoding.swaggerGeneratedUnknown;
}

List<String> v2TrailerDetailsTrailerCridGetEncodingListToJson(
    List<enums.V2TrailerDetailsTrailerCridGetEncoding>?
        v2TrailerDetailsTrailerCridGetEncoding) {
  if (v2TrailerDetailsTrailerCridGetEncoding == null) {
    return [];
  }

  return v2TrailerDetailsTrailerCridGetEncoding.map((e) => e.value!).toList();
}

List<enums.V2TrailerDetailsTrailerCridGetEncoding>
    v2TrailerDetailsTrailerCridGetEncodingListFromJson(
  List? v2TrailerDetailsTrailerCridGetEncoding, [
  List<enums.V2TrailerDetailsTrailerCridGetEncoding>? defaultValue,
]) {
  if (v2TrailerDetailsTrailerCridGetEncoding == null) {
    return defaultValue ?? [];
  }

  return v2TrailerDetailsTrailerCridGetEncoding
      .map((e) => v2TrailerDetailsTrailerCridGetEncodingFromJson(e.toString()))
      .toList();
}

List<enums.V2TrailerDetailsTrailerCridGetEncoding>?
    v2TrailerDetailsTrailerCridGetEncodingNullableListFromJson(
  List? v2TrailerDetailsTrailerCridGetEncoding, [
  List<enums.V2TrailerDetailsTrailerCridGetEncoding>? defaultValue,
]) {
  if (v2TrailerDetailsTrailerCridGetEncoding == null) {
    return defaultValue;
  }

  return v2TrailerDetailsTrailerCridGetEncoding
      .map((e) => v2TrailerDetailsTrailerCridGetEncodingFromJson(e.toString()))
      .toList();
}

String? v2TrailerDetailsTrailerCridGetMaxResToJson(
    enums.V2TrailerDetailsTrailerCridGetMaxRes?
        v2TrailerDetailsTrailerCridGetMaxRes) {
  return v2TrailerDetailsTrailerCridGetMaxRes?.value;
}

enums.V2TrailerDetailsTrailerCridGetMaxRes
    v2TrailerDetailsTrailerCridGetMaxResFromJson(
  Object? v2TrailerDetailsTrailerCridGetMaxRes, [
  enums.V2TrailerDetailsTrailerCridGetMaxRes? defaultValue,
]) {
  return enums.V2TrailerDetailsTrailerCridGetMaxRes.values.firstWhereOrNull(
          (e) => e.value == v2TrailerDetailsTrailerCridGetMaxRes) ??
      defaultValue ??
      enums.V2TrailerDetailsTrailerCridGetMaxRes.swaggerGeneratedUnknown;
}

List<String> v2TrailerDetailsTrailerCridGetMaxResListToJson(
    List<enums.V2TrailerDetailsTrailerCridGetMaxRes>?
        v2TrailerDetailsTrailerCridGetMaxRes) {
  if (v2TrailerDetailsTrailerCridGetMaxRes == null) {
    return [];
  }

  return v2TrailerDetailsTrailerCridGetMaxRes.map((e) => e.value!).toList();
}

List<enums.V2TrailerDetailsTrailerCridGetMaxRes>
    v2TrailerDetailsTrailerCridGetMaxResListFromJson(
  List? v2TrailerDetailsTrailerCridGetMaxRes, [
  List<enums.V2TrailerDetailsTrailerCridGetMaxRes>? defaultValue,
]) {
  if (v2TrailerDetailsTrailerCridGetMaxRes == null) {
    return defaultValue ?? [];
  }

  return v2TrailerDetailsTrailerCridGetMaxRes
      .map((e) => v2TrailerDetailsTrailerCridGetMaxResFromJson(e.toString()))
      .toList();
}

List<enums.V2TrailerDetailsTrailerCridGetMaxRes>?
    v2TrailerDetailsTrailerCridGetMaxResNullableListFromJson(
  List? v2TrailerDetailsTrailerCridGetMaxRes, [
  List<enums.V2TrailerDetailsTrailerCridGetMaxRes>? defaultValue,
]) {
  if (v2TrailerDetailsTrailerCridGetMaxRes == null) {
    return defaultValue;
  }

  return v2TrailerDetailsTrailerCridGetMaxRes
      .map((e) => v2TrailerDetailsTrailerCridGetMaxResFromJson(e.toString()))
      .toList();
}

String? v2GridoptionsCridGetEncodingToJson(
    enums.V2GridoptionsCridGetEncoding? v2GridoptionsCridGetEncoding) {
  return v2GridoptionsCridGetEncoding?.value;
}

enums.V2GridoptionsCridGetEncoding v2GridoptionsCridGetEncodingFromJson(
  Object? v2GridoptionsCridGetEncoding, [
  enums.V2GridoptionsCridGetEncoding? defaultValue,
]) {
  return enums.V2GridoptionsCridGetEncoding.values
          .firstWhereOrNull((e) => e.value == v2GridoptionsCridGetEncoding) ??
      defaultValue ??
      enums.V2GridoptionsCridGetEncoding.swaggerGeneratedUnknown;
}

List<String> v2GridoptionsCridGetEncodingListToJson(
    List<enums.V2GridoptionsCridGetEncoding>? v2GridoptionsCridGetEncoding) {
  if (v2GridoptionsCridGetEncoding == null) {
    return [];
  }

  return v2GridoptionsCridGetEncoding.map((e) => e.value!).toList();
}

List<enums.V2GridoptionsCridGetEncoding>
    v2GridoptionsCridGetEncodingListFromJson(
  List? v2GridoptionsCridGetEncoding, [
  List<enums.V2GridoptionsCridGetEncoding>? defaultValue,
]) {
  if (v2GridoptionsCridGetEncoding == null) {
    return defaultValue ?? [];
  }

  return v2GridoptionsCridGetEncoding
      .map((e) => v2GridoptionsCridGetEncodingFromJson(e.toString()))
      .toList();
}

List<enums.V2GridoptionsCridGetEncoding>?
    v2GridoptionsCridGetEncodingNullableListFromJson(
  List? v2GridoptionsCridGetEncoding, [
  List<enums.V2GridoptionsCridGetEncoding>? defaultValue,
]) {
  if (v2GridoptionsCridGetEncoding == null) {
    return defaultValue;
  }

  return v2GridoptionsCridGetEncoding
      .map((e) => v2GridoptionsCridGetEncodingFromJson(e.toString()))
      .toList();
}

String? v2GridoptionsCridGetMaxResToJson(
    enums.V2GridoptionsCridGetMaxRes? v2GridoptionsCridGetMaxRes) {
  return v2GridoptionsCridGetMaxRes?.value;
}

enums.V2GridoptionsCridGetMaxRes v2GridoptionsCridGetMaxResFromJson(
  Object? v2GridoptionsCridGetMaxRes, [
  enums.V2GridoptionsCridGetMaxRes? defaultValue,
]) {
  return enums.V2GridoptionsCridGetMaxRes.values
          .firstWhereOrNull((e) => e.value == v2GridoptionsCridGetMaxRes) ??
      defaultValue ??
      enums.V2GridoptionsCridGetMaxRes.swaggerGeneratedUnknown;
}

List<String> v2GridoptionsCridGetMaxResListToJson(
    List<enums.V2GridoptionsCridGetMaxRes>? v2GridoptionsCridGetMaxRes) {
  if (v2GridoptionsCridGetMaxRes == null) {
    return [];
  }

  return v2GridoptionsCridGetMaxRes.map((e) => e.value!).toList();
}

List<enums.V2GridoptionsCridGetMaxRes> v2GridoptionsCridGetMaxResListFromJson(
  List? v2GridoptionsCridGetMaxRes, [
  List<enums.V2GridoptionsCridGetMaxRes>? defaultValue,
]) {
  if (v2GridoptionsCridGetMaxRes == null) {
    return defaultValue ?? [];
  }

  return v2GridoptionsCridGetMaxRes
      .map((e) => v2GridoptionsCridGetMaxResFromJson(e.toString()))
      .toList();
}

List<enums.V2GridoptionsCridGetMaxRes>?
    v2GridoptionsCridGetMaxResNullableListFromJson(
  List? v2GridoptionsCridGetMaxRes, [
  List<enums.V2GridoptionsCridGetMaxRes>? defaultValue,
]) {
  if (v2GridoptionsCridGetMaxRes == null) {
    return defaultValue;
  }

  return v2GridoptionsCridGetMaxRes
      .map((e) => v2GridoptionsCridGetMaxResFromJson(e.toString()))
      .toList();
}

String? v2GridscreenRootIdCridGetSortTypeToJson(
    enums.V2GridscreenRootIdCridGetSortType?
        v2GridscreenRootIdCridGetSortType) {
  return v2GridscreenRootIdCridGetSortType?.value;
}

enums.V2GridscreenRootIdCridGetSortType
    v2GridscreenRootIdCridGetSortTypeFromJson(
  Object? v2GridscreenRootIdCridGetSortType, [
  enums.V2GridscreenRootIdCridGetSortType? defaultValue,
]) {
  return enums.V2GridscreenRootIdCridGetSortType.values.firstWhereOrNull(
          (e) => e.value == v2GridscreenRootIdCridGetSortType) ??
      defaultValue ??
      enums.V2GridscreenRootIdCridGetSortType.swaggerGeneratedUnknown;
}

List<String> v2GridscreenRootIdCridGetSortTypeListToJson(
    List<enums.V2GridscreenRootIdCridGetSortType>?
        v2GridscreenRootIdCridGetSortType) {
  if (v2GridscreenRootIdCridGetSortType == null) {
    return [];
  }

  return v2GridscreenRootIdCridGetSortType.map((e) => e.value!).toList();
}

List<enums.V2GridscreenRootIdCridGetSortType>
    v2GridscreenRootIdCridGetSortTypeListFromJson(
  List? v2GridscreenRootIdCridGetSortType, [
  List<enums.V2GridscreenRootIdCridGetSortType>? defaultValue,
]) {
  if (v2GridscreenRootIdCridGetSortType == null) {
    return defaultValue ?? [];
  }

  return v2GridscreenRootIdCridGetSortType
      .map((e) => v2GridscreenRootIdCridGetSortTypeFromJson(e.toString()))
      .toList();
}

List<enums.V2GridscreenRootIdCridGetSortType>?
    v2GridscreenRootIdCridGetSortTypeNullableListFromJson(
  List? v2GridscreenRootIdCridGetSortType, [
  List<enums.V2GridscreenRootIdCridGetSortType>? defaultValue,
]) {
  if (v2GridscreenRootIdCridGetSortType == null) {
    return defaultValue;
  }

  return v2GridscreenRootIdCridGetSortType
      .map((e) => v2GridscreenRootIdCridGetSortTypeFromJson(e.toString()))
      .toList();
}

String? v2GridscreenRootIdCridGetSortDirectionToJson(
    enums.V2GridscreenRootIdCridGetSortDirection?
        v2GridscreenRootIdCridGetSortDirection) {
  return v2GridscreenRootIdCridGetSortDirection?.value;
}

enums.V2GridscreenRootIdCridGetSortDirection
    v2GridscreenRootIdCridGetSortDirectionFromJson(
  Object? v2GridscreenRootIdCridGetSortDirection, [
  enums.V2GridscreenRootIdCridGetSortDirection? defaultValue,
]) {
  return enums.V2GridscreenRootIdCridGetSortDirection.values.firstWhereOrNull(
          (e) => e.value == v2GridscreenRootIdCridGetSortDirection) ??
      defaultValue ??
      enums.V2GridscreenRootIdCridGetSortDirection.swaggerGeneratedUnknown;
}

List<String> v2GridscreenRootIdCridGetSortDirectionListToJson(
    List<enums.V2GridscreenRootIdCridGetSortDirection>?
        v2GridscreenRootIdCridGetSortDirection) {
  if (v2GridscreenRootIdCridGetSortDirection == null) {
    return [];
  }

  return v2GridscreenRootIdCridGetSortDirection.map((e) => e.value!).toList();
}

List<enums.V2GridscreenRootIdCridGetSortDirection>
    v2GridscreenRootIdCridGetSortDirectionListFromJson(
  List? v2GridscreenRootIdCridGetSortDirection, [
  List<enums.V2GridscreenRootIdCridGetSortDirection>? defaultValue,
]) {
  if (v2GridscreenRootIdCridGetSortDirection == null) {
    return defaultValue ?? [];
  }

  return v2GridscreenRootIdCridGetSortDirection
      .map((e) => v2GridscreenRootIdCridGetSortDirectionFromJson(e.toString()))
      .toList();
}

List<enums.V2GridscreenRootIdCridGetSortDirection>?
    v2GridscreenRootIdCridGetSortDirectionNullableListFromJson(
  List? v2GridscreenRootIdCridGetSortDirection, [
  List<enums.V2GridscreenRootIdCridGetSortDirection>? defaultValue,
]) {
  if (v2GridscreenRootIdCridGetSortDirection == null) {
    return defaultValue;
  }

  return v2GridscreenRootIdCridGetSortDirection
      .map((e) => v2GridscreenRootIdCridGetSortDirectionFromJson(e.toString()))
      .toList();
}

String? v2GridscreenRootIdCridGetFilterTypeToJson(
    enums.V2GridscreenRootIdCridGetFilterType?
        v2GridscreenRootIdCridGetFilterType) {
  return v2GridscreenRootIdCridGetFilterType?.value;
}

enums.V2GridscreenRootIdCridGetFilterType
    v2GridscreenRootIdCridGetFilterTypeFromJson(
  Object? v2GridscreenRootIdCridGetFilterType, [
  enums.V2GridscreenRootIdCridGetFilterType? defaultValue,
]) {
  return enums.V2GridscreenRootIdCridGetFilterType.values.firstWhereOrNull(
          (e) => e.value == v2GridscreenRootIdCridGetFilterType) ??
      defaultValue ??
      enums.V2GridscreenRootIdCridGetFilterType.swaggerGeneratedUnknown;
}

List<String> v2GridscreenRootIdCridGetFilterTypeListToJson(
    List<enums.V2GridscreenRootIdCridGetFilterType>?
        v2GridscreenRootIdCridGetFilterType) {
  if (v2GridscreenRootIdCridGetFilterType == null) {
    return [];
  }

  return v2GridscreenRootIdCridGetFilterType.map((e) => e.value!).toList();
}

List<enums.V2GridscreenRootIdCridGetFilterType>
    v2GridscreenRootIdCridGetFilterTypeListFromJson(
  List? v2GridscreenRootIdCridGetFilterType, [
  List<enums.V2GridscreenRootIdCridGetFilterType>? defaultValue,
]) {
  if (v2GridscreenRootIdCridGetFilterType == null) {
    return defaultValue ?? [];
  }

  return v2GridscreenRootIdCridGetFilterType
      .map((e) => v2GridscreenRootIdCridGetFilterTypeFromJson(e.toString()))
      .toList();
}

List<enums.V2GridscreenRootIdCridGetFilterType>?
    v2GridscreenRootIdCridGetFilterTypeNullableListFromJson(
  List? v2GridscreenRootIdCridGetFilterType, [
  List<enums.V2GridscreenRootIdCridGetFilterType>? defaultValue,
]) {
  if (v2GridscreenRootIdCridGetFilterType == null) {
    return defaultValue;
  }

  return v2GridscreenRootIdCridGetFilterType
      .map((e) => v2GridscreenRootIdCridGetFilterTypeFromJson(e.toString()))
      .toList();
}

String? v2GridscreenRootIdCridGetEncodingToJson(
    enums.V2GridscreenRootIdCridGetEncoding?
        v2GridscreenRootIdCridGetEncoding) {
  return v2GridscreenRootIdCridGetEncoding?.value;
}

enums.V2GridscreenRootIdCridGetEncoding
    v2GridscreenRootIdCridGetEncodingFromJson(
  Object? v2GridscreenRootIdCridGetEncoding, [
  enums.V2GridscreenRootIdCridGetEncoding? defaultValue,
]) {
  return enums.V2GridscreenRootIdCridGetEncoding.values.firstWhereOrNull(
          (e) => e.value == v2GridscreenRootIdCridGetEncoding) ??
      defaultValue ??
      enums.V2GridscreenRootIdCridGetEncoding.swaggerGeneratedUnknown;
}

List<String> v2GridscreenRootIdCridGetEncodingListToJson(
    List<enums.V2GridscreenRootIdCridGetEncoding>?
        v2GridscreenRootIdCridGetEncoding) {
  if (v2GridscreenRootIdCridGetEncoding == null) {
    return [];
  }

  return v2GridscreenRootIdCridGetEncoding.map((e) => e.value!).toList();
}

List<enums.V2GridscreenRootIdCridGetEncoding>
    v2GridscreenRootIdCridGetEncodingListFromJson(
  List? v2GridscreenRootIdCridGetEncoding, [
  List<enums.V2GridscreenRootIdCridGetEncoding>? defaultValue,
]) {
  if (v2GridscreenRootIdCridGetEncoding == null) {
    return defaultValue ?? [];
  }

  return v2GridscreenRootIdCridGetEncoding
      .map((e) => v2GridscreenRootIdCridGetEncodingFromJson(e.toString()))
      .toList();
}

List<enums.V2GridscreenRootIdCridGetEncoding>?
    v2GridscreenRootIdCridGetEncodingNullableListFromJson(
  List? v2GridscreenRootIdCridGetEncoding, [
  List<enums.V2GridscreenRootIdCridGetEncoding>? defaultValue,
]) {
  if (v2GridscreenRootIdCridGetEncoding == null) {
    return defaultValue;
  }

  return v2GridscreenRootIdCridGetEncoding
      .map((e) => v2GridscreenRootIdCridGetEncodingFromJson(e.toString()))
      .toList();
}

String? v2GridscreenRootIdCridGetMaxResToJson(
    enums.V2GridscreenRootIdCridGetMaxRes? v2GridscreenRootIdCridGetMaxRes) {
  return v2GridscreenRootIdCridGetMaxRes?.value;
}

enums.V2GridscreenRootIdCridGetMaxRes v2GridscreenRootIdCridGetMaxResFromJson(
  Object? v2GridscreenRootIdCridGetMaxRes, [
  enums.V2GridscreenRootIdCridGetMaxRes? defaultValue,
]) {
  return enums.V2GridscreenRootIdCridGetMaxRes.values.firstWhereOrNull(
          (e) => e.value == v2GridscreenRootIdCridGetMaxRes) ??
      defaultValue ??
      enums.V2GridscreenRootIdCridGetMaxRes.swaggerGeneratedUnknown;
}

List<String> v2GridscreenRootIdCridGetMaxResListToJson(
    List<enums.V2GridscreenRootIdCridGetMaxRes>?
        v2GridscreenRootIdCridGetMaxRes) {
  if (v2GridscreenRootIdCridGetMaxRes == null) {
    return [];
  }

  return v2GridscreenRootIdCridGetMaxRes.map((e) => e.value!).toList();
}

List<enums.V2GridscreenRootIdCridGetMaxRes>
    v2GridscreenRootIdCridGetMaxResListFromJson(
  List? v2GridscreenRootIdCridGetMaxRes, [
  List<enums.V2GridscreenRootIdCridGetMaxRes>? defaultValue,
]) {
  if (v2GridscreenRootIdCridGetMaxRes == null) {
    return defaultValue ?? [];
  }

  return v2GridscreenRootIdCridGetMaxRes
      .map((e) => v2GridscreenRootIdCridGetMaxResFromJson(e.toString()))
      .toList();
}

List<enums.V2GridscreenRootIdCridGetMaxRes>?
    v2GridscreenRootIdCridGetMaxResNullableListFromJson(
  List? v2GridscreenRootIdCridGetMaxRes, [
  List<enums.V2GridscreenRootIdCridGetMaxRes>? defaultValue,
]) {
  if (v2GridscreenRootIdCridGetMaxRes == null) {
    return defaultValue;
  }

  return v2GridscreenRootIdCridGetMaxRes
      .map((e) => v2GridscreenRootIdCridGetMaxResFromJson(e.toString()))
      .toList();
}

String? v2NextepisodeGetEncodingToJson(
    enums.V2NextepisodeGetEncoding? v2NextepisodeGetEncoding) {
  return v2NextepisodeGetEncoding?.value;
}

enums.V2NextepisodeGetEncoding v2NextepisodeGetEncodingFromJson(
  Object? v2NextepisodeGetEncoding, [
  enums.V2NextepisodeGetEncoding? defaultValue,
]) {
  return enums.V2NextepisodeGetEncoding.values
          .firstWhereOrNull((e) => e.value == v2NextepisodeGetEncoding) ??
      defaultValue ??
      enums.V2NextepisodeGetEncoding.swaggerGeneratedUnknown;
}

List<String> v2NextepisodeGetEncodingListToJson(
    List<enums.V2NextepisodeGetEncoding>? v2NextepisodeGetEncoding) {
  if (v2NextepisodeGetEncoding == null) {
    return [];
  }

  return v2NextepisodeGetEncoding.map((e) => e.value!).toList();
}

List<enums.V2NextepisodeGetEncoding> v2NextepisodeGetEncodingListFromJson(
  List? v2NextepisodeGetEncoding, [
  List<enums.V2NextepisodeGetEncoding>? defaultValue,
]) {
  if (v2NextepisodeGetEncoding == null) {
    return defaultValue ?? [];
  }

  return v2NextepisodeGetEncoding
      .map((e) => v2NextepisodeGetEncodingFromJson(e.toString()))
      .toList();
}

List<enums.V2NextepisodeGetEncoding>?
    v2NextepisodeGetEncodingNullableListFromJson(
  List? v2NextepisodeGetEncoding, [
  List<enums.V2NextepisodeGetEncoding>? defaultValue,
]) {
  if (v2NextepisodeGetEncoding == null) {
    return defaultValue;
  }

  return v2NextepisodeGetEncoding
      .map((e) => v2NextepisodeGetEncodingFromJson(e.toString()))
      .toList();
}

String? v2NextepisodeGetMaxResToJson(
    enums.V2NextepisodeGetMaxRes? v2NextepisodeGetMaxRes) {
  return v2NextepisodeGetMaxRes?.value;
}

enums.V2NextepisodeGetMaxRes v2NextepisodeGetMaxResFromJson(
  Object? v2NextepisodeGetMaxRes, [
  enums.V2NextepisodeGetMaxRes? defaultValue,
]) {
  return enums.V2NextepisodeGetMaxRes.values
          .firstWhereOrNull((e) => e.value == v2NextepisodeGetMaxRes) ??
      defaultValue ??
      enums.V2NextepisodeGetMaxRes.swaggerGeneratedUnknown;
}

List<String> v2NextepisodeGetMaxResListToJson(
    List<enums.V2NextepisodeGetMaxRes>? v2NextepisodeGetMaxRes) {
  if (v2NextepisodeGetMaxRes == null) {
    return [];
  }

  return v2NextepisodeGetMaxRes.map((e) => e.value!).toList();
}

List<enums.V2NextepisodeGetMaxRes> v2NextepisodeGetMaxResListFromJson(
  List? v2NextepisodeGetMaxRes, [
  List<enums.V2NextepisodeGetMaxRes>? defaultValue,
]) {
  if (v2NextepisodeGetMaxRes == null) {
    return defaultValue ?? [];
  }

  return v2NextepisodeGetMaxRes
      .map((e) => v2NextepisodeGetMaxResFromJson(e.toString()))
      .toList();
}

List<enums.V2NextepisodeGetMaxRes>? v2NextepisodeGetMaxResNullableListFromJson(
  List? v2NextepisodeGetMaxRes, [
  List<enums.V2NextepisodeGetMaxRes>? defaultValue,
]) {
  if (v2NextepisodeGetMaxRes == null) {
    return defaultValue;
  }

  return v2NextepisodeGetMaxRes
      .map((e) => v2NextepisodeGetMaxResFromJson(e.toString()))
      .toList();
}

String? v2TilescreenRootIdCridGetEncodingToJson(
    enums.V2TilescreenRootIdCridGetEncoding?
        v2TilescreenRootIdCridGetEncoding) {
  return v2TilescreenRootIdCridGetEncoding?.value;
}

enums.V2TilescreenRootIdCridGetEncoding
    v2TilescreenRootIdCridGetEncodingFromJson(
  Object? v2TilescreenRootIdCridGetEncoding, [
  enums.V2TilescreenRootIdCridGetEncoding? defaultValue,
]) {
  return enums.V2TilescreenRootIdCridGetEncoding.values.firstWhereOrNull(
          (e) => e.value == v2TilescreenRootIdCridGetEncoding) ??
      defaultValue ??
      enums.V2TilescreenRootIdCridGetEncoding.swaggerGeneratedUnknown;
}

List<String> v2TilescreenRootIdCridGetEncodingListToJson(
    List<enums.V2TilescreenRootIdCridGetEncoding>?
        v2TilescreenRootIdCridGetEncoding) {
  if (v2TilescreenRootIdCridGetEncoding == null) {
    return [];
  }

  return v2TilescreenRootIdCridGetEncoding.map((e) => e.value!).toList();
}

List<enums.V2TilescreenRootIdCridGetEncoding>
    v2TilescreenRootIdCridGetEncodingListFromJson(
  List? v2TilescreenRootIdCridGetEncoding, [
  List<enums.V2TilescreenRootIdCridGetEncoding>? defaultValue,
]) {
  if (v2TilescreenRootIdCridGetEncoding == null) {
    return defaultValue ?? [];
  }

  return v2TilescreenRootIdCridGetEncoding
      .map((e) => v2TilescreenRootIdCridGetEncodingFromJson(e.toString()))
      .toList();
}

List<enums.V2TilescreenRootIdCridGetEncoding>?
    v2TilescreenRootIdCridGetEncodingNullableListFromJson(
  List? v2TilescreenRootIdCridGetEncoding, [
  List<enums.V2TilescreenRootIdCridGetEncoding>? defaultValue,
]) {
  if (v2TilescreenRootIdCridGetEncoding == null) {
    return defaultValue;
  }

  return v2TilescreenRootIdCridGetEncoding
      .map((e) => v2TilescreenRootIdCridGetEncodingFromJson(e.toString()))
      .toList();
}

String? v2TilescreenRootIdCridGetMaxResToJson(
    enums.V2TilescreenRootIdCridGetMaxRes? v2TilescreenRootIdCridGetMaxRes) {
  return v2TilescreenRootIdCridGetMaxRes?.value;
}

enums.V2TilescreenRootIdCridGetMaxRes v2TilescreenRootIdCridGetMaxResFromJson(
  Object? v2TilescreenRootIdCridGetMaxRes, [
  enums.V2TilescreenRootIdCridGetMaxRes? defaultValue,
]) {
  return enums.V2TilescreenRootIdCridGetMaxRes.values.firstWhereOrNull(
          (e) => e.value == v2TilescreenRootIdCridGetMaxRes) ??
      defaultValue ??
      enums.V2TilescreenRootIdCridGetMaxRes.swaggerGeneratedUnknown;
}

List<String> v2TilescreenRootIdCridGetMaxResListToJson(
    List<enums.V2TilescreenRootIdCridGetMaxRes>?
        v2TilescreenRootIdCridGetMaxRes) {
  if (v2TilescreenRootIdCridGetMaxRes == null) {
    return [];
  }

  return v2TilescreenRootIdCridGetMaxRes.map((e) => e.value!).toList();
}

List<enums.V2TilescreenRootIdCridGetMaxRes>
    v2TilescreenRootIdCridGetMaxResListFromJson(
  List? v2TilescreenRootIdCridGetMaxRes, [
  List<enums.V2TilescreenRootIdCridGetMaxRes>? defaultValue,
]) {
  if (v2TilescreenRootIdCridGetMaxRes == null) {
    return defaultValue ?? [];
  }

  return v2TilescreenRootIdCridGetMaxRes
      .map((e) => v2TilescreenRootIdCridGetMaxResFromJson(e.toString()))
      .toList();
}

List<enums.V2TilescreenRootIdCridGetMaxRes>?
    v2TilescreenRootIdCridGetMaxResNullableListFromJson(
  List? v2TilescreenRootIdCridGetMaxRes, [
  List<enums.V2TilescreenRootIdCridGetMaxRes>? defaultValue,
]) {
  if (v2TilescreenRootIdCridGetMaxRes == null) {
    return defaultValue;
  }

  return v2TilescreenRootIdCridGetMaxRes
      .map((e) => v2TilescreenRootIdCridGetMaxResFromJson(e.toString()))
      .toList();
}

String? v2VodscreenRootIdCridGetEncodingToJson(
    enums.V2VodscreenRootIdCridGetEncoding? v2VodscreenRootIdCridGetEncoding) {
  return v2VodscreenRootIdCridGetEncoding?.value;
}

enums.V2VodscreenRootIdCridGetEncoding v2VodscreenRootIdCridGetEncodingFromJson(
  Object? v2VodscreenRootIdCridGetEncoding, [
  enums.V2VodscreenRootIdCridGetEncoding? defaultValue,
]) {
  return enums.V2VodscreenRootIdCridGetEncoding.values.firstWhereOrNull(
          (e) => e.value == v2VodscreenRootIdCridGetEncoding) ??
      defaultValue ??
      enums.V2VodscreenRootIdCridGetEncoding.swaggerGeneratedUnknown;
}

List<String> v2VodscreenRootIdCridGetEncodingListToJson(
    List<enums.V2VodscreenRootIdCridGetEncoding>?
        v2VodscreenRootIdCridGetEncoding) {
  if (v2VodscreenRootIdCridGetEncoding == null) {
    return [];
  }

  return v2VodscreenRootIdCridGetEncoding.map((e) => e.value!).toList();
}

List<enums.V2VodscreenRootIdCridGetEncoding>
    v2VodscreenRootIdCridGetEncodingListFromJson(
  List? v2VodscreenRootIdCridGetEncoding, [
  List<enums.V2VodscreenRootIdCridGetEncoding>? defaultValue,
]) {
  if (v2VodscreenRootIdCridGetEncoding == null) {
    return defaultValue ?? [];
  }

  return v2VodscreenRootIdCridGetEncoding
      .map((e) => v2VodscreenRootIdCridGetEncodingFromJson(e.toString()))
      .toList();
}

List<enums.V2VodscreenRootIdCridGetEncoding>?
    v2VodscreenRootIdCridGetEncodingNullableListFromJson(
  List? v2VodscreenRootIdCridGetEncoding, [
  List<enums.V2VodscreenRootIdCridGetEncoding>? defaultValue,
]) {
  if (v2VodscreenRootIdCridGetEncoding == null) {
    return defaultValue;
  }

  return v2VodscreenRootIdCridGetEncoding
      .map((e) => v2VodscreenRootIdCridGetEncodingFromJson(e.toString()))
      .toList();
}

String? v2VodscreenRootIdCridGetMaxResToJson(
    enums.V2VodscreenRootIdCridGetMaxRes? v2VodscreenRootIdCridGetMaxRes) {
  return v2VodscreenRootIdCridGetMaxRes?.value;
}

enums.V2VodscreenRootIdCridGetMaxRes v2VodscreenRootIdCridGetMaxResFromJson(
  Object? v2VodscreenRootIdCridGetMaxRes, [
  enums.V2VodscreenRootIdCridGetMaxRes? defaultValue,
]) {
  return enums.V2VodscreenRootIdCridGetMaxRes.values
          .firstWhereOrNull((e) => e.value == v2VodscreenRootIdCridGetMaxRes) ??
      defaultValue ??
      enums.V2VodscreenRootIdCridGetMaxRes.swaggerGeneratedUnknown;
}

List<String> v2VodscreenRootIdCridGetMaxResListToJson(
    List<enums.V2VodscreenRootIdCridGetMaxRes>?
        v2VodscreenRootIdCridGetMaxRes) {
  if (v2VodscreenRootIdCridGetMaxRes == null) {
    return [];
  }

  return v2VodscreenRootIdCridGetMaxRes.map((e) => e.value!).toList();
}

List<enums.V2VodscreenRootIdCridGetMaxRes>
    v2VodscreenRootIdCridGetMaxResListFromJson(
  List? v2VodscreenRootIdCridGetMaxRes, [
  List<enums.V2VodscreenRootIdCridGetMaxRes>? defaultValue,
]) {
  if (v2VodscreenRootIdCridGetMaxRes == null) {
    return defaultValue ?? [];
  }

  return v2VodscreenRootIdCridGetMaxRes
      .map((e) => v2VodscreenRootIdCridGetMaxResFromJson(e.toString()))
      .toList();
}

List<enums.V2VodscreenRootIdCridGetMaxRes>?
    v2VodscreenRootIdCridGetMaxResNullableListFromJson(
  List? v2VodscreenRootIdCridGetMaxRes, [
  List<enums.V2VodscreenRootIdCridGetMaxRes>? defaultValue,
]) {
  if (v2VodscreenRootIdCridGetMaxRes == null) {
    return defaultValue;
  }

  return v2VodscreenRootIdCridGetMaxRes
      .map((e) => v2VodscreenRootIdCridGetMaxResFromJson(e.toString()))
      .toList();
}

String? v2VodstructureRootIdCridGetEncodingToJson(
    enums.V2VodstructureRootIdCridGetEncoding?
        v2VodstructureRootIdCridGetEncoding) {
  return v2VodstructureRootIdCridGetEncoding?.value;
}

enums.V2VodstructureRootIdCridGetEncoding
    v2VodstructureRootIdCridGetEncodingFromJson(
  Object? v2VodstructureRootIdCridGetEncoding, [
  enums.V2VodstructureRootIdCridGetEncoding? defaultValue,
]) {
  return enums.V2VodstructureRootIdCridGetEncoding.values.firstWhereOrNull(
          (e) => e.value == v2VodstructureRootIdCridGetEncoding) ??
      defaultValue ??
      enums.V2VodstructureRootIdCridGetEncoding.swaggerGeneratedUnknown;
}

List<String> v2VodstructureRootIdCridGetEncodingListToJson(
    List<enums.V2VodstructureRootIdCridGetEncoding>?
        v2VodstructureRootIdCridGetEncoding) {
  if (v2VodstructureRootIdCridGetEncoding == null) {
    return [];
  }

  return v2VodstructureRootIdCridGetEncoding.map((e) => e.value!).toList();
}

List<enums.V2VodstructureRootIdCridGetEncoding>
    v2VodstructureRootIdCridGetEncodingListFromJson(
  List? v2VodstructureRootIdCridGetEncoding, [
  List<enums.V2VodstructureRootIdCridGetEncoding>? defaultValue,
]) {
  if (v2VodstructureRootIdCridGetEncoding == null) {
    return defaultValue ?? [];
  }

  return v2VodstructureRootIdCridGetEncoding
      .map((e) => v2VodstructureRootIdCridGetEncodingFromJson(e.toString()))
      .toList();
}

List<enums.V2VodstructureRootIdCridGetEncoding>?
    v2VodstructureRootIdCridGetEncodingNullableListFromJson(
  List? v2VodstructureRootIdCridGetEncoding, [
  List<enums.V2VodstructureRootIdCridGetEncoding>? defaultValue,
]) {
  if (v2VodstructureRootIdCridGetEncoding == null) {
    return defaultValue;
  }

  return v2VodstructureRootIdCridGetEncoding
      .map((e) => v2VodstructureRootIdCridGetEncodingFromJson(e.toString()))
      .toList();
}

String? v2VodstructureRootIdCridGetMaxResToJson(
    enums.V2VodstructureRootIdCridGetMaxRes?
        v2VodstructureRootIdCridGetMaxRes) {
  return v2VodstructureRootIdCridGetMaxRes?.value;
}

enums.V2VodstructureRootIdCridGetMaxRes
    v2VodstructureRootIdCridGetMaxResFromJson(
  Object? v2VodstructureRootIdCridGetMaxRes, [
  enums.V2VodstructureRootIdCridGetMaxRes? defaultValue,
]) {
  return enums.V2VodstructureRootIdCridGetMaxRes.values.firstWhereOrNull(
          (e) => e.value == v2VodstructureRootIdCridGetMaxRes) ??
      defaultValue ??
      enums.V2VodstructureRootIdCridGetMaxRes.swaggerGeneratedUnknown;
}

List<String> v2VodstructureRootIdCridGetMaxResListToJson(
    List<enums.V2VodstructureRootIdCridGetMaxRes>?
        v2VodstructureRootIdCridGetMaxRes) {
  if (v2VodstructureRootIdCridGetMaxRes == null) {
    return [];
  }

  return v2VodstructureRootIdCridGetMaxRes.map((e) => e.value!).toList();
}

List<enums.V2VodstructureRootIdCridGetMaxRes>
    v2VodstructureRootIdCridGetMaxResListFromJson(
  List? v2VodstructureRootIdCridGetMaxRes, [
  List<enums.V2VodstructureRootIdCridGetMaxRes>? defaultValue,
]) {
  if (v2VodstructureRootIdCridGetMaxRes == null) {
    return defaultValue ?? [];
  }

  return v2VodstructureRootIdCridGetMaxRes
      .map((e) => v2VodstructureRootIdCridGetMaxResFromJson(e.toString()))
      .toList();
}

List<enums.V2VodstructureRootIdCridGetMaxRes>?
    v2VodstructureRootIdCridGetMaxResNullableListFromJson(
  List? v2VodstructureRootIdCridGetMaxRes, [
  List<enums.V2VodstructureRootIdCridGetMaxRes>? defaultValue,
]) {
  if (v2VodstructureRootIdCridGetMaxRes == null) {
    return defaultValue;
  }

  return v2VodstructureRootIdCridGetMaxRes
      .map((e) => v2VodstructureRootIdCridGetMaxResFromJson(e.toString()))
      .toList();
}

String? hzngoV1EditorialFeedCategoryIdGetSortTypeToJson(
    enums.HzngoV1EditorialFeedCategoryIdGetSortType?
        hzngoV1EditorialFeedCategoryIdGetSortType) {
  return hzngoV1EditorialFeedCategoryIdGetSortType?.value;
}

enums.HzngoV1EditorialFeedCategoryIdGetSortType
    hzngoV1EditorialFeedCategoryIdGetSortTypeFromJson(
  Object? hzngoV1EditorialFeedCategoryIdGetSortType, [
  enums.HzngoV1EditorialFeedCategoryIdGetSortType? defaultValue,
]) {
  return enums.HzngoV1EditorialFeedCategoryIdGetSortType.values
          .firstWhereOrNull(
              (e) => e.value == hzngoV1EditorialFeedCategoryIdGetSortType) ??
      defaultValue ??
      enums.HzngoV1EditorialFeedCategoryIdGetSortType.swaggerGeneratedUnknown;
}

List<String> hzngoV1EditorialFeedCategoryIdGetSortTypeListToJson(
    List<enums.HzngoV1EditorialFeedCategoryIdGetSortType>?
        hzngoV1EditorialFeedCategoryIdGetSortType) {
  if (hzngoV1EditorialFeedCategoryIdGetSortType == null) {
    return [];
  }

  return hzngoV1EditorialFeedCategoryIdGetSortType
      .map((e) => e.value!)
      .toList();
}

List<enums.HzngoV1EditorialFeedCategoryIdGetSortType>
    hzngoV1EditorialFeedCategoryIdGetSortTypeListFromJson(
  List? hzngoV1EditorialFeedCategoryIdGetSortType, [
  List<enums.HzngoV1EditorialFeedCategoryIdGetSortType>? defaultValue,
]) {
  if (hzngoV1EditorialFeedCategoryIdGetSortType == null) {
    return defaultValue ?? [];
  }

  return hzngoV1EditorialFeedCategoryIdGetSortType
      .map((e) =>
          hzngoV1EditorialFeedCategoryIdGetSortTypeFromJson(e.toString()))
      .toList();
}

List<enums.HzngoV1EditorialFeedCategoryIdGetSortType>?
    hzngoV1EditorialFeedCategoryIdGetSortTypeNullableListFromJson(
  List? hzngoV1EditorialFeedCategoryIdGetSortType, [
  List<enums.HzngoV1EditorialFeedCategoryIdGetSortType>? defaultValue,
]) {
  if (hzngoV1EditorialFeedCategoryIdGetSortType == null) {
    return defaultValue;
  }

  return hzngoV1EditorialFeedCategoryIdGetSortType
      .map((e) =>
          hzngoV1EditorialFeedCategoryIdGetSortTypeFromJson(e.toString()))
      .toList();
}

String? hzngoV1EditorialFeedCategoryIdGetSortDirectionToJson(
    enums.HzngoV1EditorialFeedCategoryIdGetSortDirection?
        hzngoV1EditorialFeedCategoryIdGetSortDirection) {
  return hzngoV1EditorialFeedCategoryIdGetSortDirection?.value;
}

enums.HzngoV1EditorialFeedCategoryIdGetSortDirection
    hzngoV1EditorialFeedCategoryIdGetSortDirectionFromJson(
  Object? hzngoV1EditorialFeedCategoryIdGetSortDirection, [
  enums.HzngoV1EditorialFeedCategoryIdGetSortDirection? defaultValue,
]) {
  return enums.HzngoV1EditorialFeedCategoryIdGetSortDirection.values
          .firstWhereOrNull((e) =>
              e.value == hzngoV1EditorialFeedCategoryIdGetSortDirection) ??
      defaultValue ??
      enums.HzngoV1EditorialFeedCategoryIdGetSortDirection
          .swaggerGeneratedUnknown;
}

List<String> hzngoV1EditorialFeedCategoryIdGetSortDirectionListToJson(
    List<enums.HzngoV1EditorialFeedCategoryIdGetSortDirection>?
        hzngoV1EditorialFeedCategoryIdGetSortDirection) {
  if (hzngoV1EditorialFeedCategoryIdGetSortDirection == null) {
    return [];
  }

  return hzngoV1EditorialFeedCategoryIdGetSortDirection
      .map((e) => e.value!)
      .toList();
}

List<enums.HzngoV1EditorialFeedCategoryIdGetSortDirection>
    hzngoV1EditorialFeedCategoryIdGetSortDirectionListFromJson(
  List? hzngoV1EditorialFeedCategoryIdGetSortDirection, [
  List<enums.HzngoV1EditorialFeedCategoryIdGetSortDirection>? defaultValue,
]) {
  if (hzngoV1EditorialFeedCategoryIdGetSortDirection == null) {
    return defaultValue ?? [];
  }

  return hzngoV1EditorialFeedCategoryIdGetSortDirection
      .map((e) =>
          hzngoV1EditorialFeedCategoryIdGetSortDirectionFromJson(e.toString()))
      .toList();
}

List<enums.HzngoV1EditorialFeedCategoryIdGetSortDirection>?
    hzngoV1EditorialFeedCategoryIdGetSortDirectionNullableListFromJson(
  List? hzngoV1EditorialFeedCategoryIdGetSortDirection, [
  List<enums.HzngoV1EditorialFeedCategoryIdGetSortDirection>? defaultValue,
]) {
  if (hzngoV1EditorialFeedCategoryIdGetSortDirection == null) {
    return defaultValue;
  }

  return hzngoV1EditorialFeedCategoryIdGetSortDirection
      .map((e) =>
          hzngoV1EditorialFeedCategoryIdGetSortDirectionFromJson(e.toString()))
      .toList();
}

typedef $JsonFactory<T> = T Function(Map<String, dynamic> json);

class $CustomJsonDecoder {
  $CustomJsonDecoder(this.factories);

  final Map<Type, $JsonFactory> factories;

  dynamic decode<T>(dynamic entity) {
    if (entity is Iterable) {
      return _decodeList<T>(entity);
    }

    if (entity is T) {
      return entity;
    }

    if (isTypeOf<T, Map>()) {
      return entity;
    }

    if (isTypeOf<T, Iterable>()) {
      return entity;
    }

    if (entity is Map<String, dynamic>) {
      return _decodeMap<T>(entity);
    }

    return entity;
  }

  T _decodeMap<T>(Map<String, dynamic> values) {
    final jsonFactory = factories[T];
    if (jsonFactory == null || jsonFactory is! $JsonFactory<T>) {
      return throw "Could not find factory for type $T. Is '$T: $T.fromJsonFactory' included in the CustomJsonDecoder instance creation in bootstrapper.dart?";
    }

    return jsonFactory(values);
  }

  List<T> _decodeList<T>(Iterable values) =>
      values.where((v) => v != null).map<T>((v) => decode<T>(v) as T).toList();
}

class $JsonSerializableConverter extends chopper.JsonConverter {
  @override
  FutureOr<chopper.Response<ResultType>> convertResponse<ResultType, Item>(
      chopper.Response response) async {
    if (response.bodyString.isEmpty) {
      // In rare cases, when let's say 204 (no content) is returned -
      // we cannot decode the missing json with the result type specified
      return chopper.Response(response.base, null, error: response.error);
    }

    final jsonRes = await super.convertResponse(response);
    return jsonRes.copyWith<ResultType>(
        body: $jsonDecoder.decode<Item>(jsonRes.body) as ResultType);
  }
}

final $jsonDecoder = $CustomJsonDecoder(generatedMapping);

// ignore: unused_element
String? _dateToJson(DateTime? date) {
  if (date == null) {
    return null;
  }

  final year = date.year.toString();
  final month = date.month < 10 ? '0${date.month}' : date.month.toString();
  final day = date.day < 10 ? '0${date.day}' : date.day.toString();

  return '$year-$month-$day';
}

class Wrapped<T> {
  final T value;
  const Wrapped.value(this.value);
}
